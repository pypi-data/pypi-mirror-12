# Auto-generated by BabelAPI, do not modify.
try:
    from . import babel_validators as bv
except (SystemError, ValueError):
    # Catch errors raised when importing a relative module when not in a package.
    # This makes testing this file directly (outside of a package) easier.
    import babel_validators as bv

class Role(object):
    """
    Role associated with an account.

    :ivar personal: Personal account unaffiliated with any team.
    :ivar business: Work account associated with a team.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    personal = None
    # Attribute is overwritten below the class definition
    business = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_personal(self):
        return self._tag == 'personal'

    def is_business(self):
        return self._tag == 'business'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'Role(%r)' % self._tag

class AccessInfo(object):
    """
    Access token details returned after logging in. Contains information for
    accessing other APIs as the authenticated user.

    :ivar user_id: Authenticated user's Dropbox user ID.
    :ivar oauth2_access_token: OAuth version 2 access token
    """

    __slots__ = [
        '_user_id_value',
        '_user_id_present',
        '_oauth2_access_token_value',
        '_oauth2_access_token_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 user_id=None,
                 oauth2_access_token=None):
        self._user_id_value = None
        self._user_id_present = False
        self._oauth2_access_token_value = None
        self._oauth2_access_token_present = False
        if user_id is not None:
            self.user_id = user_id
        if oauth2_access_token is not None:
            self.oauth2_access_token = oauth2_access_token

    @property
    def user_id(self):
        """
        Authenticated user's Dropbox user ID.

        :rtype: long
        """
        if self._user_id_present:
            return self._user_id_value
        else:
            raise AttributeError("missing required field 'user_id'")

    @user_id.setter
    def user_id(self, val):
        val = self._user_id_validator.validate(val)
        self._user_id_value = val
        self._user_id_present = True

    @user_id.deleter
    def user_id(self):
        self._user_id_value = None
        self._user_id_present = False

    @property
    def oauth2_access_token(self):
        """
        OAuth version 2 access token

        :rtype: str
        """
        if self._oauth2_access_token_present:
            return self._oauth2_access_token_value
        else:
            raise AttributeError("missing required field 'oauth2_access_token'")

    @oauth2_access_token.setter
    def oauth2_access_token(self, val):
        val = self._oauth2_access_token_validator.validate(val)
        self._oauth2_access_token_value = val
        self._oauth2_access_token_present = True

    @oauth2_access_token.deleter
    def oauth2_access_token(self):
        self._oauth2_access_token_value = None
        self._oauth2_access_token_present = False

    def __repr__(self):
        return 'AccessInfo(user_id={!r}, oauth2_access_token={!r})'.format(
            self._user_id_value,
            self._oauth2_access_token_value,
        )

class DeviceInfo(object):
    """
    Client device details.

    :ivar device_id: Unique ID identifying the specific client device. Can be
        generated by client code.
    :ivar device_name: User defined name for the device.
    :ivar carrier: Network carrier.
    :ivar client_locale: Locale of the client device.
    :ivar app_version: Installed version of app on client device.
    :ivar sys_model: Device hardware model.
    :ivar sys_version: Device operating system version.
    """

    __slots__ = [
        '_device_id_value',
        '_device_id_present',
        '_device_name_value',
        '_device_name_present',
        '_carrier_value',
        '_carrier_present',
        '_client_locale_value',
        '_client_locale_present',
        '_app_version_value',
        '_app_version_present',
        '_sys_model_value',
        '_sys_model_present',
        '_sys_version_value',
        '_sys_version_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 device_id=None,
                 device_name=None,
                 carrier=None,
                 client_locale=None,
                 app_version=None,
                 sys_model=None,
                 sys_version=None):
        self._device_id_value = None
        self._device_id_present = False
        self._device_name_value = None
        self._device_name_present = False
        self._carrier_value = None
        self._carrier_present = False
        self._client_locale_value = None
        self._client_locale_present = False
        self._app_version_value = None
        self._app_version_present = False
        self._sys_model_value = None
        self._sys_model_present = False
        self._sys_version_value = None
        self._sys_version_present = False
        if device_id is not None:
            self.device_id = device_id
        if device_name is not None:
            self.device_name = device_name
        if carrier is not None:
            self.carrier = carrier
        if client_locale is not None:
            self.client_locale = client_locale
        if app_version is not None:
            self.app_version = app_version
        if sys_model is not None:
            self.sys_model = sys_model
        if sys_version is not None:
            self.sys_version = sys_version

    @property
    def device_id(self):
        """
        Unique ID identifying the specific client device. Can be generated by
        client code.

        :rtype: str
        """
        if self._device_id_present:
            return self._device_id_value
        else:
            return None

    @device_id.setter
    def device_id(self, val):
        if val is None:
            del self.device_id
            return
        val = self._device_id_validator.validate(val)
        self._device_id_value = val
        self._device_id_present = True

    @device_id.deleter
    def device_id(self):
        self._device_id_value = None
        self._device_id_present = False

    @property
    def device_name(self):
        """
        User defined name for the device.

        :rtype: str
        """
        if self._device_name_present:
            return self._device_name_value
        else:
            return None

    @device_name.setter
    def device_name(self, val):
        if val is None:
            del self.device_name
            return
        val = self._device_name_validator.validate(val)
        self._device_name_value = val
        self._device_name_present = True

    @device_name.deleter
    def device_name(self):
        self._device_name_value = None
        self._device_name_present = False

    @property
    def carrier(self):
        """
        Network carrier.

        :rtype: str
        """
        if self._carrier_present:
            return self._carrier_value
        else:
            return None

    @carrier.setter
    def carrier(self, val):
        if val is None:
            del self.carrier
            return
        val = self._carrier_validator.validate(val)
        self._carrier_value = val
        self._carrier_present = True

    @carrier.deleter
    def carrier(self):
        self._carrier_value = None
        self._carrier_present = False

    @property
    def client_locale(self):
        """
        Locale of the client device.

        :rtype: str
        """
        if self._client_locale_present:
            return self._client_locale_value
        else:
            return None

    @client_locale.setter
    def client_locale(self, val):
        if val is None:
            del self.client_locale
            return
        val = self._client_locale_validator.validate(val)
        self._client_locale_value = val
        self._client_locale_present = True

    @client_locale.deleter
    def client_locale(self):
        self._client_locale_value = None
        self._client_locale_present = False

    @property
    def app_version(self):
        """
        Installed version of app on client device.

        :rtype: str
        """
        if self._app_version_present:
            return self._app_version_value
        else:
            return None

    @app_version.setter
    def app_version(self, val):
        if val is None:
            del self.app_version
            return
        val = self._app_version_validator.validate(val)
        self._app_version_value = val
        self._app_version_present = True

    @app_version.deleter
    def app_version(self):
        self._app_version_value = None
        self._app_version_present = False

    @property
    def sys_model(self):
        """
        Device hardware model.

        :rtype: str
        """
        if self._sys_model_present:
            return self._sys_model_value
        else:
            return None

    @sys_model.setter
    def sys_model(self, val):
        if val is None:
            del self.sys_model
            return
        val = self._sys_model_validator.validate(val)
        self._sys_model_value = val
        self._sys_model_present = True

    @sys_model.deleter
    def sys_model(self):
        self._sys_model_value = None
        self._sys_model_present = False

    @property
    def sys_version(self):
        """
        Device operating system version.

        :rtype: str
        """
        if self._sys_version_present:
            return self._sys_version_value
        else:
            return None

    @sys_version.setter
    def sys_version(self, val):
        if val is None:
            del self.sys_version
            return
        val = self._sys_version_validator.validate(val)
        self._sys_version_value = val
        self._sys_version_present = True

    @sys_version.deleter
    def sys_version(self):
        self._sys_version_value = None
        self._sys_version_present = False

    def __repr__(self):
        return 'DeviceInfo(device_id={!r}, device_name={!r}, carrier={!r}, client_locale={!r}, app_version={!r}, sys_model={!r}, sys_version={!r})'.format(
            self._device_id_value,
            self._device_name_value,
            self._carrier_value,
            self._client_locale_value,
            self._app_version_value,
            self._sys_model_value,
            self._sys_version_value,
        )

class ReCaptchaRequest(object):
    """
    Request for a Google reCAPTCHA response.  Clients should process the request
    and return a :class:`ReCaptchaResponse`.

    :ivar public_key: Base64 encoded reCAPTCHA public key used to encrypt
        response. This public key must be passed to reCAPTCHA servers when
        requesting the CAPTCHA.
    """

    __slots__ = [
        '_public_key_value',
        '_public_key_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 public_key=None):
        self._public_key_value = None
        self._public_key_present = False
        if public_key is not None:
            self.public_key = public_key

    @property
    def public_key(self):
        """
        Base64 encoded reCAPTCHA public key used to encrypt response. This
        public key must be passed to reCAPTCHA servers when requesting the
        CAPTCHA.

        :rtype: str
        """
        if self._public_key_present:
            return self._public_key_value
        else:
            raise AttributeError("missing required field 'public_key'")

    @public_key.setter
    def public_key(self, val):
        val = self._public_key_validator.validate(val)
        self._public_key_value = val
        self._public_key_present = True

    @public_key.deleter
    def public_key(self):
        self._public_key_value = None
        self._public_key_present = False

    def __repr__(self):
        return 'ReCaptchaRequest(public_key={!r})'.format(
            self._public_key_value,
        )

class ReCaptchaResponse(object):
    """
    reCAPTCHA response used to verify to the server the user is not a bot.  Sent
    by clients to the server after receiving a :class:`ReCaptchaRequest`.

    :ivar challenge: reCAPTCHA challenge identifier.
    :ivar challenge_response: reCAPTCHA challenge response.
    """

    __slots__ = [
        '_challenge_value',
        '_challenge_present',
        '_challenge_response_value',
        '_challenge_response_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 challenge=None,
                 challenge_response=None):
        self._challenge_value = None
        self._challenge_present = False
        self._challenge_response_value = None
        self._challenge_response_present = False
        if challenge is not None:
            self.challenge = challenge
        if challenge_response is not None:
            self.challenge_response = challenge_response

    @property
    def challenge(self):
        """
        reCAPTCHA challenge identifier.

        :rtype: str
        """
        if self._challenge_present:
            return self._challenge_value
        else:
            raise AttributeError("missing required field 'challenge'")

    @challenge.setter
    def challenge(self, val):
        val = self._challenge_validator.validate(val)
        self._challenge_value = val
        self._challenge_present = True

    @challenge.deleter
    def challenge(self):
        self._challenge_value = None
        self._challenge_present = False

    @property
    def challenge_response(self):
        """
        reCAPTCHA challenge response.

        :rtype: str
        """
        if self._challenge_response_present:
            return self._challenge_response_value
        else:
            raise AttributeError("missing required field 'challenge_response'")

    @challenge_response.setter
    def challenge_response(self, val):
        val = self._challenge_response_validator.validate(val)
        self._challenge_response_value = val
        self._challenge_response_present = True

    @challenge_response.deleter
    def challenge_response(self):
        self._challenge_response_value = None
        self._challenge_response_present = False

    def __repr__(self):
        return 'ReCaptchaResponse(challenge={!r}, challenge_response={!r})'.format(
            self._challenge_value,
            self._challenge_response_value,
        )

class LoginArg(object):
    """
    Arguments for login_with_password.

    :ivar email: User's e-mail address.
    :ivar password: User's password.
    :ivar require_role: Role user must have upon login.
    :ivar device_info: Detailed information about the client device.
    :ivar captcha: CAPTCHA response if CAPTCHA was required.
    """

    __slots__ = [
        '_email_value',
        '_email_present',
        '_password_value',
        '_password_present',
        '_require_role_value',
        '_require_role_present',
        '_device_info_value',
        '_device_info_present',
        '_captcha_value',
        '_captcha_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 email=None,
                 password=None,
                 require_role=None,
                 device_info=None,
                 captcha=None):
        self._email_value = None
        self._email_present = False
        self._password_value = None
        self._password_present = False
        self._require_role_value = None
        self._require_role_present = False
        self._device_info_value = None
        self._device_info_present = False
        self._captcha_value = None
        self._captcha_present = False
        if email is not None:
            self.email = email
        if password is not None:
            self.password = password
        if require_role is not None:
            self.require_role = require_role
        if device_info is not None:
            self.device_info = device_info
        if captcha is not None:
            self.captcha = captcha

    @property
    def email(self):
        """
        User's e-mail address.

        :rtype: str
        """
        if self._email_present:
            return self._email_value
        else:
            raise AttributeError("missing required field 'email'")

    @email.setter
    def email(self, val):
        val = self._email_validator.validate(val)
        self._email_value = val
        self._email_present = True

    @email.deleter
    def email(self):
        self._email_value = None
        self._email_present = False

    @property
    def password(self):
        """
        User's password.

        :rtype: str
        """
        if self._password_present:
            return self._password_value
        else:
            raise AttributeError("missing required field 'password'")

    @password.setter
    def password(self, val):
        val = self._password_validator.validate(val)
        self._password_value = val
        self._password_present = True

    @password.deleter
    def password(self):
        self._password_value = None
        self._password_present = False

    @property
    def require_role(self):
        """
        Role user must have upon login.

        :rtype: Role
        """
        if self._require_role_present:
            return self._require_role_value
        else:
            return None

    @require_role.setter
    def require_role(self, val):
        if val is None:
            del self.require_role
            return
        self._require_role_validator.validate_type_only(val)
        self._require_role_value = val
        self._require_role_present = True

    @require_role.deleter
    def require_role(self):
        self._require_role_value = None
        self._require_role_present = False

    @property
    def device_info(self):
        """
        Detailed information about the client device.

        :rtype: DeviceInfo
        """
        if self._device_info_present:
            return self._device_info_value
        else:
            return None

    @device_info.setter
    def device_info(self, val):
        if val is None:
            del self.device_info
            return
        self._device_info_validator.validate_type_only(val)
        self._device_info_value = val
        self._device_info_present = True

    @device_info.deleter
    def device_info(self):
        self._device_info_value = None
        self._device_info_present = False

    @property
    def captcha(self):
        """
        CAPTCHA response if CAPTCHA was required.

        :rtype: ReCaptchaResponse
        """
        if self._captcha_present:
            return self._captcha_value
        else:
            return None

    @captcha.setter
    def captcha(self, val):
        if val is None:
            del self.captcha
            return
        self._captcha_validator.validate_type_only(val)
        self._captcha_value = val
        self._captcha_present = True

    @captcha.deleter
    def captcha(self):
        self._captcha_value = None
        self._captcha_present = False

    def __repr__(self):
        return 'LoginArg(email={!r}, password={!r}, require_role={!r}, device_info={!r}, captcha={!r})'.format(
            self._email_value,
            self._password_value,
            self._require_role_value,
            self._device_info_value,
            self._captcha_value,
        )

class LoginResult(object):
    """
    Result for login_with_password.  Note that return of a result does not
    indicate successful login.  Check result to confirm whether further action
    is required.

    :ivar AccessInfo success: login is complete and an access information is
        available.
    :ivar ReCaptchaRequest requires_captcha: login requires a response to
        CAPTCHA before proceeding. Process CAPTCHA and retry with CAPTCHA
        response.
    :ivar TwoFactorAuthRequest requires_two_factor: login requires 2-factor
        authentication. Complete login using 2FA.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    @classmethod
    def success(cls, val):
        return cls('success', val)

    @classmethod
    def requires_captcha(cls, val):
        return cls('requires_captcha', val)

    @classmethod
    def requires_two_factor(cls, val):
        return cls('requires_two_factor', val)

    def is_success(self):
        return self._tag == 'success'

    def is_requires_captcha(self):
        return self._tag == 'requires_captcha'

    def is_requires_two_factor(self):
        return self._tag == 'requires_two_factor'

    def is_other(self):
        return self._tag == 'other'

    def get_success(self):
        if not self.is_success():
            raise AttributeError("tag 'success' not set")
        return self._value

    def get_requires_captcha(self):
        if not self.is_requires_captcha():
            raise AttributeError("tag 'requires_captcha' not set")
        return self._value

    def get_requires_two_factor(self):
        if not self.is_requires_two_factor():
            raise AttributeError("tag 'requires_two_factor' not set")
        return self._value

    def __repr__(self):
        return 'LoginResult(%r)' % self._tag

class LoginError(object):
    """
    Error returned by login_with_password.

    :ivar credentials_expired: User's password has expired. An e-mail will be
        sent to the user with further instructions.
    :ivar credentials_invalid: Incorrect e-mail or password.
    :ivar login_rate_exceeded: Too many login attempts have been made.  Try
        again later.
    :ivar SmsError sms_error: Unable to send SMS to phone registered for
        two-factor authentication.
    :ivar two_factor_not_enabled: User's administrator requires two-factor
        authentication but the user does not have it enabled.  Two-factor
        authentication must be enabled through a web browser to login.
    :ivar role_mismatch: User does not the required role (e.g. business,
        personal) to complete request.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    credentials_expired = None
    # Attribute is overwritten below the class definition
    credentials_invalid = None
    # Attribute is overwritten below the class definition
    login_rate_exceeded = None
    # Attribute is overwritten below the class definition
    two_factor_not_enabled = None
    # Attribute is overwritten below the class definition
    role_mismatch = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    @classmethod
    def sms_error(cls, val):
        return cls('sms_error', val)

    def is_credentials_expired(self):
        return self._tag == 'credentials_expired'

    def is_credentials_invalid(self):
        return self._tag == 'credentials_invalid'

    def is_login_rate_exceeded(self):
        return self._tag == 'login_rate_exceeded'

    def is_sms_error(self):
        return self._tag == 'sms_error'

    def is_two_factor_not_enabled(self):
        return self._tag == 'two_factor_not_enabled'

    def is_role_mismatch(self):
        return self._tag == 'role_mismatch'

    def is_other(self):
        return self._tag == 'other'

    def get_sms_error(self):
        if not self.is_sms_error():
            raise AttributeError("tag 'sms_error' not set")
        return self._value

    def __repr__(self):
        return 'LoginError(%r)' % self._tag

class SmsError(object):
    """
    Error sending an SMS to a mobile phone.

    :ivar phone_suffix: Last 4 digits of the mobile phone number.
    :ivar reason: Reason for SMS failure.
    """

    __slots__ = [
        '_phone_suffix_value',
        '_phone_suffix_present',
        '_reason_value',
        '_reason_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 phone_suffix=None,
                 reason=None):
        self._phone_suffix_value = None
        self._phone_suffix_present = False
        self._reason_value = None
        self._reason_present = False
        if phone_suffix is not None:
            self.phone_suffix = phone_suffix
        if reason is not None:
            self.reason = reason

    @property
    def phone_suffix(self):
        """
        Last 4 digits of the mobile phone number.

        :rtype: str
        """
        if self._phone_suffix_present:
            return self._phone_suffix_value
        else:
            raise AttributeError("missing required field 'phone_suffix'")

    @phone_suffix.setter
    def phone_suffix(self, val):
        val = self._phone_suffix_validator.validate(val)
        self._phone_suffix_value = val
        self._phone_suffix_present = True

    @phone_suffix.deleter
    def phone_suffix(self):
        self._phone_suffix_value = None
        self._phone_suffix_present = False

    @property
    def reason(self):
        """
        Reason for SMS failure.

        :rtype: SmsErrorReason
        """
        if self._reason_present:
            return self._reason_value
        else:
            raise AttributeError("missing required field 'reason'")

    @reason.setter
    def reason(self, val):
        self._reason_validator.validate_type_only(val)
        self._reason_value = val
        self._reason_present = True

    @reason.deleter
    def reason(self):
        self._reason_value = None
        self._reason_present = False

    def __repr__(self):
        return 'SmsError(phone_suffix={!r}, reason={!r})'.format(
            self._phone_suffix_value,
            self._reason_value,
        )

class SmsErrorReason(object):
    """
    Reason an SMS error occurred (see :class:`SmsError`)

    :ivar number_invalid: Mobile phone number is invalid.  This could indicate
        the number is malformed or is not registered to an SMS-enabled device.
    :ivar carrier_unsupported: Mobile phone number is registered with an
        unsupported network carrier.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = None
    # Attribute is overwritten below the class definition
    number_invalid = None
    # Attribute is overwritten below the class definition
    carrier_unsupported = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_number_invalid(self):
        return self._tag == 'number_invalid'

    def is_carrier_unsupported(self):
        return self._tag == 'carrier_unsupported'

    def __repr__(self):
        return 'SmsErrorReason(%r)' % self._tag

class TwoFactorAuthRequest(object):
    """
    Result for login_with_password if 2-factor authentication is enabled on the
    account.  Clients should continue the login process using two_factor/verify.

    :ivar checkpoint_token: Temporary token used to track 2-factor
        authentication session.
    :ivar checkpoint_token_expires: Expiration time of ``checkpoint_token``.
    :ivar delivery_mode: Preferred form of receiving second factor of
        authentication.
    """

    __slots__ = [
        '_checkpoint_token_value',
        '_checkpoint_token_present',
        '_checkpoint_token_expires_value',
        '_checkpoint_token_expires_present',
        '_delivery_mode_value',
        '_delivery_mode_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 checkpoint_token=None,
                 checkpoint_token_expires=None,
                 delivery_mode=None):
        self._checkpoint_token_value = None
        self._checkpoint_token_present = False
        self._checkpoint_token_expires_value = None
        self._checkpoint_token_expires_present = False
        self._delivery_mode_value = None
        self._delivery_mode_present = False
        if checkpoint_token is not None:
            self.checkpoint_token = checkpoint_token
        if checkpoint_token_expires is not None:
            self.checkpoint_token_expires = checkpoint_token_expires
        if delivery_mode is not None:
            self.delivery_mode = delivery_mode

    @property
    def checkpoint_token(self):
        """
        Temporary token used to track 2-factor authentication session.

        :rtype: str
        """
        if self._checkpoint_token_present:
            return self._checkpoint_token_value
        else:
            raise AttributeError("missing required field 'checkpoint_token'")

    @checkpoint_token.setter
    def checkpoint_token(self, val):
        val = self._checkpoint_token_validator.validate(val)
        self._checkpoint_token_value = val
        self._checkpoint_token_present = True

    @checkpoint_token.deleter
    def checkpoint_token(self):
        self._checkpoint_token_value = None
        self._checkpoint_token_present = False

    @property
    def checkpoint_token_expires(self):
        """
        Expiration time of ``checkpoint_token``.

        :rtype: datetime.datetime
        """
        if self._checkpoint_token_expires_present:
            return self._checkpoint_token_expires_value
        else:
            raise AttributeError("missing required field 'checkpoint_token_expires'")

    @checkpoint_token_expires.setter
    def checkpoint_token_expires(self, val):
        val = self._checkpoint_token_expires_validator.validate(val)
        self._checkpoint_token_expires_value = val
        self._checkpoint_token_expires_present = True

    @checkpoint_token_expires.deleter
    def checkpoint_token_expires(self):
        self._checkpoint_token_expires_value = None
        self._checkpoint_token_expires_present = False

    @property
    def delivery_mode(self):
        """
        Preferred form of receiving second factor of authentication.

        :rtype: TwoFactorDeliveryMode
        """
        if self._delivery_mode_present:
            return self._delivery_mode_value
        else:
            raise AttributeError("missing required field 'delivery_mode'")

    @delivery_mode.setter
    def delivery_mode(self, val):
        self._delivery_mode_validator.validate_type_only(val)
        self._delivery_mode_value = val
        self._delivery_mode_present = True

    @delivery_mode.deleter
    def delivery_mode(self):
        self._delivery_mode_value = None
        self._delivery_mode_present = False

    def __repr__(self):
        return 'TwoFactorAuthRequest(checkpoint_token={!r}, checkpoint_token_expires={!r}, delivery_mode={!r})'.format(
            self._checkpoint_token_value,
            self._checkpoint_token_expires_value,
            self._delivery_mode_value,
        )

class TwoFactorDeliveryMode(object):
    """
    Method of delivering the second factor to the user.

    :ivar offline: Factor will be provided by an authenticator app, like Google
        Authenticator.
    :ivar str sms: Factor will be provided through SMS (text).  Value is the
        last 4 digits of phone number that will receive the SMS.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    offline = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    @classmethod
    def sms(cls, val):
        return cls('sms', val)

    def is_offline(self):
        return self._tag == 'offline'

    def is_sms(self):
        return self._tag == 'sms'

    def is_other(self):
        return self._tag == 'other'

    def get_sms(self):
        if not self.is_sms():
            raise AttributeError("tag 'sms' not set")
        return self._value

    def __repr__(self):
        return 'TwoFactorDeliveryMode(%r)' % self._tag

class TwoFactorVerifyArg(object):
    """
    Arguments for two_factor/verify.

    :ivar checkpoint_token: Temporary token used to track two-factor
        authentication session.
    :ivar two_factor_code: Second factor provided by user for authentication
        (e.g. SMS code, Google authenticator code).
    :ivar device_info: Detailed information about the client device.
    """

    __slots__ = [
        '_checkpoint_token_value',
        '_checkpoint_token_present',
        '_two_factor_code_value',
        '_two_factor_code_present',
        '_device_info_value',
        '_device_info_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 checkpoint_token=None,
                 two_factor_code=None,
                 device_info=None):
        self._checkpoint_token_value = None
        self._checkpoint_token_present = False
        self._two_factor_code_value = None
        self._two_factor_code_present = False
        self._device_info_value = None
        self._device_info_present = False
        if checkpoint_token is not None:
            self.checkpoint_token = checkpoint_token
        if two_factor_code is not None:
            self.two_factor_code = two_factor_code
        if device_info is not None:
            self.device_info = device_info

    @property
    def checkpoint_token(self):
        """
        Temporary token used to track two-factor authentication session.

        :rtype: str
        """
        if self._checkpoint_token_present:
            return self._checkpoint_token_value
        else:
            raise AttributeError("missing required field 'checkpoint_token'")

    @checkpoint_token.setter
    def checkpoint_token(self, val):
        val = self._checkpoint_token_validator.validate(val)
        self._checkpoint_token_value = val
        self._checkpoint_token_present = True

    @checkpoint_token.deleter
    def checkpoint_token(self):
        self._checkpoint_token_value = None
        self._checkpoint_token_present = False

    @property
    def two_factor_code(self):
        """
        Second factor provided by user for authentication (e.g. SMS code, Google
        authenticator code).

        :rtype: str
        """
        if self._two_factor_code_present:
            return self._two_factor_code_value
        else:
            raise AttributeError("missing required field 'two_factor_code'")

    @two_factor_code.setter
    def two_factor_code(self, val):
        val = self._two_factor_code_validator.validate(val)
        self._two_factor_code_value = val
        self._two_factor_code_present = True

    @two_factor_code.deleter
    def two_factor_code(self):
        self._two_factor_code_value = None
        self._two_factor_code_present = False

    @property
    def device_info(self):
        """
        Detailed information about the client device.

        :rtype: DeviceInfo
        """
        if self._device_info_present:
            return self._device_info_value
        else:
            return None

    @device_info.setter
    def device_info(self, val):
        if val is None:
            del self.device_info
            return
        self._device_info_validator.validate_type_only(val)
        self._device_info_value = val
        self._device_info_present = True

    @device_info.deleter
    def device_info(self):
        self._device_info_value = None
        self._device_info_present = False

    def __repr__(self):
        return 'TwoFactorVerifyArg(checkpoint_token={!r}, two_factor_code={!r}, device_info={!r})'.format(
            self._checkpoint_token_value,
            self._two_factor_code_value,
            self._device_info_value,
        )

class TwoFactorVerifyError(object):
    """
    Error returned by two_factor/verify.

    :ivar two_factor_code_invalid: The two-factor authentication code,
        ``TwoFactorVerifyArg.two_factor_code``, is invalid.
    :ivar checkpoint_token_invalid: Checkpoint token,
        ``TwoFactorVerifyArg.checkpoint_token``, is invalid.  The token may be
        malformed or may have expired. Attempt login again by calling
        login_with_password to obtain a new checkpoint token.
    :ivar login_rate_exceeded: Too many login attempts have been made.  Try
        again later.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    two_factor_code_invalid = None
    # Attribute is overwritten below the class definition
    checkpoint_token_invalid = None
    # Attribute is overwritten below the class definition
    login_rate_exceeded = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_two_factor_code_invalid(self):
        return self._tag == 'two_factor_code_invalid'

    def is_checkpoint_token_invalid(self):
        return self._tag == 'checkpoint_token_invalid'

    def is_login_rate_exceeded(self):
        return self._tag == 'login_rate_exceeded'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'TwoFactorVerifyError(%r)' % self._tag

Role._personal_validator = bv.Void()
Role._business_validator = bv.Void()
Role._other_validator = bv.Void()
Role._tagmap = {
    'personal': Role._personal_validator,
    'business': Role._business_validator,
    'other': Role._other_validator,
}

Role.personal = Role('personal')
Role.business = Role('business')
Role.other = Role('other')

AccessInfo._user_id_validator = bv.Int64()
AccessInfo._oauth2_access_token_validator = bv.String()
AccessInfo._all_field_names_ = set([
    'user_id',
    'oauth2_access_token',
])
AccessInfo._all_fields_ = [
    ('user_id', AccessInfo._user_id_validator),
    ('oauth2_access_token', AccessInfo._oauth2_access_token_validator),
]

DeviceInfo._device_id_validator = bv.Nullable(bv.String())
DeviceInfo._device_name_validator = bv.Nullable(bv.String())
DeviceInfo._carrier_validator = bv.Nullable(bv.String())
DeviceInfo._client_locale_validator = bv.Nullable(bv.String())
DeviceInfo._app_version_validator = bv.Nullable(bv.String())
DeviceInfo._sys_model_validator = bv.Nullable(bv.String())
DeviceInfo._sys_version_validator = bv.Nullable(bv.String())
DeviceInfo._all_field_names_ = set([
    'device_id',
    'device_name',
    'carrier',
    'client_locale',
    'app_version',
    'sys_model',
    'sys_version',
])
DeviceInfo._all_fields_ = [
    ('device_id', DeviceInfo._device_id_validator),
    ('device_name', DeviceInfo._device_name_validator),
    ('carrier', DeviceInfo._carrier_validator),
    ('client_locale', DeviceInfo._client_locale_validator),
    ('app_version', DeviceInfo._app_version_validator),
    ('sys_model', DeviceInfo._sys_model_validator),
    ('sys_version', DeviceInfo._sys_version_validator),
]

ReCaptchaRequest._public_key_validator = bv.String()
ReCaptchaRequest._all_field_names_ = set(['public_key'])
ReCaptchaRequest._all_fields_ = [('public_key', ReCaptchaRequest._public_key_validator)]

ReCaptchaResponse._challenge_validator = bv.String()
ReCaptchaResponse._challenge_response_validator = bv.String()
ReCaptchaResponse._all_field_names_ = set([
    'challenge',
    'challenge_response',
])
ReCaptchaResponse._all_fields_ = [
    ('challenge', ReCaptchaResponse._challenge_validator),
    ('challenge_response', ReCaptchaResponse._challenge_response_validator),
]

LoginArg._email_validator = bv.String()
LoginArg._password_validator = bv.String()
LoginArg._require_role_validator = bv.Nullable(bv.Union(Role))
LoginArg._device_info_validator = bv.Nullable(bv.Struct(DeviceInfo))
LoginArg._captcha_validator = bv.Nullable(bv.Struct(ReCaptchaResponse))
LoginArg._all_field_names_ = set([
    'email',
    'password',
    'require_role',
    'device_info',
    'captcha',
])
LoginArg._all_fields_ = [
    ('email', LoginArg._email_validator),
    ('password', LoginArg._password_validator),
    ('require_role', LoginArg._require_role_validator),
    ('device_info', LoginArg._device_info_validator),
    ('captcha', LoginArg._captcha_validator),
]

LoginResult._success_validator = bv.Struct(AccessInfo)
LoginResult._requires_captcha_validator = bv.Struct(ReCaptchaRequest)
LoginResult._requires_two_factor_validator = bv.Struct(TwoFactorAuthRequest)
LoginResult._other_validator = bv.Void()
LoginResult._tagmap = {
    'success': LoginResult._success_validator,
    'requires_captcha': LoginResult._requires_captcha_validator,
    'requires_two_factor': LoginResult._requires_two_factor_validator,
    'other': LoginResult._other_validator,
}

LoginResult.other = LoginResult('other')

LoginError._credentials_expired_validator = bv.Void()
LoginError._credentials_invalid_validator = bv.Void()
LoginError._login_rate_exceeded_validator = bv.Void()
LoginError._sms_error_validator = bv.Struct(SmsError)
LoginError._two_factor_not_enabled_validator = bv.Void()
LoginError._role_mismatch_validator = bv.Void()
LoginError._other_validator = bv.Void()
LoginError._tagmap = {
    'credentials_expired': LoginError._credentials_expired_validator,
    'credentials_invalid': LoginError._credentials_invalid_validator,
    'login_rate_exceeded': LoginError._login_rate_exceeded_validator,
    'sms_error': LoginError._sms_error_validator,
    'two_factor_not_enabled': LoginError._two_factor_not_enabled_validator,
    'role_mismatch': LoginError._role_mismatch_validator,
    'other': LoginError._other_validator,
}

LoginError.credentials_expired = LoginError('credentials_expired')
LoginError.credentials_invalid = LoginError('credentials_invalid')
LoginError.login_rate_exceeded = LoginError('login_rate_exceeded')
LoginError.two_factor_not_enabled = LoginError('two_factor_not_enabled')
LoginError.role_mismatch = LoginError('role_mismatch')
LoginError.other = LoginError('other')

SmsError._phone_suffix_validator = bv.String()
SmsError._reason_validator = bv.Union(SmsErrorReason)
SmsError._all_field_names_ = set([
    'phone_suffix',
    'reason',
])
SmsError._all_fields_ = [
    ('phone_suffix', SmsError._phone_suffix_validator),
    ('reason', SmsError._reason_validator),
]

SmsErrorReason._number_invalid_validator = bv.Void()
SmsErrorReason._carrier_unsupported_validator = bv.Void()
SmsErrorReason._tagmap = {
    'number_invalid': SmsErrorReason._number_invalid_validator,
    'carrier_unsupported': SmsErrorReason._carrier_unsupported_validator,
}

SmsErrorReason.number_invalid = SmsErrorReason('number_invalid')
SmsErrorReason.carrier_unsupported = SmsErrorReason('carrier_unsupported')

TwoFactorAuthRequest._checkpoint_token_validator = bv.String()
TwoFactorAuthRequest._checkpoint_token_expires_validator = bv.Timestamp(u'%Y-%m-%dT%H:%M:%SZ')
TwoFactorAuthRequest._delivery_mode_validator = bv.Union(TwoFactorDeliveryMode)
TwoFactorAuthRequest._all_field_names_ = set([
    'checkpoint_token',
    'checkpoint_token_expires',
    'delivery_mode',
])
TwoFactorAuthRequest._all_fields_ = [
    ('checkpoint_token', TwoFactorAuthRequest._checkpoint_token_validator),
    ('checkpoint_token_expires', TwoFactorAuthRequest._checkpoint_token_expires_validator),
    ('delivery_mode', TwoFactorAuthRequest._delivery_mode_validator),
]

TwoFactorDeliveryMode._offline_validator = bv.Void()
TwoFactorDeliveryMode._sms_validator = bv.String()
TwoFactorDeliveryMode._other_validator = bv.Void()
TwoFactorDeliveryMode._tagmap = {
    'offline': TwoFactorDeliveryMode._offline_validator,
    'sms': TwoFactorDeliveryMode._sms_validator,
    'other': TwoFactorDeliveryMode._other_validator,
}

TwoFactorDeliveryMode.offline = TwoFactorDeliveryMode('offline')
TwoFactorDeliveryMode.other = TwoFactorDeliveryMode('other')

TwoFactorVerifyArg._checkpoint_token_validator = bv.String()
TwoFactorVerifyArg._two_factor_code_validator = bv.String()
TwoFactorVerifyArg._device_info_validator = bv.Nullable(bv.Struct(DeviceInfo))
TwoFactorVerifyArg._all_field_names_ = set([
    'checkpoint_token',
    'two_factor_code',
    'device_info',
])
TwoFactorVerifyArg._all_fields_ = [
    ('checkpoint_token', TwoFactorVerifyArg._checkpoint_token_validator),
    ('two_factor_code', TwoFactorVerifyArg._two_factor_code_validator),
    ('device_info', TwoFactorVerifyArg._device_info_validator),
]

TwoFactorVerifyError._two_factor_code_invalid_validator = bv.Void()
TwoFactorVerifyError._checkpoint_token_invalid_validator = bv.Void()
TwoFactorVerifyError._login_rate_exceeded_validator = bv.Void()
TwoFactorVerifyError._other_validator = bv.Void()
TwoFactorVerifyError._tagmap = {
    'two_factor_code_invalid': TwoFactorVerifyError._two_factor_code_invalid_validator,
    'checkpoint_token_invalid': TwoFactorVerifyError._checkpoint_token_invalid_validator,
    'login_rate_exceeded': TwoFactorVerifyError._login_rate_exceeded_validator,
    'other': TwoFactorVerifyError._other_validator,
}

TwoFactorVerifyError.two_factor_code_invalid = TwoFactorVerifyError('two_factor_code_invalid')
TwoFactorVerifyError.checkpoint_token_invalid = TwoFactorVerifyError('checkpoint_token_invalid')
TwoFactorVerifyError.login_rate_exceeded = TwoFactorVerifyError('login_rate_exceeded')
TwoFactorVerifyError.other = TwoFactorVerifyError('other')

