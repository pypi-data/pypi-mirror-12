# Auto-generated by BabelAPI, do not modify.
try:
    from . import babel_validators as bv
except (SystemError, ValueError):
    # Catch errors raised when importing a relative module when not in a package.
    # This makes testing this file directly (outside of a package) easier.
    import babel_validators as bv

try:
    from . import (
        async,
        users,
    )
except (SystemError, ValueError):
    import async
    import users

class MemberProfile(object):
    """
    Basic member profile.

    :ivar member_id: ID of user as a member of a team. The value of this ID is
        guaranteed to stay the same. Other identifiers (such as account_id) may
        change, especially in the transition of a user being invited to team, to
        the user being a member of the team.
    :ivar account_id: The user's unique Dropbox ID. Note that the account ID
        that is associated with a specific member_id may change in certain
        conditions.
    :ivar external_id: External ID that a team can attach to the user. An
        application using the API may find it easier to use their own IDs
        instead of Dropbox IDs like account_id or member_id.
    :ivar email: Email address of user.
    :ivar email_verified: Is true if the user's email is verified to be owned by
        the user.
    :ivar name: Representations for a person's name.
    """

    __slots__ = [
        '_member_id_value',
        '_member_id_present',
        '_account_id_value',
        '_account_id_present',
        '_external_id_value',
        '_external_id_present',
        '_email_value',
        '_email_present',
        '_email_verified_value',
        '_email_verified_present',
        '_name_value',
        '_name_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 member_id=None,
                 account_id=None,
                 email=None,
                 email_verified=None,
                 name=None,
                 external_id=None):
        self._member_id_value = None
        self._member_id_present = False
        self._account_id_value = None
        self._account_id_present = False
        self._external_id_value = None
        self._external_id_present = False
        self._email_value = None
        self._email_present = False
        self._email_verified_value = None
        self._email_verified_present = False
        self._name_value = None
        self._name_present = False
        if member_id is not None:
            self.member_id = member_id
        if account_id is not None:
            self.account_id = account_id
        if external_id is not None:
            self.external_id = external_id
        if email is not None:
            self.email = email
        if email_verified is not None:
            self.email_verified = email_verified
        if name is not None:
            self.name = name

    @property
    def member_id(self):
        """
        ID of user as a member of a team. The value of this ID is guaranteed to
        stay the same. Other identifiers (such as account_id) may change,
        especially in the transition of a user being invited to team, to the
        user being a member of the team.

        :rtype: str
        """
        if self._member_id_present:
            return self._member_id_value
        else:
            raise AttributeError("missing required field 'member_id'")

    @member_id.setter
    def member_id(self, val):
        val = self._member_id_validator.validate(val)
        self._member_id_value = val
        self._member_id_present = True

    @member_id.deleter
    def member_id(self):
        self._member_id_value = None
        self._member_id_present = False

    @property
    def account_id(self):
        """
        The user's unique Dropbox ID. Note that the account ID that is
        associated with a specific member_id may change in certain conditions.

        :rtype: str
        """
        if self._account_id_present:
            return self._account_id_value
        else:
            raise AttributeError("missing required field 'account_id'")

    @account_id.setter
    def account_id(self, val):
        val = self._account_id_validator.validate(val)
        self._account_id_value = val
        self._account_id_present = True

    @account_id.deleter
    def account_id(self):
        self._account_id_value = None
        self._account_id_present = False

    @property
    def external_id(self):
        """
        External ID that a team can attach to the user. An application using the
        API may find it easier to use their own IDs instead of Dropbox IDs like
        account_id or member_id.

        :rtype: str
        """
        if self._external_id_present:
            return self._external_id_value
        else:
            return None

    @external_id.setter
    def external_id(self, val):
        if val is None:
            del self.external_id
            return
        val = self._external_id_validator.validate(val)
        self._external_id_value = val
        self._external_id_present = True

    @external_id.deleter
    def external_id(self):
        self._external_id_value = None
        self._external_id_present = False

    @property
    def email(self):
        """
        Email address of user.

        :rtype: str
        """
        if self._email_present:
            return self._email_value
        else:
            raise AttributeError("missing required field 'email'")

    @email.setter
    def email(self, val):
        val = self._email_validator.validate(val)
        self._email_value = val
        self._email_present = True

    @email.deleter
    def email(self):
        self._email_value = None
        self._email_present = False

    @property
    def email_verified(self):
        """
        Is true if the user's email is verified to be owned by the user.

        :rtype: bool
        """
        if self._email_verified_present:
            return self._email_verified_value
        else:
            raise AttributeError("missing required field 'email_verified'")

    @email_verified.setter
    def email_verified(self, val):
        val = self._email_verified_validator.validate(val)
        self._email_verified_value = val
        self._email_verified_present = True

    @email_verified.deleter
    def email_verified(self):
        self._email_verified_value = None
        self._email_verified_present = False

    @property
    def name(self):
        """
        Representations for a person's name.

        :rtype: users.Name
        """
        if self._name_present:
            return self._name_value
        else:
            raise AttributeError("missing required field 'name'")

    @name.setter
    def name(self, val):
        self._name_validator.validate_type_only(val)
        self._name_value = val
        self._name_present = True

    @name.deleter
    def name(self):
        self._name_value = None
        self._name_present = False

    def __repr__(self):
        return 'MemberProfile(member_id={!r}, account_id={!r}, email={!r}, email_verified={!r}, name={!r}, external_id={!r})'.format(
            self._member_id_value,
            self._account_id_value,
            self._email_value,
            self._email_verified_value,
            self._name_value,
            self._external_id_value,
        )

class UserSelectorArg(object):
    """
    Argument for selecting a single user, either by member_id, external_id or
    email.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    @classmethod
    def member_id(cls, val):
        return cls('member_id', val)

    @classmethod
    def external_id(cls, val):
        return cls('external_id', val)

    @classmethod
    def email(cls, val):
        return cls('email', val)

    def is_member_id(self):
        return self._tag == 'member_id'

    def is_external_id(self):
        return self._tag == 'external_id'

    def is_email(self):
        return self._tag == 'email'

    def get_member_id(self):
        if not self.is_member_id():
            raise AttributeError("tag 'member_id' not set")
        return self._value

    def get_external_id(self):
        if not self.is_external_id():
            raise AttributeError("tag 'external_id' not set")
        return self._value

    def get_email(self):
        if not self.is_email():
            raise AttributeError("tag 'email' not set")
        return self._value

    def __repr__(self):
        return 'UserSelectorArg(%r)' % self._tag

class UserSelectorError(object):
    """
    Error that can be returned whenever a struct derived from
    :class:`UserSelectorArg` is used.

    :ivar user_not_found: No matching user found. The provided member_id, email,
        or external_id does not exist on this team.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = None
    # Attribute is overwritten below the class definition
    user_not_found = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_user_not_found(self):
        return self._tag == 'user_not_found'

    def __repr__(self):
        return 'UserSelectorError(%r)' % self._tag

class UsersSelectorArg(object):
    """
    Argument for selecting a list of users, either by member_ids, external_ids
    or emails.

    :ivar list of [str] member_ids: List of member IDs.
    :ivar list of [str] external_ids: List of external user IDs.
    :ivar list of [str] emails: List of email addresses.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    @classmethod
    def member_ids(cls, val):
        return cls('member_ids', val)

    @classmethod
    def external_ids(cls, val):
        return cls('external_ids', val)

    @classmethod
    def emails(cls, val):
        return cls('emails', val)

    def is_member_ids(self):
        return self._tag == 'member_ids'

    def is_external_ids(self):
        return self._tag == 'external_ids'

    def is_emails(self):
        return self._tag == 'emails'

    def get_member_ids(self):
        if not self.is_member_ids():
            raise AttributeError("tag 'member_ids' not set")
        return self._value

    def get_external_ids(self):
        if not self.is_external_ids():
            raise AttributeError("tag 'external_ids' not set")
        return self._value

    def get_emails(self):
        if not self.is_emails():
            raise AttributeError("tag 'emails' not set")
        return self._value

    def __repr__(self):
        return 'UsersSelectorArg(%r)' % self._tag

class TeamGetInfoResult(object):
    """
    :ivar name: The name of the team.
    :ivar team_id: The ID of the team.
    :ivar num_licensed_users: The number of licenses available to the team.
    :ivar num_provisioned_users: The number of accounts that have been invited
        or are already active members of the team.
    """

    __slots__ = [
        '_name_value',
        '_name_present',
        '_team_id_value',
        '_team_id_present',
        '_num_licensed_users_value',
        '_num_licensed_users_present',
        '_num_provisioned_users_value',
        '_num_provisioned_users_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 name=None,
                 team_id=None,
                 num_licensed_users=None,
                 num_provisioned_users=None):
        self._name_value = None
        self._name_present = False
        self._team_id_value = None
        self._team_id_present = False
        self._num_licensed_users_value = None
        self._num_licensed_users_present = False
        self._num_provisioned_users_value = None
        self._num_provisioned_users_present = False
        if name is not None:
            self.name = name
        if team_id is not None:
            self.team_id = team_id
        if num_licensed_users is not None:
            self.num_licensed_users = num_licensed_users
        if num_provisioned_users is not None:
            self.num_provisioned_users = num_provisioned_users

    @property
    def name(self):
        """
        The name of the team.

        :rtype: str
        """
        if self._name_present:
            return self._name_value
        else:
            raise AttributeError("missing required field 'name'")

    @name.setter
    def name(self, val):
        val = self._name_validator.validate(val)
        self._name_value = val
        self._name_present = True

    @name.deleter
    def name(self):
        self._name_value = None
        self._name_present = False

    @property
    def team_id(self):
        """
        The ID of the team.

        :rtype: str
        """
        if self._team_id_present:
            return self._team_id_value
        else:
            raise AttributeError("missing required field 'team_id'")

    @team_id.setter
    def team_id(self, val):
        val = self._team_id_validator.validate(val)
        self._team_id_value = val
        self._team_id_present = True

    @team_id.deleter
    def team_id(self):
        self._team_id_value = None
        self._team_id_present = False

    @property
    def num_licensed_users(self):
        """
        The number of licenses available to the team.

        :rtype: long
        """
        if self._num_licensed_users_present:
            return self._num_licensed_users_value
        else:
            raise AttributeError("missing required field 'num_licensed_users'")

    @num_licensed_users.setter
    def num_licensed_users(self, val):
        val = self._num_licensed_users_validator.validate(val)
        self._num_licensed_users_value = val
        self._num_licensed_users_present = True

    @num_licensed_users.deleter
    def num_licensed_users(self):
        self._num_licensed_users_value = None
        self._num_licensed_users_present = False

    @property
    def num_provisioned_users(self):
        """
        The number of accounts that have been invited or are already active
        members of the team.

        :rtype: long
        """
        if self._num_provisioned_users_present:
            return self._num_provisioned_users_value
        else:
            raise AttributeError("missing required field 'num_provisioned_users'")

    @num_provisioned_users.setter
    def num_provisioned_users(self, val):
        val = self._num_provisioned_users_validator.validate(val)
        self._num_provisioned_users_value = val
        self._num_provisioned_users_present = True

    @num_provisioned_users.deleter
    def num_provisioned_users(self):
        self._num_provisioned_users_value = None
        self._num_provisioned_users_present = False

    def __repr__(self):
        return 'TeamGetInfoResult(name={!r}, team_id={!r}, num_licensed_users={!r}, num_provisioned_users={!r})'.format(
            self._name_value,
            self._team_id_value,
            self._num_licensed_users_value,
            self._num_provisioned_users_value,
        )

class ListMemberDevicesArg(object):
    """
    :ivar member_id: The team's member id
    :ivar include_web_sessions: Whether to list web sessions of the team's
        member
    :ivar include_desktop_clients: Whether to list linked desktop devices of the
        team's member
    :ivar include_mobile_clients: Whether to list linked mobile devices of the
        team's member
    """

    __slots__ = [
        '_member_id_value',
        '_member_id_present',
        '_include_web_sessions_value',
        '_include_web_sessions_present',
        '_include_desktop_clients_value',
        '_include_desktop_clients_present',
        '_include_mobile_clients_value',
        '_include_mobile_clients_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 member_id=None,
                 include_web_sessions=None,
                 include_desktop_clients=None,
                 include_mobile_clients=None):
        self._member_id_value = None
        self._member_id_present = False
        self._include_web_sessions_value = None
        self._include_web_sessions_present = False
        self._include_desktop_clients_value = None
        self._include_desktop_clients_present = False
        self._include_mobile_clients_value = None
        self._include_mobile_clients_present = False
        if member_id is not None:
            self.member_id = member_id
        if include_web_sessions is not None:
            self.include_web_sessions = include_web_sessions
        if include_desktop_clients is not None:
            self.include_desktop_clients = include_desktop_clients
        if include_mobile_clients is not None:
            self.include_mobile_clients = include_mobile_clients

    @property
    def member_id(self):
        """
        The team's member id

        :rtype: str
        """
        if self._member_id_present:
            return self._member_id_value
        else:
            raise AttributeError("missing required field 'member_id'")

    @member_id.setter
    def member_id(self, val):
        val = self._member_id_validator.validate(val)
        self._member_id_value = val
        self._member_id_present = True

    @member_id.deleter
    def member_id(self):
        self._member_id_value = None
        self._member_id_present = False

    @property
    def include_web_sessions(self):
        """
        Whether to list web sessions of the team's member

        :rtype: bool
        """
        if self._include_web_sessions_present:
            return self._include_web_sessions_value
        else:
            return True

    @include_web_sessions.setter
    def include_web_sessions(self, val):
        val = self._include_web_sessions_validator.validate(val)
        self._include_web_sessions_value = val
        self._include_web_sessions_present = True

    @include_web_sessions.deleter
    def include_web_sessions(self):
        self._include_web_sessions_value = None
        self._include_web_sessions_present = False

    @property
    def include_desktop_clients(self):
        """
        Whether to list linked desktop devices of the team's member

        :rtype: bool
        """
        if self._include_desktop_clients_present:
            return self._include_desktop_clients_value
        else:
            return True

    @include_desktop_clients.setter
    def include_desktop_clients(self, val):
        val = self._include_desktop_clients_validator.validate(val)
        self._include_desktop_clients_value = val
        self._include_desktop_clients_present = True

    @include_desktop_clients.deleter
    def include_desktop_clients(self):
        self._include_desktop_clients_value = None
        self._include_desktop_clients_present = False

    @property
    def include_mobile_clients(self):
        """
        Whether to list linked mobile devices of the team's member

        :rtype: bool
        """
        if self._include_mobile_clients_present:
            return self._include_mobile_clients_value
        else:
            return True

    @include_mobile_clients.setter
    def include_mobile_clients(self, val):
        val = self._include_mobile_clients_validator.validate(val)
        self._include_mobile_clients_value = val
        self._include_mobile_clients_present = True

    @include_mobile_clients.deleter
    def include_mobile_clients(self):
        self._include_mobile_clients_value = None
        self._include_mobile_clients_present = False

    def __repr__(self):
        return 'ListMemberDevicesArg(member_id={!r}, include_web_sessions={!r}, include_desktop_clients={!r}, include_mobile_clients={!r})'.format(
            self._member_id_value,
            self._include_web_sessions_value,
            self._include_desktop_clients_value,
            self._include_mobile_clients_value,
        )

class DeviceSession(object):
    """
    :ivar session_id: The session id
    :ivar ip_address: The IP address of the last activity from this session
    :ivar country: The country from which the last activity from this session
        was made
    :ivar created: The time this session was created
    :ivar updated: The time of the last activity from this session
    """

    __slots__ = [
        '_session_id_value',
        '_session_id_present',
        '_ip_address_value',
        '_ip_address_present',
        '_country_value',
        '_country_present',
        '_created_value',
        '_created_present',
        '_updated_value',
        '_updated_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 ip_address=None,
                 country=None,
                 created=None,
                 updated=None):
        self._session_id_value = None
        self._session_id_present = False
        self._ip_address_value = None
        self._ip_address_present = False
        self._country_value = None
        self._country_present = False
        self._created_value = None
        self._created_present = False
        self._updated_value = None
        self._updated_present = False
        if session_id is not None:
            self.session_id = session_id
        if ip_address is not None:
            self.ip_address = ip_address
        if country is not None:
            self.country = country
        if created is not None:
            self.created = created
        if updated is not None:
            self.updated = updated

    @property
    def session_id(self):
        """
        The session id

        :rtype: str
        """
        if self._session_id_present:
            return self._session_id_value
        else:
            raise AttributeError("missing required field 'session_id'")

    @session_id.setter
    def session_id(self, val):
        val = self._session_id_validator.validate(val)
        self._session_id_value = val
        self._session_id_present = True

    @session_id.deleter
    def session_id(self):
        self._session_id_value = None
        self._session_id_present = False

    @property
    def ip_address(self):
        """
        The IP address of the last activity from this session

        :rtype: str
        """
        if self._ip_address_present:
            return self._ip_address_value
        else:
            return None

    @ip_address.setter
    def ip_address(self, val):
        if val is None:
            del self.ip_address
            return
        val = self._ip_address_validator.validate(val)
        self._ip_address_value = val
        self._ip_address_present = True

    @ip_address.deleter
    def ip_address(self):
        self._ip_address_value = None
        self._ip_address_present = False

    @property
    def country(self):
        """
        The country from which the last activity from this session was made

        :rtype: str
        """
        if self._country_present:
            return self._country_value
        else:
            return None

    @country.setter
    def country(self, val):
        if val is None:
            del self.country
            return
        val = self._country_validator.validate(val)
        self._country_value = val
        self._country_present = True

    @country.deleter
    def country(self):
        self._country_value = None
        self._country_present = False

    @property
    def created(self):
        """
        The time this session was created

        :rtype: datetime.datetime
        """
        if self._created_present:
            return self._created_value
        else:
            return None

    @created.setter
    def created(self, val):
        if val is None:
            del self.created
            return
        val = self._created_validator.validate(val)
        self._created_value = val
        self._created_present = True

    @created.deleter
    def created(self):
        self._created_value = None
        self._created_present = False

    @property
    def updated(self):
        """
        The time of the last activity from this session

        :rtype: datetime.datetime
        """
        if self._updated_present:
            return self._updated_value
        else:
            return None

    @updated.setter
    def updated(self, val):
        if val is None:
            del self.updated
            return
        val = self._updated_validator.validate(val)
        self._updated_value = val
        self._updated_present = True

    @updated.deleter
    def updated(self):
        self._updated_value = None
        self._updated_present = False

    def __repr__(self):
        return 'DeviceSession(session_id={!r}, ip_address={!r}, country={!r}, created={!r}, updated={!r})'.format(
            self._session_id_value,
            self._ip_address_value,
            self._country_value,
            self._created_value,
            self._updated_value,
        )

class ActiveWebSession(DeviceSession):
    """
    Information on active web sessions

    :ivar user_agent: Information on the hosting device
    :ivar os: Information on the hosting operating system
    :ivar browser: Information on the browser used for this web session
    """

    __slots__ = [
        '_user_agent_value',
        '_user_agent_present',
        '_os_value',
        '_os_present',
        '_browser_value',
        '_browser_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 user_agent=None,
                 os=None,
                 browser=None,
                 ip_address=None,
                 country=None,
                 created=None,
                 updated=None):
        super(ActiveWebSession, self).__init__(session_id,
                                               ip_address,
                                               country,
                                               created,
                                               updated)
        self._user_agent_value = None
        self._user_agent_present = False
        self._os_value = None
        self._os_present = False
        self._browser_value = None
        self._browser_present = False
        if user_agent is not None:
            self.user_agent = user_agent
        if os is not None:
            self.os = os
        if browser is not None:
            self.browser = browser

    @property
    def user_agent(self):
        """
        Information on the hosting device

        :rtype: str
        """
        if self._user_agent_present:
            return self._user_agent_value
        else:
            raise AttributeError("missing required field 'user_agent'")

    @user_agent.setter
    def user_agent(self, val):
        val = self._user_agent_validator.validate(val)
        self._user_agent_value = val
        self._user_agent_present = True

    @user_agent.deleter
    def user_agent(self):
        self._user_agent_value = None
        self._user_agent_present = False

    @property
    def os(self):
        """
        Information on the hosting operating system

        :rtype: str
        """
        if self._os_present:
            return self._os_value
        else:
            raise AttributeError("missing required field 'os'")

    @os.setter
    def os(self, val):
        val = self._os_validator.validate(val)
        self._os_value = val
        self._os_present = True

    @os.deleter
    def os(self):
        self._os_value = None
        self._os_present = False

    @property
    def browser(self):
        """
        Information on the browser used for this web session

        :rtype: str
        """
        if self._browser_present:
            return self._browser_value
        else:
            raise AttributeError("missing required field 'browser'")

    @browser.setter
    def browser(self, val):
        val = self._browser_validator.validate(val)
        self._browser_value = val
        self._browser_present = True

    @browser.deleter
    def browser(self):
        self._browser_value = None
        self._browser_present = False

    def __repr__(self):
        return 'ActiveWebSession(session_id={!r}, user_agent={!r}, os={!r}, browser={!r}, ip_address={!r}, country={!r}, created={!r}, updated={!r})'.format(
            self._session_id_value,
            self._user_agent_value,
            self._os_value,
            self._browser_value,
            self._ip_address_value,
            self._country_value,
            self._created_value,
            self._updated_value,
        )

class DesktopPlatform(object):
    """
    :ivar windows: Official Windows Dropbox desktop client
    :ivar mac: Official Mac Dropbox desktop client
    :ivar linux: Official Linux Dropbox desktop client
    :ivar other: Official Dropbox desktop client for another platform
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    windows = None
    # Attribute is overwritten below the class definition
    mac = None
    # Attribute is overwritten below the class definition
    linux = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_windows(self):
        return self._tag == 'windows'

    def is_mac(self):
        return self._tag == 'mac'

    def is_linux(self):
        return self._tag == 'linux'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'DesktopPlatform(%r)' % self._tag

class DesktopClientSession(DeviceSession):
    """
    Information about linked Dropbox desktop client sessions

    :ivar host_name: Name of the hosting desktop
    :ivar client_type: The Dropbox desktop client type
    :ivar client_version: The Dropbox client version
    :ivar platform: Information on the hosting platform
    :ivar is_delete_on_unlink_supported: Whether it's possible to delete all of
        the account files upon unlinking
    """

    __slots__ = [
        '_host_name_value',
        '_host_name_present',
        '_client_type_value',
        '_client_type_present',
        '_client_version_value',
        '_client_version_present',
        '_platform_value',
        '_platform_present',
        '_is_delete_on_unlink_supported_value',
        '_is_delete_on_unlink_supported_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 host_name=None,
                 client_type=None,
                 client_version=None,
                 platform=None,
                 is_delete_on_unlink_supported=None,
                 ip_address=None,
                 country=None,
                 created=None,
                 updated=None):
        super(DesktopClientSession, self).__init__(session_id,
                                                   ip_address,
                                                   country,
                                                   created,
                                                   updated)
        self._host_name_value = None
        self._host_name_present = False
        self._client_type_value = None
        self._client_type_present = False
        self._client_version_value = None
        self._client_version_present = False
        self._platform_value = None
        self._platform_present = False
        self._is_delete_on_unlink_supported_value = None
        self._is_delete_on_unlink_supported_present = False
        if host_name is not None:
            self.host_name = host_name
        if client_type is not None:
            self.client_type = client_type
        if client_version is not None:
            self.client_version = client_version
        if platform is not None:
            self.platform = platform
        if is_delete_on_unlink_supported is not None:
            self.is_delete_on_unlink_supported = is_delete_on_unlink_supported

    @property
    def host_name(self):
        """
        Name of the hosting desktop

        :rtype: str
        """
        if self._host_name_present:
            return self._host_name_value
        else:
            raise AttributeError("missing required field 'host_name'")

    @host_name.setter
    def host_name(self, val):
        val = self._host_name_validator.validate(val)
        self._host_name_value = val
        self._host_name_present = True

    @host_name.deleter
    def host_name(self):
        self._host_name_value = None
        self._host_name_present = False

    @property
    def client_type(self):
        """
        The Dropbox desktop client type

        :rtype: DesktopPlatform
        """
        if self._client_type_present:
            return self._client_type_value
        else:
            raise AttributeError("missing required field 'client_type'")

    @client_type.setter
    def client_type(self, val):
        self._client_type_validator.validate_type_only(val)
        self._client_type_value = val
        self._client_type_present = True

    @client_type.deleter
    def client_type(self):
        self._client_type_value = None
        self._client_type_present = False

    @property
    def client_version(self):
        """
        The Dropbox client version

        :rtype: str
        """
        if self._client_version_present:
            return self._client_version_value
        else:
            raise AttributeError("missing required field 'client_version'")

    @client_version.setter
    def client_version(self, val):
        val = self._client_version_validator.validate(val)
        self._client_version_value = val
        self._client_version_present = True

    @client_version.deleter
    def client_version(self):
        self._client_version_value = None
        self._client_version_present = False

    @property
    def platform(self):
        """
        Information on the hosting platform

        :rtype: str
        """
        if self._platform_present:
            return self._platform_value
        else:
            raise AttributeError("missing required field 'platform'")

    @platform.setter
    def platform(self, val):
        val = self._platform_validator.validate(val)
        self._platform_value = val
        self._platform_present = True

    @platform.deleter
    def platform(self):
        self._platform_value = None
        self._platform_present = False

    @property
    def is_delete_on_unlink_supported(self):
        """
        Whether it's possible to delete all of the account files upon unlinking

        :rtype: bool
        """
        if self._is_delete_on_unlink_supported_present:
            return self._is_delete_on_unlink_supported_value
        else:
            raise AttributeError("missing required field 'is_delete_on_unlink_supported'")

    @is_delete_on_unlink_supported.setter
    def is_delete_on_unlink_supported(self, val):
        val = self._is_delete_on_unlink_supported_validator.validate(val)
        self._is_delete_on_unlink_supported_value = val
        self._is_delete_on_unlink_supported_present = True

    @is_delete_on_unlink_supported.deleter
    def is_delete_on_unlink_supported(self):
        self._is_delete_on_unlink_supported_value = None
        self._is_delete_on_unlink_supported_present = False

    def __repr__(self):
        return 'DesktopClientSession(session_id={!r}, host_name={!r}, client_type={!r}, client_version={!r}, platform={!r}, is_delete_on_unlink_supported={!r}, ip_address={!r}, country={!r}, created={!r}, updated={!r})'.format(
            self._session_id_value,
            self._host_name_value,
            self._client_type_value,
            self._client_version_value,
            self._platform_value,
            self._is_delete_on_unlink_supported_value,
            self._ip_address_value,
            self._country_value,
            self._created_value,
            self._updated_value,
        )

class MobileClientPlatform(object):
    """
    :ivar iphone: Official Dropbox iPhone client
    :ivar ipad: Official Dropbox iPad client
    :ivar android: Official Dropbox Android client
    :ivar windows_phone: Official Dropbox Windows phone client
    :ivar blackberry: Official Dropbox Blackberry client
    :ivar other: Official Dropbox client for another platform
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    iphone = None
    # Attribute is overwritten below the class definition
    ipad = None
    # Attribute is overwritten below the class definition
    android = None
    # Attribute is overwritten below the class definition
    windows_phone = None
    # Attribute is overwritten below the class definition
    blackberry = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_iphone(self):
        return self._tag == 'iphone'

    def is_ipad(self):
        return self._tag == 'ipad'

    def is_android(self):
        return self._tag == 'android'

    def is_windows_phone(self):
        return self._tag == 'windows_phone'

    def is_blackberry(self):
        return self._tag == 'blackberry'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'MobileClientPlatform(%r)' % self._tag

class MobileClientSession(DeviceSession):
    """
    Information about linked Dropbox mobile client sessions

    :ivar device_name: The device name
    :ivar client_type: The mobile application type
    :ivar client_version: The dropbox client version
    :ivar os_version: The hosting OS version
    :ivar last_carrier: last carrier used by the device
    """

    __slots__ = [
        '_device_name_value',
        '_device_name_present',
        '_client_type_value',
        '_client_type_present',
        '_client_version_value',
        '_client_version_present',
        '_os_version_value',
        '_os_version_present',
        '_last_carrier_value',
        '_last_carrier_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 device_name=None,
                 client_type=None,
                 ip_address=None,
                 country=None,
                 created=None,
                 updated=None,
                 client_version=None,
                 os_version=None,
                 last_carrier=None):
        super(MobileClientSession, self).__init__(session_id,
                                                  ip_address,
                                                  country,
                                                  created,
                                                  updated)
        self._device_name_value = None
        self._device_name_present = False
        self._client_type_value = None
        self._client_type_present = False
        self._client_version_value = None
        self._client_version_present = False
        self._os_version_value = None
        self._os_version_present = False
        self._last_carrier_value = None
        self._last_carrier_present = False
        if device_name is not None:
            self.device_name = device_name
        if client_type is not None:
            self.client_type = client_type
        if client_version is not None:
            self.client_version = client_version
        if os_version is not None:
            self.os_version = os_version
        if last_carrier is not None:
            self.last_carrier = last_carrier

    @property
    def device_name(self):
        """
        The device name

        :rtype: str
        """
        if self._device_name_present:
            return self._device_name_value
        else:
            raise AttributeError("missing required field 'device_name'")

    @device_name.setter
    def device_name(self, val):
        val = self._device_name_validator.validate(val)
        self._device_name_value = val
        self._device_name_present = True

    @device_name.deleter
    def device_name(self):
        self._device_name_value = None
        self._device_name_present = False

    @property
    def client_type(self):
        """
        The mobile application type

        :rtype: MobileClientPlatform
        """
        if self._client_type_present:
            return self._client_type_value
        else:
            raise AttributeError("missing required field 'client_type'")

    @client_type.setter
    def client_type(self, val):
        self._client_type_validator.validate_type_only(val)
        self._client_type_value = val
        self._client_type_present = True

    @client_type.deleter
    def client_type(self):
        self._client_type_value = None
        self._client_type_present = False

    @property
    def client_version(self):
        """
        The dropbox client version

        :rtype: str
        """
        if self._client_version_present:
            return self._client_version_value
        else:
            return None

    @client_version.setter
    def client_version(self, val):
        if val is None:
            del self.client_version
            return
        val = self._client_version_validator.validate(val)
        self._client_version_value = val
        self._client_version_present = True

    @client_version.deleter
    def client_version(self):
        self._client_version_value = None
        self._client_version_present = False

    @property
    def os_version(self):
        """
        The hosting OS version

        :rtype: str
        """
        if self._os_version_present:
            return self._os_version_value
        else:
            return None

    @os_version.setter
    def os_version(self, val):
        if val is None:
            del self.os_version
            return
        val = self._os_version_validator.validate(val)
        self._os_version_value = val
        self._os_version_present = True

    @os_version.deleter
    def os_version(self):
        self._os_version_value = None
        self._os_version_present = False

    @property
    def last_carrier(self):
        """
        last carrier used by the device

        :rtype: str
        """
        if self._last_carrier_present:
            return self._last_carrier_value
        else:
            return None

    @last_carrier.setter
    def last_carrier(self, val):
        if val is None:
            del self.last_carrier
            return
        val = self._last_carrier_validator.validate(val)
        self._last_carrier_value = val
        self._last_carrier_present = True

    @last_carrier.deleter
    def last_carrier(self):
        self._last_carrier_value = None
        self._last_carrier_present = False

    def __repr__(self):
        return 'MobileClientSession(session_id={!r}, device_name={!r}, client_type={!r}, ip_address={!r}, country={!r}, created={!r}, updated={!r}, client_version={!r}, os_version={!r}, last_carrier={!r})'.format(
            self._session_id_value,
            self._device_name_value,
            self._client_type_value,
            self._ip_address_value,
            self._country_value,
            self._created_value,
            self._updated_value,
            self._client_version_value,
            self._os_version_value,
            self._last_carrier_value,
        )

class ListMemberDevicesResult(object):
    """
    :ivar active_web_sessions: List of web sessions made by this team member
    :ivar desktop_client_sessions: List of desktop clients used by this team
        member
    :ivar mobile_client_sessions: List of mobile client used by this team member
    """

    __slots__ = [
        '_active_web_sessions_value',
        '_active_web_sessions_present',
        '_desktop_client_sessions_value',
        '_desktop_client_sessions_present',
        '_mobile_client_sessions_value',
        '_mobile_client_sessions_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 active_web_sessions=None,
                 desktop_client_sessions=None,
                 mobile_client_sessions=None):
        self._active_web_sessions_value = None
        self._active_web_sessions_present = False
        self._desktop_client_sessions_value = None
        self._desktop_client_sessions_present = False
        self._mobile_client_sessions_value = None
        self._mobile_client_sessions_present = False
        if active_web_sessions is not None:
            self.active_web_sessions = active_web_sessions
        if desktop_client_sessions is not None:
            self.desktop_client_sessions = desktop_client_sessions
        if mobile_client_sessions is not None:
            self.mobile_client_sessions = mobile_client_sessions

    @property
    def active_web_sessions(self):
        """
        List of web sessions made by this team member

        :rtype: list of [ActiveWebSession]
        """
        if self._active_web_sessions_present:
            return self._active_web_sessions_value
        else:
            return None

    @active_web_sessions.setter
    def active_web_sessions(self, val):
        if val is None:
            del self.active_web_sessions
            return
        val = self._active_web_sessions_validator.validate(val)
        self._active_web_sessions_value = val
        self._active_web_sessions_present = True

    @active_web_sessions.deleter
    def active_web_sessions(self):
        self._active_web_sessions_value = None
        self._active_web_sessions_present = False

    @property
    def desktop_client_sessions(self):
        """
        List of desktop clients used by this team member

        :rtype: list of [DesktopClientSession]
        """
        if self._desktop_client_sessions_present:
            return self._desktop_client_sessions_value
        else:
            return None

    @desktop_client_sessions.setter
    def desktop_client_sessions(self, val):
        if val is None:
            del self.desktop_client_sessions
            return
        val = self._desktop_client_sessions_validator.validate(val)
        self._desktop_client_sessions_value = val
        self._desktop_client_sessions_present = True

    @desktop_client_sessions.deleter
    def desktop_client_sessions(self):
        self._desktop_client_sessions_value = None
        self._desktop_client_sessions_present = False

    @property
    def mobile_client_sessions(self):
        """
        List of mobile client used by this team member

        :rtype: list of [MobileClientSession]
        """
        if self._mobile_client_sessions_present:
            return self._mobile_client_sessions_value
        else:
            return None

    @mobile_client_sessions.setter
    def mobile_client_sessions(self, val):
        if val is None:
            del self.mobile_client_sessions
            return
        val = self._mobile_client_sessions_validator.validate(val)
        self._mobile_client_sessions_value = val
        self._mobile_client_sessions_present = True

    @mobile_client_sessions.deleter
    def mobile_client_sessions(self):
        self._mobile_client_sessions_value = None
        self._mobile_client_sessions_present = False

    def __repr__(self):
        return 'ListMemberDevicesResult(active_web_sessions={!r}, desktop_client_sessions={!r}, mobile_client_sessions={!r})'.format(
            self._active_web_sessions_value,
            self._desktop_client_sessions_value,
            self._mobile_client_sessions_value,
        )

class ListMemberDevicesError(object):
    """
    :ivar member_not_found: Member not found.
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    member_not_found = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_member_not_found(self):
        return self._tag == 'member_not_found'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'ListMemberDevicesError(%r)' % self._tag

class ListTeamDevicesArg(object):
    """
    :ivar cursor: At the first call to the devices/list_team_devices the cursor
        shouldn't be passed. Then, if the result of the call includes a cursor,
        the following requests should include the received cursors in order to
        receive the next sub list of team devices
    :ivar include_web_sessions: Whether to list web sessions of the team members
    :ivar include_desktop_clients: Whether to list desktop clients of the team
        members
    :ivar include_mobile_clients: Whether to list mobile clients of the team
        members
    """

    __slots__ = [
        '_cursor_value',
        '_cursor_present',
        '_include_web_sessions_value',
        '_include_web_sessions_present',
        '_include_desktop_clients_value',
        '_include_desktop_clients_present',
        '_include_mobile_clients_value',
        '_include_mobile_clients_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 cursor=None,
                 include_web_sessions=None,
                 include_desktop_clients=None,
                 include_mobile_clients=None):
        self._cursor_value = None
        self._cursor_present = False
        self._include_web_sessions_value = None
        self._include_web_sessions_present = False
        self._include_desktop_clients_value = None
        self._include_desktop_clients_present = False
        self._include_mobile_clients_value = None
        self._include_mobile_clients_present = False
        if cursor is not None:
            self.cursor = cursor
        if include_web_sessions is not None:
            self.include_web_sessions = include_web_sessions
        if include_desktop_clients is not None:
            self.include_desktop_clients = include_desktop_clients
        if include_mobile_clients is not None:
            self.include_mobile_clients = include_mobile_clients

    @property
    def cursor(self):
        """
        At the first call to the devices/list_team_devices the cursor shouldn't
        be passed. Then, if the result of the call includes a cursor, the
        following requests should include the received cursors in order to
        receive the next sub list of team devices

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    @property
    def include_web_sessions(self):
        """
        Whether to list web sessions of the team members

        :rtype: bool
        """
        if self._include_web_sessions_present:
            return self._include_web_sessions_value
        else:
            return True

    @include_web_sessions.setter
    def include_web_sessions(self, val):
        val = self._include_web_sessions_validator.validate(val)
        self._include_web_sessions_value = val
        self._include_web_sessions_present = True

    @include_web_sessions.deleter
    def include_web_sessions(self):
        self._include_web_sessions_value = None
        self._include_web_sessions_present = False

    @property
    def include_desktop_clients(self):
        """
        Whether to list desktop clients of the team members

        :rtype: bool
        """
        if self._include_desktop_clients_present:
            return self._include_desktop_clients_value
        else:
            return True

    @include_desktop_clients.setter
    def include_desktop_clients(self, val):
        val = self._include_desktop_clients_validator.validate(val)
        self._include_desktop_clients_value = val
        self._include_desktop_clients_present = True

    @include_desktop_clients.deleter
    def include_desktop_clients(self):
        self._include_desktop_clients_value = None
        self._include_desktop_clients_present = False

    @property
    def include_mobile_clients(self):
        """
        Whether to list mobile clients of the team members

        :rtype: bool
        """
        if self._include_mobile_clients_present:
            return self._include_mobile_clients_value
        else:
            return True

    @include_mobile_clients.setter
    def include_mobile_clients(self, val):
        val = self._include_mobile_clients_validator.validate(val)
        self._include_mobile_clients_value = val
        self._include_mobile_clients_present = True

    @include_mobile_clients.deleter
    def include_mobile_clients(self):
        self._include_mobile_clients_value = None
        self._include_mobile_clients_present = False

    def __repr__(self):
        return 'ListTeamDevicesArg(cursor={!r}, include_web_sessions={!r}, include_desktop_clients={!r}, include_mobile_clients={!r})'.format(
            self._cursor_value,
            self._include_web_sessions_value,
            self._include_desktop_clients_value,
            self._include_mobile_clients_value,
        )

class MemberDevices(object):
    """
    Information on devices of a team's member.

    :ivar member_id: The member unique Id
    :ivar web_sessions: List of web sessions made by this team member
    :ivar desktop_clients: List of desktop clients by this team member
    :ivar mobile_clients: List of mobile clients by this team member
    """

    __slots__ = [
        '_member_id_value',
        '_member_id_present',
        '_web_sessions_value',
        '_web_sessions_present',
        '_desktop_clients_value',
        '_desktop_clients_present',
        '_mobile_clients_value',
        '_mobile_clients_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 member_id=None,
                 web_sessions=None,
                 desktop_clients=None,
                 mobile_clients=None):
        self._member_id_value = None
        self._member_id_present = False
        self._web_sessions_value = None
        self._web_sessions_present = False
        self._desktop_clients_value = None
        self._desktop_clients_present = False
        self._mobile_clients_value = None
        self._mobile_clients_present = False
        if member_id is not None:
            self.member_id = member_id
        if web_sessions is not None:
            self.web_sessions = web_sessions
        if desktop_clients is not None:
            self.desktop_clients = desktop_clients
        if mobile_clients is not None:
            self.mobile_clients = mobile_clients

    @property
    def member_id(self):
        """
        The member unique Id

        :rtype: str
        """
        if self._member_id_present:
            return self._member_id_value
        else:
            raise AttributeError("missing required field 'member_id'")

    @member_id.setter
    def member_id(self, val):
        val = self._member_id_validator.validate(val)
        self._member_id_value = val
        self._member_id_present = True

    @member_id.deleter
    def member_id(self):
        self._member_id_value = None
        self._member_id_present = False

    @property
    def web_sessions(self):
        """
        List of web sessions made by this team member

        :rtype: list of [ActiveWebSession]
        """
        if self._web_sessions_present:
            return self._web_sessions_value
        else:
            return None

    @web_sessions.setter
    def web_sessions(self, val):
        if val is None:
            del self.web_sessions
            return
        val = self._web_sessions_validator.validate(val)
        self._web_sessions_value = val
        self._web_sessions_present = True

    @web_sessions.deleter
    def web_sessions(self):
        self._web_sessions_value = None
        self._web_sessions_present = False

    @property
    def desktop_clients(self):
        """
        List of desktop clients by this team member

        :rtype: list of [DesktopClientSession]
        """
        if self._desktop_clients_present:
            return self._desktop_clients_value
        else:
            return None

    @desktop_clients.setter
    def desktop_clients(self, val):
        if val is None:
            del self.desktop_clients
            return
        val = self._desktop_clients_validator.validate(val)
        self._desktop_clients_value = val
        self._desktop_clients_present = True

    @desktop_clients.deleter
    def desktop_clients(self):
        self._desktop_clients_value = None
        self._desktop_clients_present = False

    @property
    def mobile_clients(self):
        """
        List of mobile clients by this team member

        :rtype: list of [MobileClientSession]
        """
        if self._mobile_clients_present:
            return self._mobile_clients_value
        else:
            return None

    @mobile_clients.setter
    def mobile_clients(self, val):
        if val is None:
            del self.mobile_clients
            return
        val = self._mobile_clients_validator.validate(val)
        self._mobile_clients_value = val
        self._mobile_clients_present = True

    @mobile_clients.deleter
    def mobile_clients(self):
        self._mobile_clients_value = None
        self._mobile_clients_present = False

    def __repr__(self):
        return 'MemberDevices(member_id={!r}, web_sessions={!r}, desktop_clients={!r}, mobile_clients={!r})'.format(
            self._member_id_value,
            self._web_sessions_value,
            self._desktop_clients_value,
            self._mobile_clients_value,
        )

class ListTeamDevicesResult(object):
    """
    :ivar devices: The devices of each member of the team
    :ivar has_more: If true, then there are more devices available. Pass the
        cursor to devices/list_team_devices to retrieve the rest.
    :ivar cursor: Pass the cursor into devices/list_team_devices to receive the
        next sub list of team's devices.
    """

    __slots__ = [
        '_devices_value',
        '_devices_present',
        '_has_more_value',
        '_has_more_present',
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 devices=None,
                 has_more=None,
                 cursor=None):
        self._devices_value = None
        self._devices_present = False
        self._has_more_value = None
        self._has_more_present = False
        self._cursor_value = None
        self._cursor_present = False
        if devices is not None:
            self.devices = devices
        if has_more is not None:
            self.has_more = has_more
        if cursor is not None:
            self.cursor = cursor

    @property
    def devices(self):
        """
        The devices of each member of the team

        :rtype: list of [MemberDevices]
        """
        if self._devices_present:
            return self._devices_value
        else:
            raise AttributeError("missing required field 'devices'")

    @devices.setter
    def devices(self, val):
        val = self._devices_validator.validate(val)
        self._devices_value = val
        self._devices_present = True

    @devices.deleter
    def devices(self):
        self._devices_value = None
        self._devices_present = False

    @property
    def has_more(self):
        """
        If true, then there are more devices available. Pass the cursor to
        devices/list_team_devices to retrieve the rest.

        :rtype: bool
        """
        if self._has_more_present:
            return self._has_more_value
        else:
            raise AttributeError("missing required field 'has_more'")

    @has_more.setter
    def has_more(self, val):
        val = self._has_more_validator.validate(val)
        self._has_more_value = val
        self._has_more_present = True

    @has_more.deleter
    def has_more(self):
        self._has_more_value = None
        self._has_more_present = False

    @property
    def cursor(self):
        """
        Pass the cursor into devices/list_team_devices to receive the next sub
        list of team's devices.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'ListTeamDevicesResult(devices={!r}, has_more={!r}, cursor={!r})'.format(
            self._devices_value,
            self._has_more_value,
            self._cursor_value,
        )

class ListTeamDevicesError(object):
    """
    :ivar reset: Indicates that the cursor has been invalidated. Call
        devices/list_team_devices again with an empty cursor to obtain a new
        cursor.
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    reset = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_reset(self):
        return self._tag == 'reset'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'ListTeamDevicesError(%r)' % self._tag

class DeviceSessionArg(object):
    """
    :ivar session_id: The session id
    :ivar member_id: The unique id of the member owning the device
    """

    __slots__ = [
        '_session_id_value',
        '_session_id_present',
        '_member_id_value',
        '_member_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 member_id=None):
        self._session_id_value = None
        self._session_id_present = False
        self._member_id_value = None
        self._member_id_present = False
        if session_id is not None:
            self.session_id = session_id
        if member_id is not None:
            self.member_id = member_id

    @property
    def session_id(self):
        """
        The session id

        :rtype: str
        """
        if self._session_id_present:
            return self._session_id_value
        else:
            raise AttributeError("missing required field 'session_id'")

    @session_id.setter
    def session_id(self, val):
        val = self._session_id_validator.validate(val)
        self._session_id_value = val
        self._session_id_present = True

    @session_id.deleter
    def session_id(self):
        self._session_id_value = None
        self._session_id_present = False

    @property
    def member_id(self):
        """
        The unique id of the member owning the device

        :rtype: str
        """
        if self._member_id_present:
            return self._member_id_value
        else:
            raise AttributeError("missing required field 'member_id'")

    @member_id.setter
    def member_id(self, val):
        val = self._member_id_validator.validate(val)
        self._member_id_value = val
        self._member_id_present = True

    @member_id.deleter
    def member_id(self):
        self._member_id_value = None
        self._member_id_present = False

    def __repr__(self):
        return 'DeviceSessionArg(session_id={!r}, member_id={!r})'.format(
            self._session_id_value,
            self._member_id_value,
        )

class RevokeDesktopClientArg(DeviceSessionArg):
    """
    :ivar delete_on_unlink: Whether to delete all files of the account (this is
        possible only if supported by the desktop client and  will be made the
        next time the client access the account)
    """

    __slots__ = [
        '_delete_on_unlink_value',
        '_delete_on_unlink_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 member_id=None,
                 delete_on_unlink=None):
        super(RevokeDesktopClientArg, self).__init__(session_id,
                                                     member_id)
        self._delete_on_unlink_value = None
        self._delete_on_unlink_present = False
        if delete_on_unlink is not None:
            self.delete_on_unlink = delete_on_unlink

    @property
    def delete_on_unlink(self):
        """
        Whether to delete all files of the account (this is possible only if
        supported by the desktop client and  will be made the next time the
        client access the account)

        :rtype: bool
        """
        if self._delete_on_unlink_present:
            return self._delete_on_unlink_value
        else:
            return False

    @delete_on_unlink.setter
    def delete_on_unlink(self, val):
        val = self._delete_on_unlink_validator.validate(val)
        self._delete_on_unlink_value = val
        self._delete_on_unlink_present = True

    @delete_on_unlink.deleter
    def delete_on_unlink(self):
        self._delete_on_unlink_value = None
        self._delete_on_unlink_present = False

    def __repr__(self):
        return 'RevokeDesktopClientArg(session_id={!r}, member_id={!r}, delete_on_unlink={!r})'.format(
            self._session_id_value,
            self._member_id_value,
            self._delete_on_unlink_value,
        )

class RevokeDeviceSessionArg(object):
    """
    :ivar DeviceSessionArg web_session: End an active session
    :ivar RevokeDesktopClientArg desktop_client: Unlink a linked desktop device
    :ivar DeviceSessionArg mobile_client: Unlink a linked mobile device
    """

    __slots__ = ['_tag', '_value']

    _catch_all = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    @classmethod
    def web_session(cls, val):
        return cls('web_session', val)

    @classmethod
    def desktop_client(cls, val):
        return cls('desktop_client', val)

    @classmethod
    def mobile_client(cls, val):
        return cls('mobile_client', val)

    def is_web_session(self):
        return self._tag == 'web_session'

    def is_desktop_client(self):
        return self._tag == 'desktop_client'

    def is_mobile_client(self):
        return self._tag == 'mobile_client'

    def get_web_session(self):
        if not self.is_web_session():
            raise AttributeError("tag 'web_session' not set")
        return self._value

    def get_desktop_client(self):
        if not self.is_desktop_client():
            raise AttributeError("tag 'desktop_client' not set")
        return self._value

    def get_mobile_client(self):
        if not self.is_mobile_client():
            raise AttributeError("tag 'mobile_client' not set")
        return self._value

    def __repr__(self):
        return 'RevokeDeviceSessionArg(%r)' % self._tag

class RevokeDeviceSessionError(object):
    """
    :ivar device_session_not_found: Device session not found.
    :ivar member_not_found: Member not found.
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    device_session_not_found = None
    # Attribute is overwritten below the class definition
    member_not_found = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_device_session_not_found(self):
        return self._tag == 'device_session_not_found'

    def is_member_not_found(self):
        return self._tag == 'member_not_found'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'RevokeDeviceSessionError(%r)' % self._tag

class RevokeDeviceSessionBatchArg(object):

    __slots__ = [
        '_revoke_devices_value',
        '_revoke_devices_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 revoke_devices=None):
        self._revoke_devices_value = None
        self._revoke_devices_present = False
        if revoke_devices is not None:
            self.revoke_devices = revoke_devices

    @property
    def revoke_devices(self):
        """
        :rtype: list of [RevokeDeviceSessionArg]
        """
        if self._revoke_devices_present:
            return self._revoke_devices_value
        else:
            raise AttributeError("missing required field 'revoke_devices'")

    @revoke_devices.setter
    def revoke_devices(self, val):
        val = self._revoke_devices_validator.validate(val)
        self._revoke_devices_value = val
        self._revoke_devices_present = True

    @revoke_devices.deleter
    def revoke_devices(self):
        self._revoke_devices_value = None
        self._revoke_devices_present = False

    def __repr__(self):
        return 'RevokeDeviceSessionBatchArg(revoke_devices={!r})'.format(
            self._revoke_devices_value,
        )

class RevokeDeviceSessionStatus(object):
    """
    :ivar success: Result of the revoking request
    :ivar error_type: The error cause in case of a failure
    """

    __slots__ = [
        '_success_value',
        '_success_present',
        '_error_type_value',
        '_error_type_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 success=None,
                 error_type=None):
        self._success_value = None
        self._success_present = False
        self._error_type_value = None
        self._error_type_present = False
        if success is not None:
            self.success = success
        if error_type is not None:
            self.error_type = error_type

    @property
    def success(self):
        """
        Result of the revoking request

        :rtype: bool
        """
        if self._success_present:
            return self._success_value
        else:
            raise AttributeError("missing required field 'success'")

    @success.setter
    def success(self, val):
        val = self._success_validator.validate(val)
        self._success_value = val
        self._success_present = True

    @success.deleter
    def success(self):
        self._success_value = None
        self._success_present = False

    @property
    def error_type(self):
        """
        The error cause in case of a failure

        :rtype: RevokeDeviceSessionError
        """
        if self._error_type_present:
            return self._error_type_value
        else:
            return None

    @error_type.setter
    def error_type(self, val):
        if val is None:
            del self.error_type
            return
        self._error_type_validator.validate_type_only(val)
        self._error_type_value = val
        self._error_type_present = True

    @error_type.deleter
    def error_type(self):
        self._error_type_value = None
        self._error_type_present = False

    def __repr__(self):
        return 'RevokeDeviceSessionStatus(success={!r}, error_type={!r})'.format(
            self._success_value,
            self._error_type_value,
        )

class RevokeDeviceSessionBatchResult(object):

    __slots__ = [
        '_revoke_devices_status_value',
        '_revoke_devices_status_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 revoke_devices_status=None):
        self._revoke_devices_status_value = None
        self._revoke_devices_status_present = False
        if revoke_devices_status is not None:
            self.revoke_devices_status = revoke_devices_status

    @property
    def revoke_devices_status(self):
        """
        :rtype: list of [RevokeDeviceSessionStatus]
        """
        if self._revoke_devices_status_present:
            return self._revoke_devices_status_value
        else:
            raise AttributeError("missing required field 'revoke_devices_status'")

    @revoke_devices_status.setter
    def revoke_devices_status(self, val):
        val = self._revoke_devices_status_validator.validate(val)
        self._revoke_devices_status_value = val
        self._revoke_devices_status_present = True

    @revoke_devices_status.deleter
    def revoke_devices_status(self):
        self._revoke_devices_status_value = None
        self._revoke_devices_status_present = False

    def __repr__(self):
        return 'RevokeDeviceSessionBatchResult(revoke_devices_status={!r})'.format(
            self._revoke_devices_status_value,
        )

class RevokeDeviceSessionBatchError(object):
    """
    :ivar unspecified: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'unspecified'
    # Attribute is overwritten below the class definition
    unspecified = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_unspecified(self):
        return self._tag == 'unspecified'

    def __repr__(self):
        return 'RevokeDeviceSessionBatchError(%r)' % self._tag

class ListMemberAppsArg(object):
    """
    :ivar member_id: The team's member id
    """

    __slots__ = [
        '_member_id_value',
        '_member_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 member_id=None):
        self._member_id_value = None
        self._member_id_present = False
        if member_id is not None:
            self.member_id = member_id

    @property
    def member_id(self):
        """
        The team's member id

        :rtype: str
        """
        if self._member_id_present:
            return self._member_id_value
        else:
            raise AttributeError("missing required field 'member_id'")

    @member_id.setter
    def member_id(self, val):
        val = self._member_id_validator.validate(val)
        self._member_id_value = val
        self._member_id_present = True

    @member_id.deleter
    def member_id(self):
        self._member_id_value = None
        self._member_id_present = False

    def __repr__(self):
        return 'ListMemberAppsArg(member_id={!r})'.format(
            self._member_id_value,
        )

class ApiApp(object):
    """
    Information on linked third party applications

    :ivar app_id: The application unique id
    :ivar app_name: The application name
    :ivar publisher: The application publisher name
    :ivar publisher_url: The publisher's URL
    :ivar linked: The time this application was linked
    :ivar is_app_folder: Whether the linked application uses a dedicated folder
    """

    __slots__ = [
        '_app_id_value',
        '_app_id_present',
        '_app_name_value',
        '_app_name_present',
        '_publisher_value',
        '_publisher_present',
        '_publisher_url_value',
        '_publisher_url_present',
        '_linked_value',
        '_linked_present',
        '_is_app_folder_value',
        '_is_app_folder_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 app_id=None,
                 app_name=None,
                 is_app_folder=None,
                 publisher=None,
                 publisher_url=None,
                 linked=None):
        self._app_id_value = None
        self._app_id_present = False
        self._app_name_value = None
        self._app_name_present = False
        self._publisher_value = None
        self._publisher_present = False
        self._publisher_url_value = None
        self._publisher_url_present = False
        self._linked_value = None
        self._linked_present = False
        self._is_app_folder_value = None
        self._is_app_folder_present = False
        if app_id is not None:
            self.app_id = app_id
        if app_name is not None:
            self.app_name = app_name
        if publisher is not None:
            self.publisher = publisher
        if publisher_url is not None:
            self.publisher_url = publisher_url
        if linked is not None:
            self.linked = linked
        if is_app_folder is not None:
            self.is_app_folder = is_app_folder

    @property
    def app_id(self):
        """
        The application unique id

        :rtype: str
        """
        if self._app_id_present:
            return self._app_id_value
        else:
            raise AttributeError("missing required field 'app_id'")

    @app_id.setter
    def app_id(self, val):
        val = self._app_id_validator.validate(val)
        self._app_id_value = val
        self._app_id_present = True

    @app_id.deleter
    def app_id(self):
        self._app_id_value = None
        self._app_id_present = False

    @property
    def app_name(self):
        """
        The application name

        :rtype: str
        """
        if self._app_name_present:
            return self._app_name_value
        else:
            raise AttributeError("missing required field 'app_name'")

    @app_name.setter
    def app_name(self, val):
        val = self._app_name_validator.validate(val)
        self._app_name_value = val
        self._app_name_present = True

    @app_name.deleter
    def app_name(self):
        self._app_name_value = None
        self._app_name_present = False

    @property
    def publisher(self):
        """
        The application publisher name

        :rtype: str
        """
        if self._publisher_present:
            return self._publisher_value
        else:
            return None

    @publisher.setter
    def publisher(self, val):
        if val is None:
            del self.publisher
            return
        val = self._publisher_validator.validate(val)
        self._publisher_value = val
        self._publisher_present = True

    @publisher.deleter
    def publisher(self):
        self._publisher_value = None
        self._publisher_present = False

    @property
    def publisher_url(self):
        """
        The publisher's URL

        :rtype: str
        """
        if self._publisher_url_present:
            return self._publisher_url_value
        else:
            return None

    @publisher_url.setter
    def publisher_url(self, val):
        if val is None:
            del self.publisher_url
            return
        val = self._publisher_url_validator.validate(val)
        self._publisher_url_value = val
        self._publisher_url_present = True

    @publisher_url.deleter
    def publisher_url(self):
        self._publisher_url_value = None
        self._publisher_url_present = False

    @property
    def linked(self):
        """
        The time this application was linked

        :rtype: datetime.datetime
        """
        if self._linked_present:
            return self._linked_value
        else:
            return None

    @linked.setter
    def linked(self, val):
        if val is None:
            del self.linked
            return
        val = self._linked_validator.validate(val)
        self._linked_value = val
        self._linked_present = True

    @linked.deleter
    def linked(self):
        self._linked_value = None
        self._linked_present = False

    @property
    def is_app_folder(self):
        """
        Whether the linked application uses a dedicated folder

        :rtype: bool
        """
        if self._is_app_folder_present:
            return self._is_app_folder_value
        else:
            raise AttributeError("missing required field 'is_app_folder'")

    @is_app_folder.setter
    def is_app_folder(self, val):
        val = self._is_app_folder_validator.validate(val)
        self._is_app_folder_value = val
        self._is_app_folder_present = True

    @is_app_folder.deleter
    def is_app_folder(self):
        self._is_app_folder_value = None
        self._is_app_folder_present = False

    def __repr__(self):
        return 'ApiApp(app_id={!r}, app_name={!r}, is_app_folder={!r}, publisher={!r}, publisher_url={!r}, linked={!r})'.format(
            self._app_id_value,
            self._app_name_value,
            self._is_app_folder_value,
            self._publisher_value,
            self._publisher_url_value,
            self._linked_value,
        )

class ListMemberAppsResult(object):
    """
    :ivar linked_api_apps: List of third party applications linked by this team
        member
    """

    __slots__ = [
        '_linked_api_apps_value',
        '_linked_api_apps_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 linked_api_apps=None):
        self._linked_api_apps_value = None
        self._linked_api_apps_present = False
        if linked_api_apps is not None:
            self.linked_api_apps = linked_api_apps

    @property
    def linked_api_apps(self):
        """
        List of third party applications linked by this team member

        :rtype: list of [ApiApp]
        """
        if self._linked_api_apps_present:
            return self._linked_api_apps_value
        else:
            raise AttributeError("missing required field 'linked_api_apps'")

    @linked_api_apps.setter
    def linked_api_apps(self, val):
        val = self._linked_api_apps_validator.validate(val)
        self._linked_api_apps_value = val
        self._linked_api_apps_present = True

    @linked_api_apps.deleter
    def linked_api_apps(self):
        self._linked_api_apps_value = None
        self._linked_api_apps_present = False

    def __repr__(self):
        return 'ListMemberAppsResult(linked_api_apps={!r})'.format(
            self._linked_api_apps_value,
        )

class ListMemberAppsError(object):
    """
    Error returned by :route: `linked_apps/list_member_linked_apps`.

    :ivar member_not_found: Member not found.
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    member_not_found = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_member_not_found(self):
        return self._tag == 'member_not_found'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'ListMemberAppsError(%r)' % self._tag

class ListTeamAppsArg(object):
    """
    Arguments for linked_apps/list_team_linked_apps.

    :ivar cursor: At the first call to the linked_apps/list_team_linked_apps the
        cursor shouldn't be passed. Then, if the result of the call includes a
        cursor, the following requests should include the received cursors in
        order to receive the next sub list of team applications
    """

    __slots__ = [
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 cursor=None):
        self._cursor_value = None
        self._cursor_present = False
        if cursor is not None:
            self.cursor = cursor

    @property
    def cursor(self):
        """
        At the first call to the linked_apps/list_team_linked_apps the cursor
        shouldn't be passed. Then, if the result of the call includes a cursor,
        the following requests should include the received cursors in order to
        receive the next sub list of team applications

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'ListTeamAppsArg(cursor={!r})'.format(
            self._cursor_value,
        )

class MemberLinkedApps(object):
    """
    Information on linked applications of a team's member.

    :ivar member_id: The member unique Id
    :ivar linked_api_apps: List of third party applications linked by this team
        member
    """

    __slots__ = [
        '_member_id_value',
        '_member_id_present',
        '_linked_api_apps_value',
        '_linked_api_apps_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 member_id=None,
                 linked_api_apps=None):
        self._member_id_value = None
        self._member_id_present = False
        self._linked_api_apps_value = None
        self._linked_api_apps_present = False
        if member_id is not None:
            self.member_id = member_id
        if linked_api_apps is not None:
            self.linked_api_apps = linked_api_apps

    @property
    def member_id(self):
        """
        The member unique Id

        :rtype: str
        """
        if self._member_id_present:
            return self._member_id_value
        else:
            raise AttributeError("missing required field 'member_id'")

    @member_id.setter
    def member_id(self, val):
        val = self._member_id_validator.validate(val)
        self._member_id_value = val
        self._member_id_present = True

    @member_id.deleter
    def member_id(self):
        self._member_id_value = None
        self._member_id_present = False

    @property
    def linked_api_apps(self):
        """
        List of third party applications linked by this team member

        :rtype: list of [ApiApp]
        """
        if self._linked_api_apps_present:
            return self._linked_api_apps_value
        else:
            raise AttributeError("missing required field 'linked_api_apps'")

    @linked_api_apps.setter
    def linked_api_apps(self, val):
        val = self._linked_api_apps_validator.validate(val)
        self._linked_api_apps_value = val
        self._linked_api_apps_present = True

    @linked_api_apps.deleter
    def linked_api_apps(self):
        self._linked_api_apps_value = None
        self._linked_api_apps_present = False

    def __repr__(self):
        return 'MemberLinkedApps(member_id={!r}, linked_api_apps={!r})'.format(
            self._member_id_value,
            self._linked_api_apps_value,
        )

class ListTeamAppsResult(object):
    """
    Information returned by linked_apps/list_team_linked_apps.

    :ivar apps: The linked applications of each member of the team
    :ivar has_more: If true, then there are more apps available. Pass the cursor
        to linked_apps/list_team_linked_apps to retrieve the rest.
    :ivar cursor: Pass the cursor into linked_apps/list_team_linked_apps to
        receive the next sub list of team's applications.
    """

    __slots__ = [
        '_apps_value',
        '_apps_present',
        '_has_more_value',
        '_has_more_present',
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 apps=None,
                 has_more=None,
                 cursor=None):
        self._apps_value = None
        self._apps_present = False
        self._has_more_value = None
        self._has_more_present = False
        self._cursor_value = None
        self._cursor_present = False
        if apps is not None:
            self.apps = apps
        if has_more is not None:
            self.has_more = has_more
        if cursor is not None:
            self.cursor = cursor

    @property
    def apps(self):
        """
        The linked applications of each member of the team

        :rtype: list of [MemberLinkedApps]
        """
        if self._apps_present:
            return self._apps_value
        else:
            raise AttributeError("missing required field 'apps'")

    @apps.setter
    def apps(self, val):
        val = self._apps_validator.validate(val)
        self._apps_value = val
        self._apps_present = True

    @apps.deleter
    def apps(self):
        self._apps_value = None
        self._apps_present = False

    @property
    def has_more(self):
        """
        If true, then there are more apps available. Pass the cursor to
        linked_apps/list_team_linked_apps to retrieve the rest.

        :rtype: bool
        """
        if self._has_more_present:
            return self._has_more_value
        else:
            raise AttributeError("missing required field 'has_more'")

    @has_more.setter
    def has_more(self, val):
        val = self._has_more_validator.validate(val)
        self._has_more_value = val
        self._has_more_present = True

    @has_more.deleter
    def has_more(self):
        self._has_more_value = None
        self._has_more_present = False

    @property
    def cursor(self):
        """
        Pass the cursor into linked_apps/list_team_linked_apps to receive the
        next sub list of team's applications.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'ListTeamAppsResult(apps={!r}, has_more={!r}, cursor={!r})'.format(
            self._apps_value,
            self._has_more_value,
            self._cursor_value,
        )

class ListTeamAppsError(object):
    """
    Error returned by linked_apps/list_team_linked_apps

    :ivar reset: Indicates that the cursor has been invalidated. Call
        linked_apps/list_team_linked_apps again with an empty cursor to obtain a
        new cursor.
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    reset = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_reset(self):
        return self._tag == 'reset'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'ListTeamAppsError(%r)' % self._tag

class RevokeLinkedApiAppArg(object):
    """
    :ivar app_id: The application's unique id
    :ivar member_id: The unique id of the member owning the device
    :ivar keep_app_folder: Whether to keep the application dedicated folder (in
        case the application uses  one)
    """

    __slots__ = [
        '_app_id_value',
        '_app_id_present',
        '_member_id_value',
        '_member_id_present',
        '_keep_app_folder_value',
        '_keep_app_folder_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 app_id=None,
                 member_id=None,
                 keep_app_folder=None):
        self._app_id_value = None
        self._app_id_present = False
        self._member_id_value = None
        self._member_id_present = False
        self._keep_app_folder_value = None
        self._keep_app_folder_present = False
        if app_id is not None:
            self.app_id = app_id
        if member_id is not None:
            self.member_id = member_id
        if keep_app_folder is not None:
            self.keep_app_folder = keep_app_folder

    @property
    def app_id(self):
        """
        The application's unique id

        :rtype: str
        """
        if self._app_id_present:
            return self._app_id_value
        else:
            raise AttributeError("missing required field 'app_id'")

    @app_id.setter
    def app_id(self, val):
        val = self._app_id_validator.validate(val)
        self._app_id_value = val
        self._app_id_present = True

    @app_id.deleter
    def app_id(self):
        self._app_id_value = None
        self._app_id_present = False

    @property
    def member_id(self):
        """
        The unique id of the member owning the device

        :rtype: str
        """
        if self._member_id_present:
            return self._member_id_value
        else:
            raise AttributeError("missing required field 'member_id'")

    @member_id.setter
    def member_id(self, val):
        val = self._member_id_validator.validate(val)
        self._member_id_value = val
        self._member_id_present = True

    @member_id.deleter
    def member_id(self):
        self._member_id_value = None
        self._member_id_present = False

    @property
    def keep_app_folder(self):
        """
        Whether to keep the application dedicated folder (in case the
        application uses  one)

        :rtype: bool
        """
        if self._keep_app_folder_present:
            return self._keep_app_folder_value
        else:
            return True

    @keep_app_folder.setter
    def keep_app_folder(self, val):
        val = self._keep_app_folder_validator.validate(val)
        self._keep_app_folder_value = val
        self._keep_app_folder_present = True

    @keep_app_folder.deleter
    def keep_app_folder(self):
        self._keep_app_folder_value = None
        self._keep_app_folder_present = False

    def __repr__(self):
        return 'RevokeLinkedApiAppArg(app_id={!r}, member_id={!r}, keep_app_folder={!r})'.format(
            self._app_id_value,
            self._member_id_value,
            self._keep_app_folder_value,
        )

class RevokeLinkedAppError(object):
    """
    Error returned by linked_apps/revoke_linked_app.

    :ivar app_not_found: Application not found.
    :ivar member_not_found: Member not found.
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    app_not_found = None
    # Attribute is overwritten below the class definition
    member_not_found = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_app_not_found(self):
        return self._tag == 'app_not_found'

    def is_member_not_found(self):
        return self._tag == 'member_not_found'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'RevokeLinkedAppError(%r)' % self._tag

class RevokeLinkedApiAppBatchArg(object):

    __slots__ = [
        '_revoke_linked_app_value',
        '_revoke_linked_app_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 revoke_linked_app=None):
        self._revoke_linked_app_value = None
        self._revoke_linked_app_present = False
        if revoke_linked_app is not None:
            self.revoke_linked_app = revoke_linked_app

    @property
    def revoke_linked_app(self):
        """
        :rtype: list of [RevokeLinkedApiAppArg]
        """
        if self._revoke_linked_app_present:
            return self._revoke_linked_app_value
        else:
            raise AttributeError("missing required field 'revoke_linked_app'")

    @revoke_linked_app.setter
    def revoke_linked_app(self, val):
        val = self._revoke_linked_app_validator.validate(val)
        self._revoke_linked_app_value = val
        self._revoke_linked_app_present = True

    @revoke_linked_app.deleter
    def revoke_linked_app(self):
        self._revoke_linked_app_value = None
        self._revoke_linked_app_present = False

    def __repr__(self):
        return 'RevokeLinkedApiAppBatchArg(revoke_linked_app={!r})'.format(
            self._revoke_linked_app_value,
        )

class RevokeLinkedAppStatus(object):
    """
    :ivar success: Result of the revoking request
    :ivar error_type: The error cause in case of a failure
    """

    __slots__ = [
        '_success_value',
        '_success_present',
        '_error_type_value',
        '_error_type_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 success=None,
                 error_type=None):
        self._success_value = None
        self._success_present = False
        self._error_type_value = None
        self._error_type_present = False
        if success is not None:
            self.success = success
        if error_type is not None:
            self.error_type = error_type

    @property
    def success(self):
        """
        Result of the revoking request

        :rtype: bool
        """
        if self._success_present:
            return self._success_value
        else:
            raise AttributeError("missing required field 'success'")

    @success.setter
    def success(self, val):
        val = self._success_validator.validate(val)
        self._success_value = val
        self._success_present = True

    @success.deleter
    def success(self):
        self._success_value = None
        self._success_present = False

    @property
    def error_type(self):
        """
        The error cause in case of a failure

        :rtype: RevokeLinkedAppError
        """
        if self._error_type_present:
            return self._error_type_value
        else:
            return None

    @error_type.setter
    def error_type(self, val):
        if val is None:
            del self.error_type
            return
        self._error_type_validator.validate_type_only(val)
        self._error_type_value = val
        self._error_type_present = True

    @error_type.deleter
    def error_type(self):
        self._error_type_value = None
        self._error_type_present = False

    def __repr__(self):
        return 'RevokeLinkedAppStatus(success={!r}, error_type={!r})'.format(
            self._success_value,
            self._error_type_value,
        )

class RevokeLinkedAppBatchResult(object):

    __slots__ = [
        '_revoke_linked_app_status_value',
        '_revoke_linked_app_status_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 revoke_linked_app_status=None):
        self._revoke_linked_app_status_value = None
        self._revoke_linked_app_status_present = False
        if revoke_linked_app_status is not None:
            self.revoke_linked_app_status = revoke_linked_app_status

    @property
    def revoke_linked_app_status(self):
        """
        :rtype: list of [RevokeLinkedAppStatus]
        """
        if self._revoke_linked_app_status_present:
            return self._revoke_linked_app_status_value
        else:
            raise AttributeError("missing required field 'revoke_linked_app_status'")

    @revoke_linked_app_status.setter
    def revoke_linked_app_status(self, val):
        val = self._revoke_linked_app_status_validator.validate(val)
        self._revoke_linked_app_status_value = val
        self._revoke_linked_app_status_present = True

    @revoke_linked_app_status.deleter
    def revoke_linked_app_status(self):
        self._revoke_linked_app_status_value = None
        self._revoke_linked_app_status_present = False

    def __repr__(self):
        return 'RevokeLinkedAppBatchResult(revoke_linked_app_status={!r})'.format(
            self._revoke_linked_app_status_value,
        )

class RevokeLinkedAppBatchError(object):
    """
    Error returned by linked_apps/revoke_linked_app_batch.

    :ivar unspecified: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'unspecified'
    # Attribute is overwritten below the class definition
    unspecified = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_unspecified(self):
        return self._tag == 'unspecified'

    def __repr__(self):
        return 'RevokeLinkedAppBatchError(%r)' % self._tag

class TeamMemberStatus(object):
    """
    The user's status as a member of a specific team.

    :ivar active: User has successfully logged into their Dropbox for Business
        account.
    :ivar invited: User has been invited to a team, but has not logged into
        their Dropbox for Business account yet.
    :ivar suspended: User is no longer a member of the team, but the account can
        be un-suspended, re-establishing the user as a team member.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = None
    # Attribute is overwritten below the class definition
    active = None
    # Attribute is overwritten below the class definition
    invited = None
    # Attribute is overwritten below the class definition
    suspended = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_active(self):
        return self._tag == 'active'

    def is_invited(self):
        return self._tag == 'invited'

    def is_suspended(self):
        return self._tag == 'suspended'

    def __repr__(self):
        return 'TeamMemberStatus(%r)' % self._tag

class AdminTier(object):
    """
    Describes which team-related admin permissions a user has.

    :ivar team_admin: User is an administrator of the team - has all
        permissions.
    :ivar user_management_admin: User can do most user provisioning,
        de-provisioning and management.
    :ivar support_admin: User can do a limited set of common support tasks for
        existing users.
    :ivar member_only: User is not an admin of the team.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = None
    # Attribute is overwritten below the class definition
    team_admin = None
    # Attribute is overwritten below the class definition
    user_management_admin = None
    # Attribute is overwritten below the class definition
    support_admin = None
    # Attribute is overwritten below the class definition
    member_only = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_team_admin(self):
        return self._tag == 'team_admin'

    def is_user_management_admin(self):
        return self._tag == 'user_management_admin'

    def is_support_admin(self):
        return self._tag == 'support_admin'

    def is_member_only(self):
        return self._tag == 'member_only'

    def __repr__(self):
        return 'AdminTier(%r)' % self._tag

class TeamMemberProfile(MemberProfile):
    """
    Profile of a user as a member of a team.

    :ivar status: The user's status as a member of a specific team.
    :ivar groups: List of group IDs of groups that the user belongs to.
    """

    __slots__ = [
        '_status_value',
        '_status_present',
        '_groups_value',
        '_groups_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 member_id=None,
                 account_id=None,
                 email=None,
                 email_verified=None,
                 name=None,
                 status=None,
                 groups=None,
                 external_id=None):
        super(TeamMemberProfile, self).__init__(member_id,
                                                account_id,
                                                email,
                                                email_verified,
                                                name,
                                                external_id)
        self._status_value = None
        self._status_present = False
        self._groups_value = None
        self._groups_present = False
        if status is not None:
            self.status = status
        if groups is not None:
            self.groups = groups

    @property
    def status(self):
        """
        The user's status as a member of a specific team.

        :rtype: TeamMemberStatus
        """
        if self._status_present:
            return self._status_value
        else:
            raise AttributeError("missing required field 'status'")

    @status.setter
    def status(self, val):
        self._status_validator.validate_type_only(val)
        self._status_value = val
        self._status_present = True

    @status.deleter
    def status(self):
        self._status_value = None
        self._status_present = False

    @property
    def groups(self):
        """
        List of group IDs of groups that the user belongs to.

        :rtype: list of [str]
        """
        if self._groups_present:
            return self._groups_value
        else:
            raise AttributeError("missing required field 'groups'")

    @groups.setter
    def groups(self, val):
        val = self._groups_validator.validate(val)
        self._groups_value = val
        self._groups_present = True

    @groups.deleter
    def groups(self):
        self._groups_value = None
        self._groups_present = False

    def __repr__(self):
        return 'TeamMemberProfile(member_id={!r}, account_id={!r}, email={!r}, email_verified={!r}, name={!r}, status={!r}, groups={!r}, external_id={!r})'.format(
            self._member_id_value,
            self._account_id_value,
            self._email_value,
            self._email_verified_value,
            self._name_value,
            self._status_value,
            self._groups_value,
            self._external_id_value,
        )

class MembersListArg(object):
    """
    :ivar limit: Number of results to return per call.
    """

    __slots__ = [
        '_limit_value',
        '_limit_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 limit=None):
        self._limit_value = None
        self._limit_present = False
        if limit is not None:
            self.limit = limit

    @property
    def limit(self):
        """
        Number of results to return per call.

        :rtype: long
        """
        if self._limit_present:
            return self._limit_value
        else:
            return 1000

    @limit.setter
    def limit(self, val):
        val = self._limit_validator.validate(val)
        self._limit_value = val
        self._limit_present = True

    @limit.deleter
    def limit(self):
        self._limit_value = None
        self._limit_present = False

    def __repr__(self):
        return 'MembersListArg(limit={!r})'.format(
            self._limit_value,
        )

class TeamMemberInfo(object):
    """
    Information about a team member.

    :ivar profile: Profile of a user as a member of a team.
    :ivar role: The user's role in the team.
    """

    __slots__ = [
        '_profile_value',
        '_profile_present',
        '_role_value',
        '_role_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 profile=None,
                 role=None):
        self._profile_value = None
        self._profile_present = False
        self._role_value = None
        self._role_present = False
        if profile is not None:
            self.profile = profile
        if role is not None:
            self.role = role

    @property
    def profile(self):
        """
        Profile of a user as a member of a team.

        :rtype: TeamMemberProfile
        """
        if self._profile_present:
            return self._profile_value
        else:
            raise AttributeError("missing required field 'profile'")

    @profile.setter
    def profile(self, val):
        self._profile_validator.validate_type_only(val)
        self._profile_value = val
        self._profile_present = True

    @profile.deleter
    def profile(self):
        self._profile_value = None
        self._profile_present = False

    @property
    def role(self):
        """
        The user's role in the team.

        :rtype: AdminTier
        """
        if self._role_present:
            return self._role_value
        else:
            raise AttributeError("missing required field 'role'")

    @role.setter
    def role(self, val):
        self._role_validator.validate_type_only(val)
        self._role_value = val
        self._role_present = True

    @role.deleter
    def role(self):
        self._role_value = None
        self._role_present = False

    def __repr__(self):
        return 'TeamMemberInfo(profile={!r}, role={!r})'.format(
            self._profile_value,
            self._role_value,
        )

class MembersListResult(object):
    """
    :ivar members: List of team members.
    :ivar cursor: Pass the cursor into members/list/continue to obtain the
        additional members.
    :ivar has_more: Is true if there are additional team members that have not
        been returned yet. An additional call to members/list/continue can
        retrieve them.
    """

    __slots__ = [
        '_members_value',
        '_members_present',
        '_cursor_value',
        '_cursor_present',
        '_has_more_value',
        '_has_more_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 members=None,
                 cursor=None,
                 has_more=None):
        self._members_value = None
        self._members_present = False
        self._cursor_value = None
        self._cursor_present = False
        self._has_more_value = None
        self._has_more_present = False
        if members is not None:
            self.members = members
        if cursor is not None:
            self.cursor = cursor
        if has_more is not None:
            self.has_more = has_more

    @property
    def members(self):
        """
        List of team members.

        :rtype: list of [TeamMemberInfo]
        """
        if self._members_present:
            return self._members_value
        else:
            raise AttributeError("missing required field 'members'")

    @members.setter
    def members(self, val):
        val = self._members_validator.validate(val)
        self._members_value = val
        self._members_present = True

    @members.deleter
    def members(self):
        self._members_value = None
        self._members_present = False

    @property
    def cursor(self):
        """
        Pass the cursor into members/list/continue to obtain the additional
        members.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            raise AttributeError("missing required field 'cursor'")

    @cursor.setter
    def cursor(self, val):
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    @property
    def has_more(self):
        """
        Is true if there are additional team members that have not been returned
        yet. An additional call to members/list/continue can retrieve them.

        :rtype: bool
        """
        if self._has_more_present:
            return self._has_more_value
        else:
            raise AttributeError("missing required field 'has_more'")

    @has_more.setter
    def has_more(self, val):
        val = self._has_more_validator.validate(val)
        self._has_more_value = val
        self._has_more_present = True

    @has_more.deleter
    def has_more(self):
        self._has_more_value = None
        self._has_more_present = False

    def __repr__(self):
        return 'MembersListResult(members={!r}, cursor={!r}, has_more={!r})'.format(
            self._members_value,
            self._cursor_value,
            self._has_more_value,
        )

class MembersListError(object):
    """
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersListError(%r)' % self._tag

class MembersListContinueArg(object):
    """
    :ivar cursor: Indicates from what point to get the next set of members.
    """

    __slots__ = [
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 cursor=None):
        self._cursor_value = None
        self._cursor_present = False
        if cursor is not None:
            self.cursor = cursor

    @property
    def cursor(self):
        """
        Indicates from what point to get the next set of members.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            raise AttributeError("missing required field 'cursor'")

    @cursor.setter
    def cursor(self, val):
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'MembersListContinueArg(cursor={!r})'.format(
            self._cursor_value,
        )

class MembersListContinueError(object):
    """
    :ivar invalid_cursor: The cursor is invalid.
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    invalid_cursor = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_invalid_cursor(self):
        return self._tag == 'invalid_cursor'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersListContinueError(%r)' % self._tag

class GetInfoError(UserSelectorError):
    """
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'GetInfoError(%r)' % self._tag

class GetInfoBatchItem(object):
    """
    Describes a result obtained for a single user whose id was specified in the
    parameter of members/get_info_batch.

    :ivar id: An ID that was provided as a parameter to members/get_info_batch.
        This might be a member_id, an email, or an external ID, depending on how
        the get_info_batch method was called.
    :ivar member_info: Info about a team member. Present if a team member
        corresponding to the ``id`` was found.
    """

    __slots__ = [
        '_id_value',
        '_id_present',
        '_member_info_value',
        '_member_info_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 id=None,
                 member_info=None):
        self._id_value = None
        self._id_present = False
        self._member_info_value = None
        self._member_info_present = False
        if id is not None:
            self.id = id
        if member_info is not None:
            self.member_info = member_info

    @property
    def id(self):
        """
        An ID that was provided as a parameter to members/get_info_batch. This
        might be a member_id, an email, or an external ID, depending on how the
        get_info_batch method was called.

        :rtype: str
        """
        if self._id_present:
            return self._id_value
        else:
            raise AttributeError("missing required field 'id'")

    @id.setter
    def id(self, val):
        val = self._id_validator.validate(val)
        self._id_value = val
        self._id_present = True

    @id.deleter
    def id(self):
        self._id_value = None
        self._id_present = False

    @property
    def member_info(self):
        """
        Info about a team member. Present if a team member corresponding to the
        ``id`` was found.

        :rtype: TeamMemberInfo
        """
        if self._member_info_present:
            return self._member_info_value
        else:
            return None

    @member_info.setter
    def member_info(self, val):
        if val is None:
            del self.member_info
            return
        self._member_info_validator.validate_type_only(val)
        self._member_info_value = val
        self._member_info_present = True

    @member_info.deleter
    def member_info(self):
        self._member_info_value = None
        self._member_info_present = False

    def __repr__(self):
        return 'GetInfoBatchItem(id={!r}, member_info={!r})'.format(
            self._id_value,
            self._member_info_value,
        )

class GetInfoBatchError(object):
    """
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'GetInfoBatchError(%r)' % self._tag

class MemberAddArg(object):
    """
    :ivar member_given_name: Member's first name.
    :ivar member_surname: Member's last name.
    :ivar member_external_id: External ID for member.
    :ivar send_welcome_email: Whether to send a welcome email to the member. If
        send_welcome_email is false, no email invitation will be sent to the
        user. This may be useful for apps using single sign-on (SSO) flows for
        onboarding that want to handle Dropbox for Business announcements
        themselves.
    """

    __slots__ = [
        '_member_email_value',
        '_member_email_present',
        '_member_given_name_value',
        '_member_given_name_present',
        '_member_surname_value',
        '_member_surname_present',
        '_member_external_id_value',
        '_member_external_id_present',
        '_send_welcome_email_value',
        '_send_welcome_email_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 member_email=None,
                 member_given_name=None,
                 member_surname=None,
                 member_external_id=None,
                 send_welcome_email=None):
        self._member_email_value = None
        self._member_email_present = False
        self._member_given_name_value = None
        self._member_given_name_present = False
        self._member_surname_value = None
        self._member_surname_present = False
        self._member_external_id_value = None
        self._member_external_id_present = False
        self._send_welcome_email_value = None
        self._send_welcome_email_present = False
        if member_email is not None:
            self.member_email = member_email
        if member_given_name is not None:
            self.member_given_name = member_given_name
        if member_surname is not None:
            self.member_surname = member_surname
        if member_external_id is not None:
            self.member_external_id = member_external_id
        if send_welcome_email is not None:
            self.send_welcome_email = send_welcome_email

    @property
    def member_email(self):
        """
        :rtype: str
        """
        if self._member_email_present:
            return self._member_email_value
        else:
            raise AttributeError("missing required field 'member_email'")

    @member_email.setter
    def member_email(self, val):
        val = self._member_email_validator.validate(val)
        self._member_email_value = val
        self._member_email_present = True

    @member_email.deleter
    def member_email(self):
        self._member_email_value = None
        self._member_email_present = False

    @property
    def member_given_name(self):
        """
        Member's first name.

        :rtype: str
        """
        if self._member_given_name_present:
            return self._member_given_name_value
        else:
            raise AttributeError("missing required field 'member_given_name'")

    @member_given_name.setter
    def member_given_name(self, val):
        val = self._member_given_name_validator.validate(val)
        self._member_given_name_value = val
        self._member_given_name_present = True

    @member_given_name.deleter
    def member_given_name(self):
        self._member_given_name_value = None
        self._member_given_name_present = False

    @property
    def member_surname(self):
        """
        Member's last name.

        :rtype: str
        """
        if self._member_surname_present:
            return self._member_surname_value
        else:
            raise AttributeError("missing required field 'member_surname'")

    @member_surname.setter
    def member_surname(self, val):
        val = self._member_surname_validator.validate(val)
        self._member_surname_value = val
        self._member_surname_present = True

    @member_surname.deleter
    def member_surname(self):
        self._member_surname_value = None
        self._member_surname_present = False

    @property
    def member_external_id(self):
        """
        External ID for member.

        :rtype: str
        """
        if self._member_external_id_present:
            return self._member_external_id_value
        else:
            return None

    @member_external_id.setter
    def member_external_id(self, val):
        if val is None:
            del self.member_external_id
            return
        val = self._member_external_id_validator.validate(val)
        self._member_external_id_value = val
        self._member_external_id_present = True

    @member_external_id.deleter
    def member_external_id(self):
        self._member_external_id_value = None
        self._member_external_id_present = False

    @property
    def send_welcome_email(self):
        """
        Whether to send a welcome email to the member. If send_welcome_email is
        false, no email invitation will be sent to the user. This may be useful
        for apps using single sign-on (SSO) flows for onboarding that want to
        handle Dropbox for Business announcements themselves.

        :rtype: bool
        """
        if self._send_welcome_email_present:
            return self._send_welcome_email_value
        else:
            return True

    @send_welcome_email.setter
    def send_welcome_email(self, val):
        val = self._send_welcome_email_validator.validate(val)
        self._send_welcome_email_value = val
        self._send_welcome_email_present = True

    @send_welcome_email.deleter
    def send_welcome_email(self):
        self._send_welcome_email_value = None
        self._send_welcome_email_present = False

    def __repr__(self):
        return 'MemberAddArg(member_email={!r}, member_given_name={!r}, member_surname={!r}, member_external_id={!r}, send_welcome_email={!r})'.format(
            self._member_email_value,
            self._member_given_name_value,
            self._member_surname_value,
            self._member_external_id_value,
            self._send_welcome_email_value,
        )

class MemberAddError(object):
    """
    :ivar team_license_limit: Team is already full. The Dropbox for Business
        organization has no available licenses.
    :ivar free_team_member_limit_reached: Team is already full. The free team
        member limit has been reached.
    :ivar user_already_on_team: User is already on this team. The provided email
        address is associated with a user who is already a member of or invited
        to the team.
    :ivar user_on_another_team: User is already on another team. The provided
        email address is associated with a user that is already a member or
        invited to another team.
    :ivar user_already_paired: User is already paired.
    :ivar user_migration_failed: User migration has failed.
    :ivar duplicate_external_member_id: A user with the given external member ID
        already exists on the team.
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    team_license_limit = None
    # Attribute is overwritten below the class definition
    free_team_member_limit_reached = None
    # Attribute is overwritten below the class definition
    user_already_on_team = None
    # Attribute is overwritten below the class definition
    user_on_another_team = None
    # Attribute is overwritten below the class definition
    user_already_paired = None
    # Attribute is overwritten below the class definition
    user_migration_failed = None
    # Attribute is overwritten below the class definition
    duplicate_external_member_id = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_team_license_limit(self):
        return self._tag == 'team_license_limit'

    def is_free_team_member_limit_reached(self):
        return self._tag == 'free_team_member_limit_reached'

    def is_user_already_on_team(self):
        return self._tag == 'user_already_on_team'

    def is_user_on_another_team(self):
        return self._tag == 'user_on_another_team'

    def is_user_already_paired(self):
        return self._tag == 'user_already_paired'

    def is_user_migration_failed(self):
        return self._tag == 'user_migration_failed'

    def is_duplicate_external_member_id(self):
        return self._tag == 'duplicate_external_member_id'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'MemberAddError(%r)' % self._tag

class MembersSetProfileArg(object):
    """
    Exactly one of member_id, email, or external_id must be provided to identify
    the user account. At least one of new_email, new_external_id,
    new_given_name, and/or new_surname must be provided.

    :ivar user: Identity of user whose profile will be set.
    :ivar new_email: New email for member.
    :ivar new_external_id: New external ID for member.
    :ivar new_given_name: New given name for member.
    :ivar new_surname: New surname for member.
    """

    __slots__ = [
        '_user_value',
        '_user_present',
        '_new_email_value',
        '_new_email_present',
        '_new_external_id_value',
        '_new_external_id_present',
        '_new_given_name_value',
        '_new_given_name_present',
        '_new_surname_value',
        '_new_surname_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 user=None,
                 new_email=None,
                 new_external_id=None,
                 new_given_name=None,
                 new_surname=None):
        self._user_value = None
        self._user_present = False
        self._new_email_value = None
        self._new_email_present = False
        self._new_external_id_value = None
        self._new_external_id_present = False
        self._new_given_name_value = None
        self._new_given_name_present = False
        self._new_surname_value = None
        self._new_surname_present = False
        if user is not None:
            self.user = user
        if new_email is not None:
            self.new_email = new_email
        if new_external_id is not None:
            self.new_external_id = new_external_id
        if new_given_name is not None:
            self.new_given_name = new_given_name
        if new_surname is not None:
            self.new_surname = new_surname

    @property
    def user(self):
        """
        Identity of user whose profile will be set.

        :rtype: UserSelectorArg
        """
        if self._user_present:
            return self._user_value
        else:
            raise AttributeError("missing required field 'user'")

    @user.setter
    def user(self, val):
        self._user_validator.validate_type_only(val)
        self._user_value = val
        self._user_present = True

    @user.deleter
    def user(self):
        self._user_value = None
        self._user_present = False

    @property
    def new_email(self):
        """
        New email for member.

        :rtype: str
        """
        if self._new_email_present:
            return self._new_email_value
        else:
            return None

    @new_email.setter
    def new_email(self, val):
        if val is None:
            del self.new_email
            return
        val = self._new_email_validator.validate(val)
        self._new_email_value = val
        self._new_email_present = True

    @new_email.deleter
    def new_email(self):
        self._new_email_value = None
        self._new_email_present = False

    @property
    def new_external_id(self):
        """
        New external ID for member.

        :rtype: str
        """
        if self._new_external_id_present:
            return self._new_external_id_value
        else:
            return None

    @new_external_id.setter
    def new_external_id(self, val):
        if val is None:
            del self.new_external_id
            return
        val = self._new_external_id_validator.validate(val)
        self._new_external_id_value = val
        self._new_external_id_present = True

    @new_external_id.deleter
    def new_external_id(self):
        self._new_external_id_value = None
        self._new_external_id_present = False

    @property
    def new_given_name(self):
        """
        New given name for member.

        :rtype: str
        """
        if self._new_given_name_present:
            return self._new_given_name_value
        else:
            return None

    @new_given_name.setter
    def new_given_name(self, val):
        if val is None:
            del self.new_given_name
            return
        val = self._new_given_name_validator.validate(val)
        self._new_given_name_value = val
        self._new_given_name_present = True

    @new_given_name.deleter
    def new_given_name(self):
        self._new_given_name_value = None
        self._new_given_name_present = False

    @property
    def new_surname(self):
        """
        New surname for member.

        :rtype: str
        """
        if self._new_surname_present:
            return self._new_surname_value
        else:
            return None

    @new_surname.setter
    def new_surname(self, val):
        if val is None:
            del self.new_surname
            return
        val = self._new_surname_validator.validate(val)
        self._new_surname_value = val
        self._new_surname_present = True

    @new_surname.deleter
    def new_surname(self):
        self._new_surname_value = None
        self._new_surname_present = False

    def __repr__(self):
        return 'MembersSetProfileArg(user={!r}, new_email={!r}, new_external_id={!r}, new_given_name={!r}, new_surname={!r})'.format(
            self._user_value,
            self._new_email_value,
            self._new_external_id_value,
            self._new_given_name_value,
            self._new_surname_value,
        )

class MembersSetProfileError(UserSelectorError):
    """
    :ivar email_reserved_for_other_user: Email is already reserved for another
        user.
    :ivar external_id_used_by_other_user: The external ID is already in use by
        another team member.
    :ivar user_not_active: User is in the 'invited' state. A user profile cannot
        be edited until the user is in the 'active' state.
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    email_reserved_for_other_user = None
    # Attribute is overwritten below the class definition
    external_id_used_by_other_user = None
    # Attribute is overwritten below the class definition
    user_not_active = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_email_reserved_for_other_user(self):
        return self._tag == 'email_reserved_for_other_user'

    def is_external_id_used_by_other_user(self):
        return self._tag == 'external_id_used_by_other_user'

    def is_user_not_active(self):
        return self._tag == 'user_not_active'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersSetProfileError(%r)' % self._tag

class MembersSetRoleArg(object):
    """
    Exactly one of member_id, email, or external_id must be provided to identify
    the user account.

    :ivar user: Identity of user whose role will be set.
    :ivar new_role: The new role of the member.
    """

    __slots__ = [
        '_user_value',
        '_user_present',
        '_new_role_value',
        '_new_role_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 user=None,
                 new_role=None):
        self._user_value = None
        self._user_present = False
        self._new_role_value = None
        self._new_role_present = False
        if user is not None:
            self.user = user
        if new_role is not None:
            self.new_role = new_role

    @property
    def user(self):
        """
        Identity of user whose role will be set.

        :rtype: UserSelectorArg
        """
        if self._user_present:
            return self._user_value
        else:
            raise AttributeError("missing required field 'user'")

    @user.setter
    def user(self, val):
        self._user_validator.validate_type_only(val)
        self._user_value = val
        self._user_present = True

    @user.deleter
    def user(self):
        self._user_value = None
        self._user_present = False

    @property
    def new_role(self):
        """
        The new role of the member.

        :rtype: AdminTier
        """
        if self._new_role_present:
            return self._new_role_value
        else:
            raise AttributeError("missing required field 'new_role'")

    @new_role.setter
    def new_role(self, val):
        self._new_role_validator.validate_type_only(val)
        self._new_role_value = val
        self._new_role_present = True

    @new_role.deleter
    def new_role(self):
        self._new_role_value = None
        self._new_role_present = False

    def __repr__(self):
        return 'MembersSetRoleArg(user={!r}, new_role={!r})'.format(
            self._user_value,
            self._new_role_value,
        )

class MembersSetRoleResult(object):
    """
    :ivar member_id: The member ID of the user to which the change was applied.
    :ivar role: The role after the change.
    """

    __slots__ = [
        '_member_id_value',
        '_member_id_present',
        '_role_value',
        '_role_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 member_id=None,
                 role=None):
        self._member_id_value = None
        self._member_id_present = False
        self._role_value = None
        self._role_present = False
        if member_id is not None:
            self.member_id = member_id
        if role is not None:
            self.role = role

    @property
    def member_id(self):
        """
        The member ID of the user to which the change was applied.

        :rtype: str
        """
        if self._member_id_present:
            return self._member_id_value
        else:
            raise AttributeError("missing required field 'member_id'")

    @member_id.setter
    def member_id(self, val):
        val = self._member_id_validator.validate(val)
        self._member_id_value = val
        self._member_id_present = True

    @member_id.deleter
    def member_id(self):
        self._member_id_value = None
        self._member_id_present = False

    @property
    def role(self):
        """
        The role after the change.

        :rtype: AdminTier
        """
        if self._role_present:
            return self._role_value
        else:
            raise AttributeError("missing required field 'role'")

    @role.setter
    def role(self, val):
        self._role_validator.validate_type_only(val)
        self._role_value = val
        self._role_present = True

    @role.deleter
    def role(self):
        self._role_value = None
        self._role_present = False

    def __repr__(self):
        return 'MembersSetRoleResult(member_id={!r}, role={!r})'.format(
            self._member_id_value,
            self._role_value,
        )

class MembersSetRoleError(UserSelectorError):
    """
    :ivar last_admin: Cannot remove the admin setting of the last admin.
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    last_admin = None
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_last_admin(self):
        return self._tag == 'last_admin'

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersSetRoleError(%r)' % self._tag

class MembersSendWelcomeError(UserSelectorError):
    """
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersSendWelcomeError(%r)' % self._tag

class MembersRemoveArg(object):
    """
    Exactly one of member_id, email, or external_id must be provided to identify
    the user account.

    :ivar user: Identity of user to remove.
    :ivar transfer_dest_id: If provided, files from the deleted member account
        will be transferred to this user.
    :ivar transfer_admin_id: If provided, errors during the transfer process
        will be sent via email to this user.
    :ivar wipe_data: If provided, controls if the user's data will be deleted on
        their linked devices.
    """

    __slots__ = [
        '_user_value',
        '_user_present',
        '_transfer_dest_id_value',
        '_transfer_dest_id_present',
        '_transfer_admin_id_value',
        '_transfer_admin_id_present',
        '_wipe_data_value',
        '_wipe_data_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 user=None,
                 transfer_dest_id=None,
                 transfer_admin_id=None,
                 wipe_data=None):
        self._user_value = None
        self._user_present = False
        self._transfer_dest_id_value = None
        self._transfer_dest_id_present = False
        self._transfer_admin_id_value = None
        self._transfer_admin_id_present = False
        self._wipe_data_value = None
        self._wipe_data_present = False
        if user is not None:
            self.user = user
        if transfer_dest_id is not None:
            self.transfer_dest_id = transfer_dest_id
        if transfer_admin_id is not None:
            self.transfer_admin_id = transfer_admin_id
        if wipe_data is not None:
            self.wipe_data = wipe_data

    @property
    def user(self):
        """
        Identity of user to remove.

        :rtype: UserSelectorArg
        """
        if self._user_present:
            return self._user_value
        else:
            raise AttributeError("missing required field 'user'")

    @user.setter
    def user(self, val):
        self._user_validator.validate_type_only(val)
        self._user_value = val
        self._user_present = True

    @user.deleter
    def user(self):
        self._user_value = None
        self._user_present = False

    @property
    def transfer_dest_id(self):
        """
        If provided, files from the deleted member account will be transferred
        to this user.

        :rtype: UserSelectorArg
        """
        if self._transfer_dest_id_present:
            return self._transfer_dest_id_value
        else:
            return None

    @transfer_dest_id.setter
    def transfer_dest_id(self, val):
        if val is None:
            del self.transfer_dest_id
            return
        self._transfer_dest_id_validator.validate_type_only(val)
        self._transfer_dest_id_value = val
        self._transfer_dest_id_present = True

    @transfer_dest_id.deleter
    def transfer_dest_id(self):
        self._transfer_dest_id_value = None
        self._transfer_dest_id_present = False

    @property
    def transfer_admin_id(self):
        """
        If provided, errors during the transfer process will be sent via email
        to this user.

        :rtype: UserSelectorArg
        """
        if self._transfer_admin_id_present:
            return self._transfer_admin_id_value
        else:
            return None

    @transfer_admin_id.setter
    def transfer_admin_id(self, val):
        if val is None:
            del self.transfer_admin_id
            return
        self._transfer_admin_id_validator.validate_type_only(val)
        self._transfer_admin_id_value = val
        self._transfer_admin_id_present = True

    @transfer_admin_id.deleter
    def transfer_admin_id(self):
        self._transfer_admin_id_value = None
        self._transfer_admin_id_present = False

    @property
    def wipe_data(self):
        """
        If provided, controls if the user's data will be deleted on their linked
        devices.

        :rtype: bool
        """
        if self._wipe_data_present:
            return self._wipe_data_value
        else:
            return True

    @wipe_data.setter
    def wipe_data(self, val):
        val = self._wipe_data_validator.validate(val)
        self._wipe_data_value = val
        self._wipe_data_present = True

    @wipe_data.deleter
    def wipe_data(self):
        self._wipe_data_value = None
        self._wipe_data_present = False

    def __repr__(self):
        return 'MembersRemoveArg(user={!r}, transfer_dest_id={!r}, transfer_admin_id={!r}, wipe_data={!r})'.format(
            self._user_value,
            self._transfer_dest_id_value,
            self._transfer_admin_id_value,
            self._wipe_data_value,
        )

class MembersRemoveError(UserSelectorError):
    """
    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersRemoveError(%r)' % self._tag

class DateRange(object):
    """
    Input arguments that can be provided for most reports.

    :ivar start_date: Optional starting date (inclusive)
    :ivar end_date: Optional ending date (exclusive)
    """

    __slots__ = [
        '_start_date_value',
        '_start_date_present',
        '_end_date_value',
        '_end_date_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 start_date=None,
                 end_date=None):
        self._start_date_value = None
        self._start_date_present = False
        self._end_date_value = None
        self._end_date_present = False
        if start_date is not None:
            self.start_date = start_date
        if end_date is not None:
            self.end_date = end_date

    @property
    def start_date(self):
        """
        Optional starting date (inclusive)

        :rtype: datetime.datetime
        """
        if self._start_date_present:
            return self._start_date_value
        else:
            return None

    @start_date.setter
    def start_date(self, val):
        if val is None:
            del self.start_date
            return
        val = self._start_date_validator.validate(val)
        self._start_date_value = val
        self._start_date_present = True

    @start_date.deleter
    def start_date(self):
        self._start_date_value = None
        self._start_date_present = False

    @property
    def end_date(self):
        """
        Optional ending date (exclusive)

        :rtype: datetime.datetime
        """
        if self._end_date_present:
            return self._end_date_value
        else:
            return None

    @end_date.setter
    def end_date(self, val):
        if val is None:
            del self.end_date
            return
        val = self._end_date_validator.validate(val)
        self._end_date_value = val
        self._end_date_present = True

    @end_date.deleter
    def end_date(self):
        self._end_date_value = None
        self._end_date_present = False

    def __repr__(self):
        return 'DateRange(start_date={!r}, end_date={!r})'.format(
            self._start_date_value,
            self._end_date_value,
        )

class DateRangeError(object):
    """
    Errors that can originate from problems in input arguments to reports.

    :ivar other: An unspecified error.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_other(self):
        return self._tag == 'other'

    def __repr__(self):
        return 'DateRangeError(%r)' % self._tag

class StorageBucket(object):
    """
    Describes the number of users in a specific storage bucket.

    :ivar bucket: The name of the storage bucket. For example, '1G' is a bucket
        of users with storage size up to 1 Giga.
    :ivar users: The number of people whose storage is in the range of this
        storage bucket.
    """

    __slots__ = [
        '_bucket_value',
        '_bucket_present',
        '_users_value',
        '_users_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 bucket=None,
                 users=None):
        self._bucket_value = None
        self._bucket_present = False
        self._users_value = None
        self._users_present = False
        if bucket is not None:
            self.bucket = bucket
        if users is not None:
            self.users = users

    @property
    def bucket(self):
        """
        The name of the storage bucket. For example, '1G' is a bucket of users
        with storage size up to 1 Giga.

        :rtype: str
        """
        if self._bucket_present:
            return self._bucket_value
        else:
            raise AttributeError("missing required field 'bucket'")

    @bucket.setter
    def bucket(self, val):
        val = self._bucket_validator.validate(val)
        self._bucket_value = val
        self._bucket_present = True

    @bucket.deleter
    def bucket(self):
        self._bucket_value = None
        self._bucket_present = False

    @property
    def users(self):
        """
        The number of people whose storage is in the range of this storage
        bucket.

        :rtype: long
        """
        if self._users_present:
            return self._users_value
        else:
            raise AttributeError("missing required field 'users'")

    @users.setter
    def users(self, val):
        val = self._users_validator.validate(val)
        self._users_value = val
        self._users_present = True

    @users.deleter
    def users(self):
        self._users_value = None
        self._users_present = False

    def __repr__(self):
        return 'StorageBucket(bucket={!r}, users={!r})'.format(
            self._bucket_value,
            self._users_value,
        )

class BaseDfbReport(object):
    """
    Base report structure.

    :ivar start_date: First date present in the results as 'YYYY-MM-DD' or None.
    """

    __slots__ = [
        '_start_date_value',
        '_start_date_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 start_date=None):
        self._start_date_value = None
        self._start_date_present = False
        if start_date is not None:
            self.start_date = start_date

    @property
    def start_date(self):
        """
        First date present in the results as 'YYYY-MM-DD' or None.

        :rtype: str
        """
        if self._start_date_present:
            return self._start_date_value
        else:
            raise AttributeError("missing required field 'start_date'")

    @start_date.setter
    def start_date(self, val):
        val = self._start_date_validator.validate(val)
        self._start_date_value = val
        self._start_date_present = True

    @start_date.deleter
    def start_date(self):
        self._start_date_value = None
        self._start_date_present = False

    def __repr__(self):
        return 'BaseDfbReport(start_date={!r})'.format(
            self._start_date_value,
        )

class GetStorageReport(BaseDfbReport):
    """
    Storage Report Result. Each of the items in the storage report is an array
    of values, one value per day. If there is no data for a day, then the value
    will be None.

    :ivar total_usage: Sum of the shared, unshared, and datastore usages, for
        each day.
    :ivar shared_usage: Array of the combined size (bytes) of team members'
        shared folders, for each day.
    :ivar unshared_usage: Array of the combined size (bytes) of team members'
        root namespaces, for each day.
    :ivar shared_folders: Array of the number of shared folders owned by team
        members, for each day.
    :ivar member_storage_map: Array of storage summaries of team members'
        account sizes. Each storage summary is an array of key, value pairs,
        where each pair describes a storage bucket. The key indicates the upper
        bound of the bucket and the value is the number of users in that bucket.
        There is one such summary per day. If there is no data for a day, the
        storage summary will be empty.
    """

    __slots__ = [
        '_total_usage_value',
        '_total_usage_present',
        '_shared_usage_value',
        '_shared_usage_present',
        '_unshared_usage_value',
        '_unshared_usage_present',
        '_shared_folders_value',
        '_shared_folders_present',
        '_member_storage_map_value',
        '_member_storage_map_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 start_date=None,
                 total_usage=None,
                 shared_usage=None,
                 unshared_usage=None,
                 shared_folders=None,
                 member_storage_map=None):
        super(GetStorageReport, self).__init__(start_date)
        self._total_usage_value = None
        self._total_usage_present = False
        self._shared_usage_value = None
        self._shared_usage_present = False
        self._unshared_usage_value = None
        self._unshared_usage_present = False
        self._shared_folders_value = None
        self._shared_folders_present = False
        self._member_storage_map_value = None
        self._member_storage_map_present = False
        if total_usage is not None:
            self.total_usage = total_usage
        if shared_usage is not None:
            self.shared_usage = shared_usage
        if unshared_usage is not None:
            self.unshared_usage = unshared_usage
        if shared_folders is not None:
            self.shared_folders = shared_folders
        if member_storage_map is not None:
            self.member_storage_map = member_storage_map

    @property
    def total_usage(self):
        """
        Sum of the shared, unshared, and datastore usages, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._total_usage_present:
            return self._total_usage_value
        else:
            raise AttributeError("missing required field 'total_usage'")

    @total_usage.setter
    def total_usage(self, val):
        val = self._total_usage_validator.validate(val)
        self._total_usage_value = val
        self._total_usage_present = True

    @total_usage.deleter
    def total_usage(self):
        self._total_usage_value = None
        self._total_usage_present = False

    @property
    def shared_usage(self):
        """
        Array of the combined size (bytes) of team members' shared folders, for
        each day.

        :rtype: list of [Optional[long]]
        """
        if self._shared_usage_present:
            return self._shared_usage_value
        else:
            raise AttributeError("missing required field 'shared_usage'")

    @shared_usage.setter
    def shared_usage(self, val):
        val = self._shared_usage_validator.validate(val)
        self._shared_usage_value = val
        self._shared_usage_present = True

    @shared_usage.deleter
    def shared_usage(self):
        self._shared_usage_value = None
        self._shared_usage_present = False

    @property
    def unshared_usage(self):
        """
        Array of the combined size (bytes) of team members' root namespaces, for
        each day.

        :rtype: list of [Optional[long]]
        """
        if self._unshared_usage_present:
            return self._unshared_usage_value
        else:
            raise AttributeError("missing required field 'unshared_usage'")

    @unshared_usage.setter
    def unshared_usage(self, val):
        val = self._unshared_usage_validator.validate(val)
        self._unshared_usage_value = val
        self._unshared_usage_present = True

    @unshared_usage.deleter
    def unshared_usage(self):
        self._unshared_usage_value = None
        self._unshared_usage_present = False

    @property
    def shared_folders(self):
        """
        Array of the number of shared folders owned by team members, for each
        day.

        :rtype: list of [Optional[long]]
        """
        if self._shared_folders_present:
            return self._shared_folders_value
        else:
            raise AttributeError("missing required field 'shared_folders'")

    @shared_folders.setter
    def shared_folders(self, val):
        val = self._shared_folders_validator.validate(val)
        self._shared_folders_value = val
        self._shared_folders_present = True

    @shared_folders.deleter
    def shared_folders(self):
        self._shared_folders_value = None
        self._shared_folders_present = False

    @property
    def member_storage_map(self):
        """
        Array of storage summaries of team members' account sizes. Each storage
        summary is an array of key, value pairs, where each pair describes a
        storage bucket. The key indicates the upper bound of the bucket and the
        value is the number of users in that bucket. There is one such summary
        per day. If there is no data for a day, the storage summary will be
        empty.

        :rtype: list of [list of [StorageBucket]]
        """
        if self._member_storage_map_present:
            return self._member_storage_map_value
        else:
            raise AttributeError("missing required field 'member_storage_map'")

    @member_storage_map.setter
    def member_storage_map(self, val):
        val = self._member_storage_map_validator.validate(val)
        self._member_storage_map_value = val
        self._member_storage_map_present = True

    @member_storage_map.deleter
    def member_storage_map(self):
        self._member_storage_map_value = None
        self._member_storage_map_present = False

    def __repr__(self):
        return 'GetStorageReport(start_date={!r}, total_usage={!r}, shared_usage={!r}, unshared_usage={!r}, shared_folders={!r}, member_storage_map={!r})'.format(
            self._start_date_value,
            self._total_usage_value,
            self._shared_usage_value,
            self._unshared_usage_value,
            self._shared_folders_value,
            self._member_storage_map_value,
        )

class GetActivityReport(BaseDfbReport):
    """
    Activity Report Result. Each of the items in the storage report is an array
    of values, one value per day. If there is no data for a day, then the value
    will be None.

    :ivar adds: Array of total number of adds by team members.
    :ivar edits: Array of number of edits by team members. If the same user
        edits the same file multiple times this is counted as a single edit.
    :ivar deletes: Array of total number of deletes by team members.
    :ivar active_users_28_day: Array of the number of users who have been active
        in the last 28 days.
    :ivar active_users_7_day: Array of the number of users who have been active
        in the last week.
    :ivar active_users_1_day: Array of the number of users who have been active
        in the last day.
    :ivar active_shared_folders_28_day: Array of the number of shared folders
        with some activity in the last 28 days.
    :ivar active_shared_folders_7_day: Array of the number of shared folders
        with some activity in the last week.
    :ivar active_shared_folders_1_day: Array of the number of shared folders
        with some activity in the last day.
    :ivar shared_links_created: Array of the number of shared links created.
    :ivar shared_links_viewed_by_team: Array of the number of views by team
        users to shared links created by the team.
    :ivar shared_links_viewed_by_outside_user: Array of the number of views by
        users outside of the team to shared links created by the team.
    :ivar shared_links_viewed_by_not_logged_in: Array of the number of views by
        non-logged-in users to shared links created by the team.
    :ivar shared_links_viewed_total: Array of the total number of views to
        shared links created by the team.
    """

    __slots__ = [
        '_adds_value',
        '_adds_present',
        '_edits_value',
        '_edits_present',
        '_deletes_value',
        '_deletes_present',
        '_active_users_28_day_value',
        '_active_users_28_day_present',
        '_active_users_7_day_value',
        '_active_users_7_day_present',
        '_active_users_1_day_value',
        '_active_users_1_day_present',
        '_active_shared_folders_28_day_value',
        '_active_shared_folders_28_day_present',
        '_active_shared_folders_7_day_value',
        '_active_shared_folders_7_day_present',
        '_active_shared_folders_1_day_value',
        '_active_shared_folders_1_day_present',
        '_shared_links_created_value',
        '_shared_links_created_present',
        '_shared_links_viewed_by_team_value',
        '_shared_links_viewed_by_team_present',
        '_shared_links_viewed_by_outside_user_value',
        '_shared_links_viewed_by_outside_user_present',
        '_shared_links_viewed_by_not_logged_in_value',
        '_shared_links_viewed_by_not_logged_in_present',
        '_shared_links_viewed_total_value',
        '_shared_links_viewed_total_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 start_date=None,
                 adds=None,
                 edits=None,
                 deletes=None,
                 active_users_28_day=None,
                 active_users_7_day=None,
                 active_users_1_day=None,
                 active_shared_folders_28_day=None,
                 active_shared_folders_7_day=None,
                 active_shared_folders_1_day=None,
                 shared_links_created=None,
                 shared_links_viewed_by_team=None,
                 shared_links_viewed_by_outside_user=None,
                 shared_links_viewed_by_not_logged_in=None,
                 shared_links_viewed_total=None):
        super(GetActivityReport, self).__init__(start_date)
        self._adds_value = None
        self._adds_present = False
        self._edits_value = None
        self._edits_present = False
        self._deletes_value = None
        self._deletes_present = False
        self._active_users_28_day_value = None
        self._active_users_28_day_present = False
        self._active_users_7_day_value = None
        self._active_users_7_day_present = False
        self._active_users_1_day_value = None
        self._active_users_1_day_present = False
        self._active_shared_folders_28_day_value = None
        self._active_shared_folders_28_day_present = False
        self._active_shared_folders_7_day_value = None
        self._active_shared_folders_7_day_present = False
        self._active_shared_folders_1_day_value = None
        self._active_shared_folders_1_day_present = False
        self._shared_links_created_value = None
        self._shared_links_created_present = False
        self._shared_links_viewed_by_team_value = None
        self._shared_links_viewed_by_team_present = False
        self._shared_links_viewed_by_outside_user_value = None
        self._shared_links_viewed_by_outside_user_present = False
        self._shared_links_viewed_by_not_logged_in_value = None
        self._shared_links_viewed_by_not_logged_in_present = False
        self._shared_links_viewed_total_value = None
        self._shared_links_viewed_total_present = False
        if adds is not None:
            self.adds = adds
        if edits is not None:
            self.edits = edits
        if deletes is not None:
            self.deletes = deletes
        if active_users_28_day is not None:
            self.active_users_28_day = active_users_28_day
        if active_users_7_day is not None:
            self.active_users_7_day = active_users_7_day
        if active_users_1_day is not None:
            self.active_users_1_day = active_users_1_day
        if active_shared_folders_28_day is not None:
            self.active_shared_folders_28_day = active_shared_folders_28_day
        if active_shared_folders_7_day is not None:
            self.active_shared_folders_7_day = active_shared_folders_7_day
        if active_shared_folders_1_day is not None:
            self.active_shared_folders_1_day = active_shared_folders_1_day
        if shared_links_created is not None:
            self.shared_links_created = shared_links_created
        if shared_links_viewed_by_team is not None:
            self.shared_links_viewed_by_team = shared_links_viewed_by_team
        if shared_links_viewed_by_outside_user is not None:
            self.shared_links_viewed_by_outside_user = shared_links_viewed_by_outside_user
        if shared_links_viewed_by_not_logged_in is not None:
            self.shared_links_viewed_by_not_logged_in = shared_links_viewed_by_not_logged_in
        if shared_links_viewed_total is not None:
            self.shared_links_viewed_total = shared_links_viewed_total

    @property
    def adds(self):
        """
        Array of total number of adds by team members.

        :rtype: list of [Optional[long]]
        """
        if self._adds_present:
            return self._adds_value
        else:
            raise AttributeError("missing required field 'adds'")

    @adds.setter
    def adds(self, val):
        val = self._adds_validator.validate(val)
        self._adds_value = val
        self._adds_present = True

    @adds.deleter
    def adds(self):
        self._adds_value = None
        self._adds_present = False

    @property
    def edits(self):
        """
        Array of number of edits by team members. If the same user edits the
        same file multiple times this is counted as a single edit.

        :rtype: list of [Optional[long]]
        """
        if self._edits_present:
            return self._edits_value
        else:
            raise AttributeError("missing required field 'edits'")

    @edits.setter
    def edits(self, val):
        val = self._edits_validator.validate(val)
        self._edits_value = val
        self._edits_present = True

    @edits.deleter
    def edits(self):
        self._edits_value = None
        self._edits_present = False

    @property
    def deletes(self):
        """
        Array of total number of deletes by team members.

        :rtype: list of [Optional[long]]
        """
        if self._deletes_present:
            return self._deletes_value
        else:
            raise AttributeError("missing required field 'deletes'")

    @deletes.setter
    def deletes(self, val):
        val = self._deletes_validator.validate(val)
        self._deletes_value = val
        self._deletes_present = True

    @deletes.deleter
    def deletes(self):
        self._deletes_value = None
        self._deletes_present = False

    @property
    def active_users_28_day(self):
        """
        Array of the number of users who have been active in the last 28 days.

        :rtype: list of [Optional[long]]
        """
        if self._active_users_28_day_present:
            return self._active_users_28_day_value
        else:
            raise AttributeError("missing required field 'active_users_28_day'")

    @active_users_28_day.setter
    def active_users_28_day(self, val):
        val = self._active_users_28_day_validator.validate(val)
        self._active_users_28_day_value = val
        self._active_users_28_day_present = True

    @active_users_28_day.deleter
    def active_users_28_day(self):
        self._active_users_28_day_value = None
        self._active_users_28_day_present = False

    @property
    def active_users_7_day(self):
        """
        Array of the number of users who have been active in the last week.

        :rtype: list of [Optional[long]]
        """
        if self._active_users_7_day_present:
            return self._active_users_7_day_value
        else:
            raise AttributeError("missing required field 'active_users_7_day'")

    @active_users_7_day.setter
    def active_users_7_day(self, val):
        val = self._active_users_7_day_validator.validate(val)
        self._active_users_7_day_value = val
        self._active_users_7_day_present = True

    @active_users_7_day.deleter
    def active_users_7_day(self):
        self._active_users_7_day_value = None
        self._active_users_7_day_present = False

    @property
    def active_users_1_day(self):
        """
        Array of the number of users who have been active in the last day.

        :rtype: list of [Optional[long]]
        """
        if self._active_users_1_day_present:
            return self._active_users_1_day_value
        else:
            raise AttributeError("missing required field 'active_users_1_day'")

    @active_users_1_day.setter
    def active_users_1_day(self, val):
        val = self._active_users_1_day_validator.validate(val)
        self._active_users_1_day_value = val
        self._active_users_1_day_present = True

    @active_users_1_day.deleter
    def active_users_1_day(self):
        self._active_users_1_day_value = None
        self._active_users_1_day_present = False

    @property
    def active_shared_folders_28_day(self):
        """
        Array of the number of shared folders with some activity in the last 28
        days.

        :rtype: list of [Optional[long]]
        """
        if self._active_shared_folders_28_day_present:
            return self._active_shared_folders_28_day_value
        else:
            raise AttributeError("missing required field 'active_shared_folders_28_day'")

    @active_shared_folders_28_day.setter
    def active_shared_folders_28_day(self, val):
        val = self._active_shared_folders_28_day_validator.validate(val)
        self._active_shared_folders_28_day_value = val
        self._active_shared_folders_28_day_present = True

    @active_shared_folders_28_day.deleter
    def active_shared_folders_28_day(self):
        self._active_shared_folders_28_day_value = None
        self._active_shared_folders_28_day_present = False

    @property
    def active_shared_folders_7_day(self):
        """
        Array of the number of shared folders with some activity in the last
        week.

        :rtype: list of [Optional[long]]
        """
        if self._active_shared_folders_7_day_present:
            return self._active_shared_folders_7_day_value
        else:
            raise AttributeError("missing required field 'active_shared_folders_7_day'")

    @active_shared_folders_7_day.setter
    def active_shared_folders_7_day(self, val):
        val = self._active_shared_folders_7_day_validator.validate(val)
        self._active_shared_folders_7_day_value = val
        self._active_shared_folders_7_day_present = True

    @active_shared_folders_7_day.deleter
    def active_shared_folders_7_day(self):
        self._active_shared_folders_7_day_value = None
        self._active_shared_folders_7_day_present = False

    @property
    def active_shared_folders_1_day(self):
        """
        Array of the number of shared folders with some activity in the last
        day.

        :rtype: list of [Optional[long]]
        """
        if self._active_shared_folders_1_day_present:
            return self._active_shared_folders_1_day_value
        else:
            raise AttributeError("missing required field 'active_shared_folders_1_day'")

    @active_shared_folders_1_day.setter
    def active_shared_folders_1_day(self, val):
        val = self._active_shared_folders_1_day_validator.validate(val)
        self._active_shared_folders_1_day_value = val
        self._active_shared_folders_1_day_present = True

    @active_shared_folders_1_day.deleter
    def active_shared_folders_1_day(self):
        self._active_shared_folders_1_day_value = None
        self._active_shared_folders_1_day_present = False

    @property
    def shared_links_created(self):
        """
        Array of the number of shared links created.

        :rtype: list of [Optional[long]]
        """
        if self._shared_links_created_present:
            return self._shared_links_created_value
        else:
            raise AttributeError("missing required field 'shared_links_created'")

    @shared_links_created.setter
    def shared_links_created(self, val):
        val = self._shared_links_created_validator.validate(val)
        self._shared_links_created_value = val
        self._shared_links_created_present = True

    @shared_links_created.deleter
    def shared_links_created(self):
        self._shared_links_created_value = None
        self._shared_links_created_present = False

    @property
    def shared_links_viewed_by_team(self):
        """
        Array of the number of views by team users to shared links created by
        the team.

        :rtype: list of [Optional[long]]
        """
        if self._shared_links_viewed_by_team_present:
            return self._shared_links_viewed_by_team_value
        else:
            raise AttributeError("missing required field 'shared_links_viewed_by_team'")

    @shared_links_viewed_by_team.setter
    def shared_links_viewed_by_team(self, val):
        val = self._shared_links_viewed_by_team_validator.validate(val)
        self._shared_links_viewed_by_team_value = val
        self._shared_links_viewed_by_team_present = True

    @shared_links_viewed_by_team.deleter
    def shared_links_viewed_by_team(self):
        self._shared_links_viewed_by_team_value = None
        self._shared_links_viewed_by_team_present = False

    @property
    def shared_links_viewed_by_outside_user(self):
        """
        Array of the number of views by users outside of the team to shared
        links created by the team.

        :rtype: list of [Optional[long]]
        """
        if self._shared_links_viewed_by_outside_user_present:
            return self._shared_links_viewed_by_outside_user_value
        else:
            raise AttributeError("missing required field 'shared_links_viewed_by_outside_user'")

    @shared_links_viewed_by_outside_user.setter
    def shared_links_viewed_by_outside_user(self, val):
        val = self._shared_links_viewed_by_outside_user_validator.validate(val)
        self._shared_links_viewed_by_outside_user_value = val
        self._shared_links_viewed_by_outside_user_present = True

    @shared_links_viewed_by_outside_user.deleter
    def shared_links_viewed_by_outside_user(self):
        self._shared_links_viewed_by_outside_user_value = None
        self._shared_links_viewed_by_outside_user_present = False

    @property
    def shared_links_viewed_by_not_logged_in(self):
        """
        Array of the number of views by non-logged-in users to shared links
        created by the team.

        :rtype: list of [Optional[long]]
        """
        if self._shared_links_viewed_by_not_logged_in_present:
            return self._shared_links_viewed_by_not_logged_in_value
        else:
            raise AttributeError("missing required field 'shared_links_viewed_by_not_logged_in'")

    @shared_links_viewed_by_not_logged_in.setter
    def shared_links_viewed_by_not_logged_in(self, val):
        val = self._shared_links_viewed_by_not_logged_in_validator.validate(val)
        self._shared_links_viewed_by_not_logged_in_value = val
        self._shared_links_viewed_by_not_logged_in_present = True

    @shared_links_viewed_by_not_logged_in.deleter
    def shared_links_viewed_by_not_logged_in(self):
        self._shared_links_viewed_by_not_logged_in_value = None
        self._shared_links_viewed_by_not_logged_in_present = False

    @property
    def shared_links_viewed_total(self):
        """
        Array of the total number of views to shared links created by the team.

        :rtype: list of [Optional[long]]
        """
        if self._shared_links_viewed_total_present:
            return self._shared_links_viewed_total_value
        else:
            raise AttributeError("missing required field 'shared_links_viewed_total'")

    @shared_links_viewed_total.setter
    def shared_links_viewed_total(self, val):
        val = self._shared_links_viewed_total_validator.validate(val)
        self._shared_links_viewed_total_value = val
        self._shared_links_viewed_total_present = True

    @shared_links_viewed_total.deleter
    def shared_links_viewed_total(self):
        self._shared_links_viewed_total_value = None
        self._shared_links_viewed_total_present = False

    def __repr__(self):
        return 'GetActivityReport(start_date={!r}, adds={!r}, edits={!r}, deletes={!r}, active_users_28_day={!r}, active_users_7_day={!r}, active_users_1_day={!r}, active_shared_folders_28_day={!r}, active_shared_folders_7_day={!r}, active_shared_folders_1_day={!r}, shared_links_created={!r}, shared_links_viewed_by_team={!r}, shared_links_viewed_by_outside_user={!r}, shared_links_viewed_by_not_logged_in={!r}, shared_links_viewed_total={!r})'.format(
            self._start_date_value,
            self._adds_value,
            self._edits_value,
            self._deletes_value,
            self._active_users_28_day_value,
            self._active_users_7_day_value,
            self._active_users_1_day_value,
            self._active_shared_folders_28_day_value,
            self._active_shared_folders_7_day_value,
            self._active_shared_folders_1_day_value,
            self._shared_links_created_value,
            self._shared_links_viewed_by_team_value,
            self._shared_links_viewed_by_outside_user_value,
            self._shared_links_viewed_by_not_logged_in_value,
            self._shared_links_viewed_total_value,
        )

class GetMembershipReport(BaseDfbReport):
    """
    Membership Report Result. Each of the items in the storage report is an
    array of values, one value per day. If there is no data for a day, then the
    value will be None.

    :ivar team_size: Team size, for each day.
    :ivar pending_invites: The number of pending invites to the team, for each
        day.
    :ivar members_joined: The number of members that joined the team, for each
        day.
    :ivar suspended_members: The number of members that joined the team, for
        each day.
    :ivar licenses: The total number of licenses the team has, for each day.
    """

    __slots__ = [
        '_team_size_value',
        '_team_size_present',
        '_pending_invites_value',
        '_pending_invites_present',
        '_members_joined_value',
        '_members_joined_present',
        '_suspended_members_value',
        '_suspended_members_present',
        '_licenses_value',
        '_licenses_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 start_date=None,
                 team_size=None,
                 pending_invites=None,
                 members_joined=None,
                 suspended_members=None,
                 licenses=None):
        super(GetMembershipReport, self).__init__(start_date)
        self._team_size_value = None
        self._team_size_present = False
        self._pending_invites_value = None
        self._pending_invites_present = False
        self._members_joined_value = None
        self._members_joined_present = False
        self._suspended_members_value = None
        self._suspended_members_present = False
        self._licenses_value = None
        self._licenses_present = False
        if team_size is not None:
            self.team_size = team_size
        if pending_invites is not None:
            self.pending_invites = pending_invites
        if members_joined is not None:
            self.members_joined = members_joined
        if suspended_members is not None:
            self.suspended_members = suspended_members
        if licenses is not None:
            self.licenses = licenses

    @property
    def team_size(self):
        """
        Team size, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._team_size_present:
            return self._team_size_value
        else:
            raise AttributeError("missing required field 'team_size'")

    @team_size.setter
    def team_size(self, val):
        val = self._team_size_validator.validate(val)
        self._team_size_value = val
        self._team_size_present = True

    @team_size.deleter
    def team_size(self):
        self._team_size_value = None
        self._team_size_present = False

    @property
    def pending_invites(self):
        """
        The number of pending invites to the team, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._pending_invites_present:
            return self._pending_invites_value
        else:
            raise AttributeError("missing required field 'pending_invites'")

    @pending_invites.setter
    def pending_invites(self, val):
        val = self._pending_invites_validator.validate(val)
        self._pending_invites_value = val
        self._pending_invites_present = True

    @pending_invites.deleter
    def pending_invites(self):
        self._pending_invites_value = None
        self._pending_invites_present = False

    @property
    def members_joined(self):
        """
        The number of members that joined the team, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._members_joined_present:
            return self._members_joined_value
        else:
            raise AttributeError("missing required field 'members_joined'")

    @members_joined.setter
    def members_joined(self, val):
        val = self._members_joined_validator.validate(val)
        self._members_joined_value = val
        self._members_joined_present = True

    @members_joined.deleter
    def members_joined(self):
        self._members_joined_value = None
        self._members_joined_present = False

    @property
    def suspended_members(self):
        """
        The number of members that joined the team, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._suspended_members_present:
            return self._suspended_members_value
        else:
            raise AttributeError("missing required field 'suspended_members'")

    @suspended_members.setter
    def suspended_members(self, val):
        val = self._suspended_members_validator.validate(val)
        self._suspended_members_value = val
        self._suspended_members_present = True

    @suspended_members.deleter
    def suspended_members(self):
        self._suspended_members_value = None
        self._suspended_members_present = False

    @property
    def licenses(self):
        """
        The total number of licenses the team has, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._licenses_present:
            return self._licenses_value
        else:
            raise AttributeError("missing required field 'licenses'")

    @licenses.setter
    def licenses(self, val):
        val = self._licenses_validator.validate(val)
        self._licenses_value = val
        self._licenses_present = True

    @licenses.deleter
    def licenses(self):
        self._licenses_value = None
        self._licenses_present = False

    def __repr__(self):
        return 'GetMembershipReport(start_date={!r}, team_size={!r}, pending_invites={!r}, members_joined={!r}, suspended_members={!r}, licenses={!r})'.format(
            self._start_date_value,
            self._team_size_value,
            self._pending_invites_value,
            self._members_joined_value,
            self._suspended_members_value,
            self._licenses_value,
        )

class DevicesActive(object):
    """
    Each of the items is an array of values, one value per day. The value is the
    number of devices active within a time window, ending with that day. If
    there is no data for a day, then the value will be None.

    :ivar windows: Array of number of linked windows (desktop) clients with
        activity.
    :ivar macos: Array of number of linked mac (desktop) clients with activity.
    :ivar linux: Array of number of linked linus (desktop) clients with
        activity.
    :ivar ios: Array of number of linked ios devices with activity.
    :ivar android: Array of number of linked android devices with activity.
    :ivar other: Array of number of other linked devices (blackberry, windows
        phone, etc)  with activity.
    :ivar total: Array of total number of linked clients with activity.
    """

    __slots__ = [
        '_windows_value',
        '_windows_present',
        '_macos_value',
        '_macos_present',
        '_linux_value',
        '_linux_present',
        '_ios_value',
        '_ios_present',
        '_android_value',
        '_android_present',
        '_other_value',
        '_other_present',
        '_total_value',
        '_total_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 windows=None,
                 macos=None,
                 linux=None,
                 ios=None,
                 android=None,
                 other=None,
                 total=None):
        self._windows_value = None
        self._windows_present = False
        self._macos_value = None
        self._macos_present = False
        self._linux_value = None
        self._linux_present = False
        self._ios_value = None
        self._ios_present = False
        self._android_value = None
        self._android_present = False
        self._other_value = None
        self._other_present = False
        self._total_value = None
        self._total_present = False
        if windows is not None:
            self.windows = windows
        if macos is not None:
            self.macos = macos
        if linux is not None:
            self.linux = linux
        if ios is not None:
            self.ios = ios
        if android is not None:
            self.android = android
        if other is not None:
            self.other = other
        if total is not None:
            self.total = total

    @property
    def windows(self):
        """
        Array of number of linked windows (desktop) clients with activity.

        :rtype: list of [Optional[long]]
        """
        if self._windows_present:
            return self._windows_value
        else:
            raise AttributeError("missing required field 'windows'")

    @windows.setter
    def windows(self, val):
        val = self._windows_validator.validate(val)
        self._windows_value = val
        self._windows_present = True

    @windows.deleter
    def windows(self):
        self._windows_value = None
        self._windows_present = False

    @property
    def macos(self):
        """
        Array of number of linked mac (desktop) clients with activity.

        :rtype: list of [Optional[long]]
        """
        if self._macos_present:
            return self._macos_value
        else:
            raise AttributeError("missing required field 'macos'")

    @macos.setter
    def macos(self, val):
        val = self._macos_validator.validate(val)
        self._macos_value = val
        self._macos_present = True

    @macos.deleter
    def macos(self):
        self._macos_value = None
        self._macos_present = False

    @property
    def linux(self):
        """
        Array of number of linked linus (desktop) clients with activity.

        :rtype: list of [Optional[long]]
        """
        if self._linux_present:
            return self._linux_value
        else:
            raise AttributeError("missing required field 'linux'")

    @linux.setter
    def linux(self, val):
        val = self._linux_validator.validate(val)
        self._linux_value = val
        self._linux_present = True

    @linux.deleter
    def linux(self):
        self._linux_value = None
        self._linux_present = False

    @property
    def ios(self):
        """
        Array of number of linked ios devices with activity.

        :rtype: list of [Optional[long]]
        """
        if self._ios_present:
            return self._ios_value
        else:
            raise AttributeError("missing required field 'ios'")

    @ios.setter
    def ios(self, val):
        val = self._ios_validator.validate(val)
        self._ios_value = val
        self._ios_present = True

    @ios.deleter
    def ios(self):
        self._ios_value = None
        self._ios_present = False

    @property
    def android(self):
        """
        Array of number of linked android devices with activity.

        :rtype: list of [Optional[long]]
        """
        if self._android_present:
            return self._android_value
        else:
            raise AttributeError("missing required field 'android'")

    @android.setter
    def android(self, val):
        val = self._android_validator.validate(val)
        self._android_value = val
        self._android_present = True

    @android.deleter
    def android(self):
        self._android_value = None
        self._android_present = False

    @property
    def other(self):
        """
        Array of number of other linked devices (blackberry, windows phone, etc)
        with activity.

        :rtype: list of [Optional[long]]
        """
        if self._other_present:
            return self._other_value
        else:
            raise AttributeError("missing required field 'other'")

    @other.setter
    def other(self, val):
        val = self._other_validator.validate(val)
        self._other_value = val
        self._other_present = True

    @other.deleter
    def other(self):
        self._other_value = None
        self._other_present = False

    @property
    def total(self):
        """
        Array of total number of linked clients with activity.

        :rtype: list of [Optional[long]]
        """
        if self._total_present:
            return self._total_value
        else:
            raise AttributeError("missing required field 'total'")

    @total.setter
    def total(self, val):
        val = self._total_validator.validate(val)
        self._total_value = val
        self._total_present = True

    @total.deleter
    def total(self):
        self._total_value = None
        self._total_present = False

    def __repr__(self):
        return 'DevicesActive(windows={!r}, macos={!r}, linux={!r}, ios={!r}, android={!r}, other={!r}, total={!r})'.format(
            self._windows_value,
            self._macos_value,
            self._linux_value,
            self._ios_value,
            self._android_value,
            self._other_value,
            self._total_value,
        )

class GetDevicesReport(BaseDfbReport):
    """
    Devices Report Result. Contains subsections for different time ranges of
    activity. Each of the items in each subsection of the storage report is an
    array of values, one value per day. If there is no data for a day, then the
    value will be None.

    :ivar active_1_day: Report of the number of devices active in the last day.
    :ivar active_7_day: Report of the number of devices active in the last 7
        days.
    :ivar active_28_day: Report of the number of devices active in the last 28
        days.
    """

    __slots__ = [
        '_active_1_day_value',
        '_active_1_day_present',
        '_active_7_day_value',
        '_active_7_day_present',
        '_active_28_day_value',
        '_active_28_day_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 start_date=None,
                 active_1_day=None,
                 active_7_day=None,
                 active_28_day=None):
        super(GetDevicesReport, self).__init__(start_date)
        self._active_1_day_value = None
        self._active_1_day_present = False
        self._active_7_day_value = None
        self._active_7_day_present = False
        self._active_28_day_value = None
        self._active_28_day_present = False
        if active_1_day is not None:
            self.active_1_day = active_1_day
        if active_7_day is not None:
            self.active_7_day = active_7_day
        if active_28_day is not None:
            self.active_28_day = active_28_day

    @property
    def active_1_day(self):
        """
        Report of the number of devices active in the last day.

        :rtype: DevicesActive
        """
        if self._active_1_day_present:
            return self._active_1_day_value
        else:
            raise AttributeError("missing required field 'active_1_day'")

    @active_1_day.setter
    def active_1_day(self, val):
        self._active_1_day_validator.validate_type_only(val)
        self._active_1_day_value = val
        self._active_1_day_present = True

    @active_1_day.deleter
    def active_1_day(self):
        self._active_1_day_value = None
        self._active_1_day_present = False

    @property
    def active_7_day(self):
        """
        Report of the number of devices active in the last 7 days.

        :rtype: DevicesActive
        """
        if self._active_7_day_present:
            return self._active_7_day_value
        else:
            raise AttributeError("missing required field 'active_7_day'")

    @active_7_day.setter
    def active_7_day(self, val):
        self._active_7_day_validator.validate_type_only(val)
        self._active_7_day_value = val
        self._active_7_day_present = True

    @active_7_day.deleter
    def active_7_day(self):
        self._active_7_day_value = None
        self._active_7_day_present = False

    @property
    def active_28_day(self):
        """
        Report of the number of devices active in the last 28 days.

        :rtype: DevicesActive
        """
        if self._active_28_day_present:
            return self._active_28_day_value
        else:
            raise AttributeError("missing required field 'active_28_day'")

    @active_28_day.setter
    def active_28_day(self, val):
        self._active_28_day_validator.validate_type_only(val)
        self._active_28_day_value = val
        self._active_28_day_present = True

    @active_28_day.deleter
    def active_28_day(self):
        self._active_28_day_value = None
        self._active_28_day_present = False

    def __repr__(self):
        return 'GetDevicesReport(start_date={!r}, active_1_day={!r}, active_7_day={!r}, active_28_day={!r})'.format(
            self._start_date_value,
            self._active_1_day_value,
            self._active_7_day_value,
            self._active_28_day_value,
        )

MemberProfile._member_id_validator = bv.String()
MemberProfile._account_id_validator = bv.String(min_length=40, max_length=40)
MemberProfile._external_id_validator = bv.Nullable(bv.String())
MemberProfile._email_validator = bv.String()
MemberProfile._email_verified_validator = bv.Boolean()
MemberProfile._name_validator = bv.Struct(users.Name)
MemberProfile._all_field_names_ = set([
    'member_id',
    'account_id',
    'external_id',
    'email',
    'email_verified',
    'name',
])
MemberProfile._all_fields_ = [
    ('member_id', MemberProfile._member_id_validator),
    ('account_id', MemberProfile._account_id_validator),
    ('external_id', MemberProfile._external_id_validator),
    ('email', MemberProfile._email_validator),
    ('email_verified', MemberProfile._email_verified_validator),
    ('name', MemberProfile._name_validator),
]

UserSelectorArg._member_id_validator = bv.String()
UserSelectorArg._external_id_validator = bv.String()
UserSelectorArg._email_validator = bv.String()
UserSelectorArg._tagmap = {
    'member_id': UserSelectorArg._member_id_validator,
    'external_id': UserSelectorArg._external_id_validator,
    'email': UserSelectorArg._email_validator,
}

UserSelectorError._user_not_found_validator = bv.Void()
UserSelectorError._tagmap = {
    'user_not_found': UserSelectorError._user_not_found_validator,
}

UserSelectorError.user_not_found = UserSelectorError('user_not_found')

UsersSelectorArg._member_ids_validator = bv.List(bv.String())
UsersSelectorArg._external_ids_validator = bv.List(bv.String())
UsersSelectorArg._emails_validator = bv.List(bv.String())
UsersSelectorArg._tagmap = {
    'member_ids': UsersSelectorArg._member_ids_validator,
    'external_ids': UsersSelectorArg._external_ids_validator,
    'emails': UsersSelectorArg._emails_validator,
}

TeamGetInfoResult._name_validator = bv.String()
TeamGetInfoResult._team_id_validator = bv.String()
TeamGetInfoResult._num_licensed_users_validator = bv.UInt32()
TeamGetInfoResult._num_provisioned_users_validator = bv.UInt32()
TeamGetInfoResult._all_field_names_ = set([
    'name',
    'team_id',
    'num_licensed_users',
    'num_provisioned_users',
])
TeamGetInfoResult._all_fields_ = [
    ('name', TeamGetInfoResult._name_validator),
    ('team_id', TeamGetInfoResult._team_id_validator),
    ('num_licensed_users', TeamGetInfoResult._num_licensed_users_validator),
    ('num_provisioned_users', TeamGetInfoResult._num_provisioned_users_validator),
]

ListMemberDevicesArg._member_id_validator = bv.String()
ListMemberDevicesArg._include_web_sessions_validator = bv.Boolean()
ListMemberDevicesArg._include_desktop_clients_validator = bv.Boolean()
ListMemberDevicesArg._include_mobile_clients_validator = bv.Boolean()
ListMemberDevicesArg._all_field_names_ = set([
    'member_id',
    'include_web_sessions',
    'include_desktop_clients',
    'include_mobile_clients',
])
ListMemberDevicesArg._all_fields_ = [
    ('member_id', ListMemberDevicesArg._member_id_validator),
    ('include_web_sessions', ListMemberDevicesArg._include_web_sessions_validator),
    ('include_desktop_clients', ListMemberDevicesArg._include_desktop_clients_validator),
    ('include_mobile_clients', ListMemberDevicesArg._include_mobile_clients_validator),
]

DeviceSession._session_id_validator = bv.String()
DeviceSession._ip_address_validator = bv.Nullable(bv.String())
DeviceSession._country_validator = bv.Nullable(bv.String())
DeviceSession._created_validator = bv.Nullable(bv.Timestamp(u'%Y-%m-%dT%H:%M:%SZ'))
DeviceSession._updated_validator = bv.Nullable(bv.Timestamp(u'%Y-%m-%dT%H:%M:%SZ'))
DeviceSession._all_field_names_ = set([
    'session_id',
    'ip_address',
    'country',
    'created',
    'updated',
])
DeviceSession._all_fields_ = [
    ('session_id', DeviceSession._session_id_validator),
    ('ip_address', DeviceSession._ip_address_validator),
    ('country', DeviceSession._country_validator),
    ('created', DeviceSession._created_validator),
    ('updated', DeviceSession._updated_validator),
]

ActiveWebSession._user_agent_validator = bv.String()
ActiveWebSession._os_validator = bv.String()
ActiveWebSession._browser_validator = bv.String()
ActiveWebSession._all_field_names_ = DeviceSession._all_field_names_.union(set([
    'user_agent',
    'os',
    'browser',
]))
ActiveWebSession._all_fields_ = DeviceSession._all_fields_ + [
    ('user_agent', ActiveWebSession._user_agent_validator),
    ('os', ActiveWebSession._os_validator),
    ('browser', ActiveWebSession._browser_validator),
]

DesktopPlatform._windows_validator = bv.Void()
DesktopPlatform._mac_validator = bv.Void()
DesktopPlatform._linux_validator = bv.Void()
DesktopPlatform._other_validator = bv.Void()
DesktopPlatform._tagmap = {
    'windows': DesktopPlatform._windows_validator,
    'mac': DesktopPlatform._mac_validator,
    'linux': DesktopPlatform._linux_validator,
    'other': DesktopPlatform._other_validator,
}

DesktopPlatform.windows = DesktopPlatform('windows')
DesktopPlatform.mac = DesktopPlatform('mac')
DesktopPlatform.linux = DesktopPlatform('linux')
DesktopPlatform.other = DesktopPlatform('other')

DesktopClientSession._host_name_validator = bv.String()
DesktopClientSession._client_type_validator = bv.Union(DesktopPlatform)
DesktopClientSession._client_version_validator = bv.String()
DesktopClientSession._platform_validator = bv.String()
DesktopClientSession._is_delete_on_unlink_supported_validator = bv.Boolean()
DesktopClientSession._all_field_names_ = DeviceSession._all_field_names_.union(set([
    'host_name',
    'client_type',
    'client_version',
    'platform',
    'is_delete_on_unlink_supported',
]))
DesktopClientSession._all_fields_ = DeviceSession._all_fields_ + [
    ('host_name', DesktopClientSession._host_name_validator),
    ('client_type', DesktopClientSession._client_type_validator),
    ('client_version', DesktopClientSession._client_version_validator),
    ('platform', DesktopClientSession._platform_validator),
    ('is_delete_on_unlink_supported', DesktopClientSession._is_delete_on_unlink_supported_validator),
]

MobileClientPlatform._iphone_validator = bv.Void()
MobileClientPlatform._ipad_validator = bv.Void()
MobileClientPlatform._android_validator = bv.Void()
MobileClientPlatform._windows_phone_validator = bv.Void()
MobileClientPlatform._blackberry_validator = bv.Void()
MobileClientPlatform._other_validator = bv.Void()
MobileClientPlatform._tagmap = {
    'iphone': MobileClientPlatform._iphone_validator,
    'ipad': MobileClientPlatform._ipad_validator,
    'android': MobileClientPlatform._android_validator,
    'windows_phone': MobileClientPlatform._windows_phone_validator,
    'blackberry': MobileClientPlatform._blackberry_validator,
    'other': MobileClientPlatform._other_validator,
}

MobileClientPlatform.iphone = MobileClientPlatform('iphone')
MobileClientPlatform.ipad = MobileClientPlatform('ipad')
MobileClientPlatform.android = MobileClientPlatform('android')
MobileClientPlatform.windows_phone = MobileClientPlatform('windows_phone')
MobileClientPlatform.blackberry = MobileClientPlatform('blackberry')
MobileClientPlatform.other = MobileClientPlatform('other')

MobileClientSession._device_name_validator = bv.String()
MobileClientSession._client_type_validator = bv.Union(MobileClientPlatform)
MobileClientSession._client_version_validator = bv.Nullable(bv.String())
MobileClientSession._os_version_validator = bv.Nullable(bv.String())
MobileClientSession._last_carrier_validator = bv.Nullable(bv.String())
MobileClientSession._all_field_names_ = DeviceSession._all_field_names_.union(set([
    'device_name',
    'client_type',
    'client_version',
    'os_version',
    'last_carrier',
]))
MobileClientSession._all_fields_ = DeviceSession._all_fields_ + [
    ('device_name', MobileClientSession._device_name_validator),
    ('client_type', MobileClientSession._client_type_validator),
    ('client_version', MobileClientSession._client_version_validator),
    ('os_version', MobileClientSession._os_version_validator),
    ('last_carrier', MobileClientSession._last_carrier_validator),
]

ListMemberDevicesResult._active_web_sessions_validator = bv.Nullable(bv.List(bv.Struct(ActiveWebSession)))
ListMemberDevicesResult._desktop_client_sessions_validator = bv.Nullable(bv.List(bv.Struct(DesktopClientSession)))
ListMemberDevicesResult._mobile_client_sessions_validator = bv.Nullable(bv.List(bv.Struct(MobileClientSession)))
ListMemberDevicesResult._all_field_names_ = set([
    'active_web_sessions',
    'desktop_client_sessions',
    'mobile_client_sessions',
])
ListMemberDevicesResult._all_fields_ = [
    ('active_web_sessions', ListMemberDevicesResult._active_web_sessions_validator),
    ('desktop_client_sessions', ListMemberDevicesResult._desktop_client_sessions_validator),
    ('mobile_client_sessions', ListMemberDevicesResult._mobile_client_sessions_validator),
]

ListMemberDevicesError._member_not_found_validator = bv.Void()
ListMemberDevicesError._other_validator = bv.Void()
ListMemberDevicesError._tagmap = {
    'member_not_found': ListMemberDevicesError._member_not_found_validator,
    'other': ListMemberDevicesError._other_validator,
}

ListMemberDevicesError.member_not_found = ListMemberDevicesError('member_not_found')
ListMemberDevicesError.other = ListMemberDevicesError('other')

ListTeamDevicesArg._cursor_validator = bv.Nullable(bv.String())
ListTeamDevicesArg._include_web_sessions_validator = bv.Boolean()
ListTeamDevicesArg._include_desktop_clients_validator = bv.Boolean()
ListTeamDevicesArg._include_mobile_clients_validator = bv.Boolean()
ListTeamDevicesArg._all_field_names_ = set([
    'cursor',
    'include_web_sessions',
    'include_desktop_clients',
    'include_mobile_clients',
])
ListTeamDevicesArg._all_fields_ = [
    ('cursor', ListTeamDevicesArg._cursor_validator),
    ('include_web_sessions', ListTeamDevicesArg._include_web_sessions_validator),
    ('include_desktop_clients', ListTeamDevicesArg._include_desktop_clients_validator),
    ('include_mobile_clients', ListTeamDevicesArg._include_mobile_clients_validator),
]

MemberDevices._member_id_validator = bv.String()
MemberDevices._web_sessions_validator = bv.Nullable(bv.List(bv.Struct(ActiveWebSession)))
MemberDevices._desktop_clients_validator = bv.Nullable(bv.List(bv.Struct(DesktopClientSession)))
MemberDevices._mobile_clients_validator = bv.Nullable(bv.List(bv.Struct(MobileClientSession)))
MemberDevices._all_field_names_ = set([
    'member_id',
    'web_sessions',
    'desktop_clients',
    'mobile_clients',
])
MemberDevices._all_fields_ = [
    ('member_id', MemberDevices._member_id_validator),
    ('web_sessions', MemberDevices._web_sessions_validator),
    ('desktop_clients', MemberDevices._desktop_clients_validator),
    ('mobile_clients', MemberDevices._mobile_clients_validator),
]

ListTeamDevicesResult._devices_validator = bv.List(bv.Struct(MemberDevices))
ListTeamDevicesResult._has_more_validator = bv.Boolean()
ListTeamDevicesResult._cursor_validator = bv.Nullable(bv.String())
ListTeamDevicesResult._all_field_names_ = set([
    'devices',
    'has_more',
    'cursor',
])
ListTeamDevicesResult._all_fields_ = [
    ('devices', ListTeamDevicesResult._devices_validator),
    ('has_more', ListTeamDevicesResult._has_more_validator),
    ('cursor', ListTeamDevicesResult._cursor_validator),
]

ListTeamDevicesError._reset_validator = bv.Void()
ListTeamDevicesError._other_validator = bv.Void()
ListTeamDevicesError._tagmap = {
    'reset': ListTeamDevicesError._reset_validator,
    'other': ListTeamDevicesError._other_validator,
}

ListTeamDevicesError.reset = ListTeamDevicesError('reset')
ListTeamDevicesError.other = ListTeamDevicesError('other')

DeviceSessionArg._session_id_validator = bv.String()
DeviceSessionArg._member_id_validator = bv.String()
DeviceSessionArg._all_field_names_ = set([
    'session_id',
    'member_id',
])
DeviceSessionArg._all_fields_ = [
    ('session_id', DeviceSessionArg._session_id_validator),
    ('member_id', DeviceSessionArg._member_id_validator),
]

RevokeDesktopClientArg._delete_on_unlink_validator = bv.Boolean()
RevokeDesktopClientArg._all_field_names_ = DeviceSessionArg._all_field_names_.union(set(['delete_on_unlink']))
RevokeDesktopClientArg._all_fields_ = DeviceSessionArg._all_fields_ + [('delete_on_unlink', RevokeDesktopClientArg._delete_on_unlink_validator)]

RevokeDeviceSessionArg._web_session_validator = bv.Struct(DeviceSessionArg)
RevokeDeviceSessionArg._desktop_client_validator = bv.Struct(RevokeDesktopClientArg)
RevokeDeviceSessionArg._mobile_client_validator = bv.Struct(DeviceSessionArg)
RevokeDeviceSessionArg._tagmap = {
    'web_session': RevokeDeviceSessionArg._web_session_validator,
    'desktop_client': RevokeDeviceSessionArg._desktop_client_validator,
    'mobile_client': RevokeDeviceSessionArg._mobile_client_validator,
}

RevokeDeviceSessionError._device_session_not_found_validator = bv.Void()
RevokeDeviceSessionError._member_not_found_validator = bv.Void()
RevokeDeviceSessionError._other_validator = bv.Void()
RevokeDeviceSessionError._tagmap = {
    'device_session_not_found': RevokeDeviceSessionError._device_session_not_found_validator,
    'member_not_found': RevokeDeviceSessionError._member_not_found_validator,
    'other': RevokeDeviceSessionError._other_validator,
}

RevokeDeviceSessionError.device_session_not_found = RevokeDeviceSessionError('device_session_not_found')
RevokeDeviceSessionError.member_not_found = RevokeDeviceSessionError('member_not_found')
RevokeDeviceSessionError.other = RevokeDeviceSessionError('other')

RevokeDeviceSessionBatchArg._revoke_devices_validator = bv.List(bv.Union(RevokeDeviceSessionArg))
RevokeDeviceSessionBatchArg._all_field_names_ = set(['revoke_devices'])
RevokeDeviceSessionBatchArg._all_fields_ = [('revoke_devices', RevokeDeviceSessionBatchArg._revoke_devices_validator)]

RevokeDeviceSessionStatus._success_validator = bv.Boolean()
RevokeDeviceSessionStatus._error_type_validator = bv.Nullable(bv.Union(RevokeDeviceSessionError))
RevokeDeviceSessionStatus._all_field_names_ = set([
    'success',
    'error_type',
])
RevokeDeviceSessionStatus._all_fields_ = [
    ('success', RevokeDeviceSessionStatus._success_validator),
    ('error_type', RevokeDeviceSessionStatus._error_type_validator),
]

RevokeDeviceSessionBatchResult._revoke_devices_status_validator = bv.List(bv.Struct(RevokeDeviceSessionStatus))
RevokeDeviceSessionBatchResult._all_field_names_ = set(['revoke_devices_status'])
RevokeDeviceSessionBatchResult._all_fields_ = [('revoke_devices_status', RevokeDeviceSessionBatchResult._revoke_devices_status_validator)]

RevokeDeviceSessionBatchError._unspecified_validator = bv.Void()
RevokeDeviceSessionBatchError._tagmap = {
    'unspecified': RevokeDeviceSessionBatchError._unspecified_validator,
}

RevokeDeviceSessionBatchError.unspecified = RevokeDeviceSessionBatchError('unspecified')

ListMemberAppsArg._member_id_validator = bv.String()
ListMemberAppsArg._all_field_names_ = set(['member_id'])
ListMemberAppsArg._all_fields_ = [('member_id', ListMemberAppsArg._member_id_validator)]

ApiApp._app_id_validator = bv.String()
ApiApp._app_name_validator = bv.String()
ApiApp._publisher_validator = bv.Nullable(bv.String())
ApiApp._publisher_url_validator = bv.Nullable(bv.String())
ApiApp._linked_validator = bv.Nullable(bv.Timestamp(u'%Y-%m-%dT%H:%M:%SZ'))
ApiApp._is_app_folder_validator = bv.Boolean()
ApiApp._all_field_names_ = set([
    'app_id',
    'app_name',
    'publisher',
    'publisher_url',
    'linked',
    'is_app_folder',
])
ApiApp._all_fields_ = [
    ('app_id', ApiApp._app_id_validator),
    ('app_name', ApiApp._app_name_validator),
    ('publisher', ApiApp._publisher_validator),
    ('publisher_url', ApiApp._publisher_url_validator),
    ('linked', ApiApp._linked_validator),
    ('is_app_folder', ApiApp._is_app_folder_validator),
]

ListMemberAppsResult._linked_api_apps_validator = bv.List(bv.Struct(ApiApp))
ListMemberAppsResult._all_field_names_ = set(['linked_api_apps'])
ListMemberAppsResult._all_fields_ = [('linked_api_apps', ListMemberAppsResult._linked_api_apps_validator)]

ListMemberAppsError._member_not_found_validator = bv.Void()
ListMemberAppsError._other_validator = bv.Void()
ListMemberAppsError._tagmap = {
    'member_not_found': ListMemberAppsError._member_not_found_validator,
    'other': ListMemberAppsError._other_validator,
}

ListMemberAppsError.member_not_found = ListMemberAppsError('member_not_found')
ListMemberAppsError.other = ListMemberAppsError('other')

ListTeamAppsArg._cursor_validator = bv.Nullable(bv.String())
ListTeamAppsArg._all_field_names_ = set(['cursor'])
ListTeamAppsArg._all_fields_ = [('cursor', ListTeamAppsArg._cursor_validator)]

MemberLinkedApps._member_id_validator = bv.String()
MemberLinkedApps._linked_api_apps_validator = bv.List(bv.Struct(ApiApp))
MemberLinkedApps._all_field_names_ = set([
    'member_id',
    'linked_api_apps',
])
MemberLinkedApps._all_fields_ = [
    ('member_id', MemberLinkedApps._member_id_validator),
    ('linked_api_apps', MemberLinkedApps._linked_api_apps_validator),
]

ListTeamAppsResult._apps_validator = bv.List(bv.Struct(MemberLinkedApps))
ListTeamAppsResult._has_more_validator = bv.Boolean()
ListTeamAppsResult._cursor_validator = bv.Nullable(bv.String())
ListTeamAppsResult._all_field_names_ = set([
    'apps',
    'has_more',
    'cursor',
])
ListTeamAppsResult._all_fields_ = [
    ('apps', ListTeamAppsResult._apps_validator),
    ('has_more', ListTeamAppsResult._has_more_validator),
    ('cursor', ListTeamAppsResult._cursor_validator),
]

ListTeamAppsError._reset_validator = bv.Void()
ListTeamAppsError._other_validator = bv.Void()
ListTeamAppsError._tagmap = {
    'reset': ListTeamAppsError._reset_validator,
    'other': ListTeamAppsError._other_validator,
}

ListTeamAppsError.reset = ListTeamAppsError('reset')
ListTeamAppsError.other = ListTeamAppsError('other')

RevokeLinkedApiAppArg._app_id_validator = bv.String()
RevokeLinkedApiAppArg._member_id_validator = bv.String()
RevokeLinkedApiAppArg._keep_app_folder_validator = bv.Boolean()
RevokeLinkedApiAppArg._all_field_names_ = set([
    'app_id',
    'member_id',
    'keep_app_folder',
])
RevokeLinkedApiAppArg._all_fields_ = [
    ('app_id', RevokeLinkedApiAppArg._app_id_validator),
    ('member_id', RevokeLinkedApiAppArg._member_id_validator),
    ('keep_app_folder', RevokeLinkedApiAppArg._keep_app_folder_validator),
]

RevokeLinkedAppError._app_not_found_validator = bv.Void()
RevokeLinkedAppError._member_not_found_validator = bv.Void()
RevokeLinkedAppError._other_validator = bv.Void()
RevokeLinkedAppError._tagmap = {
    'app_not_found': RevokeLinkedAppError._app_not_found_validator,
    'member_not_found': RevokeLinkedAppError._member_not_found_validator,
    'other': RevokeLinkedAppError._other_validator,
}

RevokeLinkedAppError.app_not_found = RevokeLinkedAppError('app_not_found')
RevokeLinkedAppError.member_not_found = RevokeLinkedAppError('member_not_found')
RevokeLinkedAppError.other = RevokeLinkedAppError('other')

RevokeLinkedApiAppBatchArg._revoke_linked_app_validator = bv.List(bv.Struct(RevokeLinkedApiAppArg))
RevokeLinkedApiAppBatchArg._all_field_names_ = set(['revoke_linked_app'])
RevokeLinkedApiAppBatchArg._all_fields_ = [('revoke_linked_app', RevokeLinkedApiAppBatchArg._revoke_linked_app_validator)]

RevokeLinkedAppStatus._success_validator = bv.Boolean()
RevokeLinkedAppStatus._error_type_validator = bv.Nullable(bv.Union(RevokeLinkedAppError))
RevokeLinkedAppStatus._all_field_names_ = set([
    'success',
    'error_type',
])
RevokeLinkedAppStatus._all_fields_ = [
    ('success', RevokeLinkedAppStatus._success_validator),
    ('error_type', RevokeLinkedAppStatus._error_type_validator),
]

RevokeLinkedAppBatchResult._revoke_linked_app_status_validator = bv.List(bv.Struct(RevokeLinkedAppStatus))
RevokeLinkedAppBatchResult._all_field_names_ = set(['revoke_linked_app_status'])
RevokeLinkedAppBatchResult._all_fields_ = [('revoke_linked_app_status', RevokeLinkedAppBatchResult._revoke_linked_app_status_validator)]

RevokeLinkedAppBatchError._unspecified_validator = bv.Void()
RevokeLinkedAppBatchError._tagmap = {
    'unspecified': RevokeLinkedAppBatchError._unspecified_validator,
}

RevokeLinkedAppBatchError.unspecified = RevokeLinkedAppBatchError('unspecified')

TeamMemberStatus._active_validator = bv.Void()
TeamMemberStatus._invited_validator = bv.Void()
TeamMemberStatus._suspended_validator = bv.Void()
TeamMemberStatus._tagmap = {
    'active': TeamMemberStatus._active_validator,
    'invited': TeamMemberStatus._invited_validator,
    'suspended': TeamMemberStatus._suspended_validator,
}

TeamMemberStatus.active = TeamMemberStatus('active')
TeamMemberStatus.invited = TeamMemberStatus('invited')
TeamMemberStatus.suspended = TeamMemberStatus('suspended')

AdminTier._team_admin_validator = bv.Void()
AdminTier._user_management_admin_validator = bv.Void()
AdminTier._support_admin_validator = bv.Void()
AdminTier._member_only_validator = bv.Void()
AdminTier._tagmap = {
    'team_admin': AdminTier._team_admin_validator,
    'user_management_admin': AdminTier._user_management_admin_validator,
    'support_admin': AdminTier._support_admin_validator,
    'member_only': AdminTier._member_only_validator,
}

AdminTier.team_admin = AdminTier('team_admin')
AdminTier.user_management_admin = AdminTier('user_management_admin')
AdminTier.support_admin = AdminTier('support_admin')
AdminTier.member_only = AdminTier('member_only')

TeamMemberProfile._status_validator = bv.Union(TeamMemberStatus)
TeamMemberProfile._groups_validator = bv.List(bv.String())
TeamMemberProfile._all_field_names_ = MemberProfile._all_field_names_.union(set([
    'status',
    'groups',
]))
TeamMemberProfile._all_fields_ = MemberProfile._all_fields_ + [
    ('status', TeamMemberProfile._status_validator),
    ('groups', TeamMemberProfile._groups_validator),
]

MembersListArg._limit_validator = bv.UInt32(min_value=1, max_value=1000)
MembersListArg._all_field_names_ = set(['limit'])
MembersListArg._all_fields_ = [('limit', MembersListArg._limit_validator)]

TeamMemberInfo._profile_validator = bv.Struct(TeamMemberProfile)
TeamMemberInfo._role_validator = bv.Union(AdminTier)
TeamMemberInfo._all_field_names_ = set([
    'profile',
    'role',
])
TeamMemberInfo._all_fields_ = [
    ('profile', TeamMemberInfo._profile_validator),
    ('role', TeamMemberInfo._role_validator),
]

MembersListResult._members_validator = bv.List(bv.Struct(TeamMemberInfo))
MembersListResult._cursor_validator = bv.String()
MembersListResult._has_more_validator = bv.Boolean()
MembersListResult._all_field_names_ = set([
    'members',
    'cursor',
    'has_more',
])
MembersListResult._all_fields_ = [
    ('members', MembersListResult._members_validator),
    ('cursor', MembersListResult._cursor_validator),
    ('has_more', MembersListResult._has_more_validator),
]

MembersListError._other_validator = bv.Void()
MembersListError._tagmap = {
    'other': MembersListError._other_validator,
}

MembersListError.other = MembersListError('other')

MembersListContinueArg._cursor_validator = bv.String()
MembersListContinueArg._all_field_names_ = set(['cursor'])
MembersListContinueArg._all_fields_ = [('cursor', MembersListContinueArg._cursor_validator)]

MembersListContinueError._invalid_cursor_validator = bv.Void()
MembersListContinueError._other_validator = bv.Void()
MembersListContinueError._tagmap = {
    'invalid_cursor': MembersListContinueError._invalid_cursor_validator,
    'other': MembersListContinueError._other_validator,
}

MembersListContinueError.invalid_cursor = MembersListContinueError('invalid_cursor')
MembersListContinueError.other = MembersListContinueError('other')

GetInfoError._other_validator = bv.Void()
GetInfoError._tagmap = {
    'other': GetInfoError._other_validator,
}
GetInfoError._tagmap.update(UserSelectorError._tagmap)

GetInfoError.other = GetInfoError('other')

GetInfoBatchItem._id_validator = bv.String()
GetInfoBatchItem._member_info_validator = bv.Nullable(bv.Struct(TeamMemberInfo))
GetInfoBatchItem._all_field_names_ = set([
    'id',
    'member_info',
])
GetInfoBatchItem._all_fields_ = [
    ('id', GetInfoBatchItem._id_validator),
    ('member_info', GetInfoBatchItem._member_info_validator),
]

GetInfoBatchError._other_validator = bv.Void()
GetInfoBatchError._tagmap = {
    'other': GetInfoBatchError._other_validator,
}

GetInfoBatchError.other = GetInfoBatchError('other')

MemberAddArg._member_email_validator = bv.String()
MemberAddArg._member_given_name_validator = bv.String()
MemberAddArg._member_surname_validator = bv.String()
MemberAddArg._member_external_id_validator = bv.Nullable(bv.String())
MemberAddArg._send_welcome_email_validator = bv.Boolean()
MemberAddArg._all_field_names_ = set([
    'member_email',
    'member_given_name',
    'member_surname',
    'member_external_id',
    'send_welcome_email',
])
MemberAddArg._all_fields_ = [
    ('member_email', MemberAddArg._member_email_validator),
    ('member_given_name', MemberAddArg._member_given_name_validator),
    ('member_surname', MemberAddArg._member_surname_validator),
    ('member_external_id', MemberAddArg._member_external_id_validator),
    ('send_welcome_email', MemberAddArg._send_welcome_email_validator),
]

MemberAddError._team_license_limit_validator = bv.Void()
MemberAddError._free_team_member_limit_reached_validator = bv.Void()
MemberAddError._user_already_on_team_validator = bv.Void()
MemberAddError._user_on_another_team_validator = bv.Void()
MemberAddError._user_already_paired_validator = bv.Void()
MemberAddError._user_migration_failed_validator = bv.Void()
MemberAddError._duplicate_external_member_id_validator = bv.Void()
MemberAddError._other_validator = bv.Void()
MemberAddError._tagmap = {
    'team_license_limit': MemberAddError._team_license_limit_validator,
    'free_team_member_limit_reached': MemberAddError._free_team_member_limit_reached_validator,
    'user_already_on_team': MemberAddError._user_already_on_team_validator,
    'user_on_another_team': MemberAddError._user_on_another_team_validator,
    'user_already_paired': MemberAddError._user_already_paired_validator,
    'user_migration_failed': MemberAddError._user_migration_failed_validator,
    'duplicate_external_member_id': MemberAddError._duplicate_external_member_id_validator,
    'other': MemberAddError._other_validator,
}

MemberAddError.team_license_limit = MemberAddError('team_license_limit')
MemberAddError.free_team_member_limit_reached = MemberAddError('free_team_member_limit_reached')
MemberAddError.user_already_on_team = MemberAddError('user_already_on_team')
MemberAddError.user_on_another_team = MemberAddError('user_on_another_team')
MemberAddError.user_already_paired = MemberAddError('user_already_paired')
MemberAddError.user_migration_failed = MemberAddError('user_migration_failed')
MemberAddError.duplicate_external_member_id = MemberAddError('duplicate_external_member_id')
MemberAddError.other = MemberAddError('other')

MembersSetProfileArg._user_validator = bv.Union(UserSelectorArg)
MembersSetProfileArg._new_email_validator = bv.Nullable(bv.String())
MembersSetProfileArg._new_external_id_validator = bv.Nullable(bv.String())
MembersSetProfileArg._new_given_name_validator = bv.Nullable(bv.String())
MembersSetProfileArg._new_surname_validator = bv.Nullable(bv.String())
MembersSetProfileArg._all_field_names_ = set([
    'user',
    'new_email',
    'new_external_id',
    'new_given_name',
    'new_surname',
])
MembersSetProfileArg._all_fields_ = [
    ('user', MembersSetProfileArg._user_validator),
    ('new_email', MembersSetProfileArg._new_email_validator),
    ('new_external_id', MembersSetProfileArg._new_external_id_validator),
    ('new_given_name', MembersSetProfileArg._new_given_name_validator),
    ('new_surname', MembersSetProfileArg._new_surname_validator),
]

MembersSetProfileError._email_reserved_for_other_user_validator = bv.Void()
MembersSetProfileError._external_id_used_by_other_user_validator = bv.Void()
MembersSetProfileError._user_not_active_validator = bv.Void()
MembersSetProfileError._other_validator = bv.Void()
MembersSetProfileError._tagmap = {
    'email_reserved_for_other_user': MembersSetProfileError._email_reserved_for_other_user_validator,
    'external_id_used_by_other_user': MembersSetProfileError._external_id_used_by_other_user_validator,
    'user_not_active': MembersSetProfileError._user_not_active_validator,
    'other': MembersSetProfileError._other_validator,
}
MembersSetProfileError._tagmap.update(UserSelectorError._tagmap)

MembersSetProfileError.email_reserved_for_other_user = MembersSetProfileError('email_reserved_for_other_user')
MembersSetProfileError.external_id_used_by_other_user = MembersSetProfileError('external_id_used_by_other_user')
MembersSetProfileError.user_not_active = MembersSetProfileError('user_not_active')
MembersSetProfileError.other = MembersSetProfileError('other')

MembersSetRoleArg._user_validator = bv.Union(UserSelectorArg)
MembersSetRoleArg._new_role_validator = bv.Union(AdminTier)
MembersSetRoleArg._all_field_names_ = set([
    'user',
    'new_role',
])
MembersSetRoleArg._all_fields_ = [
    ('user', MembersSetRoleArg._user_validator),
    ('new_role', MembersSetRoleArg._new_role_validator),
]

MembersSetRoleResult._member_id_validator = bv.String()
MembersSetRoleResult._role_validator = bv.Union(AdminTier)
MembersSetRoleResult._all_field_names_ = set([
    'member_id',
    'role',
])
MembersSetRoleResult._all_fields_ = [
    ('member_id', MembersSetRoleResult._member_id_validator),
    ('role', MembersSetRoleResult._role_validator),
]

MembersSetRoleError._last_admin_validator = bv.Void()
MembersSetRoleError._other_validator = bv.Void()
MembersSetRoleError._tagmap = {
    'last_admin': MembersSetRoleError._last_admin_validator,
    'other': MembersSetRoleError._other_validator,
}
MembersSetRoleError._tagmap.update(UserSelectorError._tagmap)

MembersSetRoleError.last_admin = MembersSetRoleError('last_admin')
MembersSetRoleError.other = MembersSetRoleError('other')

MembersSendWelcomeError._other_validator = bv.Void()
MembersSendWelcomeError._tagmap = {
    'other': MembersSendWelcomeError._other_validator,
}
MembersSendWelcomeError._tagmap.update(UserSelectorError._tagmap)

MembersSendWelcomeError.other = MembersSendWelcomeError('other')

MembersRemoveArg._user_validator = bv.Union(UserSelectorArg)
MembersRemoveArg._transfer_dest_id_validator = bv.Nullable(bv.Union(UserSelectorArg))
MembersRemoveArg._transfer_admin_id_validator = bv.Nullable(bv.Union(UserSelectorArg))
MembersRemoveArg._wipe_data_validator = bv.Boolean()
MembersRemoveArg._all_field_names_ = set([
    'user',
    'transfer_dest_id',
    'transfer_admin_id',
    'wipe_data',
])
MembersRemoveArg._all_fields_ = [
    ('user', MembersRemoveArg._user_validator),
    ('transfer_dest_id', MembersRemoveArg._transfer_dest_id_validator),
    ('transfer_admin_id', MembersRemoveArg._transfer_admin_id_validator),
    ('wipe_data', MembersRemoveArg._wipe_data_validator),
]

MembersRemoveError._other_validator = bv.Void()
MembersRemoveError._tagmap = {
    'other': MembersRemoveError._other_validator,
}
MembersRemoveError._tagmap.update(UserSelectorError._tagmap)

MembersRemoveError.other = MembersRemoveError('other')

DateRange._start_date_validator = bv.Nullable(bv.Timestamp(u'%Y-%m-%d'))
DateRange._end_date_validator = bv.Nullable(bv.Timestamp(u'%Y-%m-%d'))
DateRange._all_field_names_ = set([
    'start_date',
    'end_date',
])
DateRange._all_fields_ = [
    ('start_date', DateRange._start_date_validator),
    ('end_date', DateRange._end_date_validator),
]

DateRangeError._other_validator = bv.Void()
DateRangeError._tagmap = {
    'other': DateRangeError._other_validator,
}

DateRangeError.other = DateRangeError('other')

StorageBucket._bucket_validator = bv.String()
StorageBucket._users_validator = bv.UInt64()
StorageBucket._all_field_names_ = set([
    'bucket',
    'users',
])
StorageBucket._all_fields_ = [
    ('bucket', StorageBucket._bucket_validator),
    ('users', StorageBucket._users_validator),
]

BaseDfbReport._start_date_validator = bv.String()
BaseDfbReport._all_field_names_ = set(['start_date'])
BaseDfbReport._all_fields_ = [('start_date', BaseDfbReport._start_date_validator)]

GetStorageReport._total_usage_validator = bv.List(bv.Nullable(bv.UInt64()))
GetStorageReport._shared_usage_validator = bv.List(bv.Nullable(bv.UInt64()))
GetStorageReport._unshared_usage_validator = bv.List(bv.Nullable(bv.UInt64()))
GetStorageReport._shared_folders_validator = bv.List(bv.Nullable(bv.UInt64()))
GetStorageReport._member_storage_map_validator = bv.List(bv.List(bv.Struct(StorageBucket)))
GetStorageReport._all_field_names_ = BaseDfbReport._all_field_names_.union(set([
    'total_usage',
    'shared_usage',
    'unshared_usage',
    'shared_folders',
    'member_storage_map',
]))
GetStorageReport._all_fields_ = BaseDfbReport._all_fields_ + [
    ('total_usage', GetStorageReport._total_usage_validator),
    ('shared_usage', GetStorageReport._shared_usage_validator),
    ('unshared_usage', GetStorageReport._unshared_usage_validator),
    ('shared_folders', GetStorageReport._shared_folders_validator),
    ('member_storage_map', GetStorageReport._member_storage_map_validator),
]

GetActivityReport._adds_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._edits_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._deletes_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._active_users_28_day_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._active_users_7_day_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._active_users_1_day_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._active_shared_folders_28_day_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._active_shared_folders_7_day_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._active_shared_folders_1_day_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._shared_links_created_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._shared_links_viewed_by_team_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._shared_links_viewed_by_outside_user_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._shared_links_viewed_by_not_logged_in_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._shared_links_viewed_total_validator = bv.List(bv.Nullable(bv.UInt64()))
GetActivityReport._all_field_names_ = BaseDfbReport._all_field_names_.union(set([
    'adds',
    'edits',
    'deletes',
    'active_users_28_day',
    'active_users_7_day',
    'active_users_1_day',
    'active_shared_folders_28_day',
    'active_shared_folders_7_day',
    'active_shared_folders_1_day',
    'shared_links_created',
    'shared_links_viewed_by_team',
    'shared_links_viewed_by_outside_user',
    'shared_links_viewed_by_not_logged_in',
    'shared_links_viewed_total',
]))
GetActivityReport._all_fields_ = BaseDfbReport._all_fields_ + [
    ('adds', GetActivityReport._adds_validator),
    ('edits', GetActivityReport._edits_validator),
    ('deletes', GetActivityReport._deletes_validator),
    ('active_users_28_day', GetActivityReport._active_users_28_day_validator),
    ('active_users_7_day', GetActivityReport._active_users_7_day_validator),
    ('active_users_1_day', GetActivityReport._active_users_1_day_validator),
    ('active_shared_folders_28_day', GetActivityReport._active_shared_folders_28_day_validator),
    ('active_shared_folders_7_day', GetActivityReport._active_shared_folders_7_day_validator),
    ('active_shared_folders_1_day', GetActivityReport._active_shared_folders_1_day_validator),
    ('shared_links_created', GetActivityReport._shared_links_created_validator),
    ('shared_links_viewed_by_team', GetActivityReport._shared_links_viewed_by_team_validator),
    ('shared_links_viewed_by_outside_user', GetActivityReport._shared_links_viewed_by_outside_user_validator),
    ('shared_links_viewed_by_not_logged_in', GetActivityReport._shared_links_viewed_by_not_logged_in_validator),
    ('shared_links_viewed_total', GetActivityReport._shared_links_viewed_total_validator),
]

GetMembershipReport._team_size_validator = bv.List(bv.Nullable(bv.UInt64()))
GetMembershipReport._pending_invites_validator = bv.List(bv.Nullable(bv.UInt64()))
GetMembershipReport._members_joined_validator = bv.List(bv.Nullable(bv.UInt64()))
GetMembershipReport._suspended_members_validator = bv.List(bv.Nullable(bv.UInt64()))
GetMembershipReport._licenses_validator = bv.List(bv.Nullable(bv.UInt64()))
GetMembershipReport._all_field_names_ = BaseDfbReport._all_field_names_.union(set([
    'team_size',
    'pending_invites',
    'members_joined',
    'suspended_members',
    'licenses',
]))
GetMembershipReport._all_fields_ = BaseDfbReport._all_fields_ + [
    ('team_size', GetMembershipReport._team_size_validator),
    ('pending_invites', GetMembershipReport._pending_invites_validator),
    ('members_joined', GetMembershipReport._members_joined_validator),
    ('suspended_members', GetMembershipReport._suspended_members_validator),
    ('licenses', GetMembershipReport._licenses_validator),
]

DevicesActive._windows_validator = bv.List(bv.Nullable(bv.UInt64()))
DevicesActive._macos_validator = bv.List(bv.Nullable(bv.UInt64()))
DevicesActive._linux_validator = bv.List(bv.Nullable(bv.UInt64()))
DevicesActive._ios_validator = bv.List(bv.Nullable(bv.UInt64()))
DevicesActive._android_validator = bv.List(bv.Nullable(bv.UInt64()))
DevicesActive._other_validator = bv.List(bv.Nullable(bv.UInt64()))
DevicesActive._total_validator = bv.List(bv.Nullable(bv.UInt64()))
DevicesActive._all_field_names_ = set([
    'windows',
    'macos',
    'linux',
    'ios',
    'android',
    'other',
    'total',
])
DevicesActive._all_fields_ = [
    ('windows', DevicesActive._windows_validator),
    ('macos', DevicesActive._macos_validator),
    ('linux', DevicesActive._linux_validator),
    ('ios', DevicesActive._ios_validator),
    ('android', DevicesActive._android_validator),
    ('other', DevicesActive._other_validator),
    ('total', DevicesActive._total_validator),
]

GetDevicesReport._active_1_day_validator = bv.Struct(DevicesActive)
GetDevicesReport._active_7_day_validator = bv.Struct(DevicesActive)
GetDevicesReport._active_28_day_validator = bv.Struct(DevicesActive)
GetDevicesReport._all_field_names_ = BaseDfbReport._all_field_names_.union(set([
    'active_1_day',
    'active_7_day',
    'active_28_day',
]))
GetDevicesReport._all_fields_ = BaseDfbReport._all_fields_ + [
    ('active_1_day', GetDevicesReport._active_1_day_validator),
    ('active_7_day', GetDevicesReport._active_7_day_validator),
    ('active_28_day', GetDevicesReport._active_28_day_validator),
]

