# Auto-generated by BabelAPI, do not modify.
try:
    from . import babel_validators as bv
except (SystemError, ValueError):
    # Catch errors raised when importing a relative module when not in a package.
    # This makes testing this file directly (outside of a package) easier.
    import babel_validators as bv

try:
    from . import (
        users,
    )
except (SystemError, ValueError):
    import users

class TeamSuspensionState(object):
    """
    :ivar active: The team is active and can be used within full quota.
    :ivar suspended: The team's subscription is suspended. Users can still login
        and access their files, but they will have reduced quota and possibily
        some other restrictions.
    :ivar deleted: This team has been deleted.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = None
    # Attribute is overwritten below the class definition
    active = None
    # Attribute is overwritten below the class definition
    suspended = None
    # Attribute is overwritten below the class definition
    deleted = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_active(self):
        return self._tag == 'active'

    def is_suspended(self):
        return self._tag == 'suspended'

    def is_deleted(self):
        return self._tag == 'deleted'

    def __repr__(self):
        return 'TeamSuspensionState(%r)' % self._tag

class TeamWithState(users.Team):
    """
    Information about a team along with its current state.

    :ivar num_licensed_users: Total number of licenses the team has authorized
    :ivar num_provisioned_users: Number of accounts that have been invited or
        are already active members of the team.
    """

    __slots__ = [
        '_num_licensed_users_value',
        '_num_licensed_users_present',
        '_num_provisioned_users_value',
        '_num_provisioned_users_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 id=None,
                 name=None,
                 num_licensed_users=None,
                 num_provisioned_users=None):
        super(TeamWithState, self).__init__(id,
                                            name)
        self._num_licensed_users_value = None
        self._num_licensed_users_present = False
        self._num_provisioned_users_value = None
        self._num_provisioned_users_present = False
        if num_licensed_users is not None:
            self.num_licensed_users = num_licensed_users
        if num_provisioned_users is not None:
            self.num_provisioned_users = num_provisioned_users

    @property
    def num_licensed_users(self):
        """
        Total number of licenses the team has authorized

        :rtype: long
        """
        if self._num_licensed_users_present:
            return self._num_licensed_users_value
        else:
            raise AttributeError("missing required field 'num_licensed_users'")

    @num_licensed_users.setter
    def num_licensed_users(self, val):
        val = self._num_licensed_users_validator.validate(val)
        self._num_licensed_users_value = val
        self._num_licensed_users_present = True

    @num_licensed_users.deleter
    def num_licensed_users(self):
        self._num_licensed_users_value = None
        self._num_licensed_users_present = False

    @property
    def num_provisioned_users(self):
        """
        Number of accounts that have been invited or are already active members
        of the team.

        :rtype: long
        """
        if self._num_provisioned_users_present:
            return self._num_provisioned_users_value
        else:
            raise AttributeError("missing required field 'num_provisioned_users'")

    @num_provisioned_users.setter
    def num_provisioned_users(self, val):
        val = self._num_provisioned_users_validator.validate(val)
        self._num_provisioned_users_value = val
        self._num_provisioned_users_present = True

    @num_provisioned_users.deleter
    def num_provisioned_users(self):
        self._num_provisioned_users_value = None
        self._num_provisioned_users_present = False

    def __repr__(self):
        return 'TeamWithState(id={!r}, name={!r}, num_licensed_users={!r}, num_provisioned_users={!r})'.format(
            self._id_value,
            self._name_value,
            self._num_licensed_users_value,
            self._num_provisioned_users_value,
        )

class TeamWithStateList(object):

    __slots__ = [
        '_teams_value',
        '_teams_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 teams=None):
        self._teams_value = None
        self._teams_present = False
        if teams is not None:
            self.teams = teams

    @property
    def teams(self):
        """
        :rtype: list of [TeamWithState]
        """
        if self._teams_present:
            return self._teams_value
        else:
            raise AttributeError("missing required field 'teams'")

    @teams.setter
    def teams(self, val):
        val = self._teams_validator.validate(val)
        self._teams_value = val
        self._teams_present = True

    @teams.deleter
    def teams(self):
        self._teams_value = None
        self._teams_present = False

    def __repr__(self):
        return 'TeamWithStateList(teams={!r})'.format(
            self._teams_value,
        )

class CreateTeamArg(object):
    """
    :ivar name: The name of the team.
    :ivar num_licensed_users: The number of licenses of the team.
    :ivar sku: SKU of team to use - must be 1 for now.
    :ivar invite_admin: Email address of the initial admin of this team.
    :ivar default_language_code: A ISO639-1 code that specifies the default
        language of the team.
    """

    __slots__ = [
        '_name_value',
        '_name_present',
        '_num_licensed_users_value',
        '_num_licensed_users_present',
        '_sku_value',
        '_sku_present',
        '_invite_admin_value',
        '_invite_admin_present',
        '_default_language_code_value',
        '_default_language_code_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 name=None,
                 num_licensed_users=None,
                 sku=None,
                 invite_admin=None,
                 default_language_code=None):
        self._name_value = None
        self._name_present = False
        self._num_licensed_users_value = None
        self._num_licensed_users_present = False
        self._sku_value = None
        self._sku_present = False
        self._invite_admin_value = None
        self._invite_admin_present = False
        self._default_language_code_value = None
        self._default_language_code_present = False
        if name is not None:
            self.name = name
        if num_licensed_users is not None:
            self.num_licensed_users = num_licensed_users
        if sku is not None:
            self.sku = sku
        if invite_admin is not None:
            self.invite_admin = invite_admin
        if default_language_code is not None:
            self.default_language_code = default_language_code

    @property
    def name(self):
        """
        The name of the team.

        :rtype: str
        """
        if self._name_present:
            return self._name_value
        else:
            raise AttributeError("missing required field 'name'")

    @name.setter
    def name(self, val):
        val = self._name_validator.validate(val)
        self._name_value = val
        self._name_present = True

    @name.deleter
    def name(self):
        self._name_value = None
        self._name_present = False

    @property
    def num_licensed_users(self):
        """
        The number of licenses of the team.

        :rtype: long
        """
        if self._num_licensed_users_present:
            return self._num_licensed_users_value
        else:
            raise AttributeError("missing required field 'num_licensed_users'")

    @num_licensed_users.setter
    def num_licensed_users(self, val):
        val = self._num_licensed_users_validator.validate(val)
        self._num_licensed_users_value = val
        self._num_licensed_users_present = True

    @num_licensed_users.deleter
    def num_licensed_users(self):
        self._num_licensed_users_value = None
        self._num_licensed_users_present = False

    @property
    def sku(self):
        """
        SKU of team to use - must be 1 for now.

        :rtype: long
        """
        if self._sku_present:
            return self._sku_value
        else:
            raise AttributeError("missing required field 'sku'")

    @sku.setter
    def sku(self, val):
        val = self._sku_validator.validate(val)
        self._sku_value = val
        self._sku_present = True

    @sku.deleter
    def sku(self):
        self._sku_value = None
        self._sku_present = False

    @property
    def invite_admin(self):
        """
        Email address of the initial admin of this team.

        :rtype: str
        """
        if self._invite_admin_present:
            return self._invite_admin_value
        else:
            raise AttributeError("missing required field 'invite_admin'")

    @invite_admin.setter
    def invite_admin(self, val):
        val = self._invite_admin_validator.validate(val)
        self._invite_admin_value = val
        self._invite_admin_present = True

    @invite_admin.deleter
    def invite_admin(self):
        self._invite_admin_value = None
        self._invite_admin_present = False

    @property
    def default_language_code(self):
        """
        A ISO639-1 code that specifies the default language of the team.

        :rtype: str
        """
        if self._default_language_code_present:
            return self._default_language_code_value
        else:
            return None

    @default_language_code.setter
    def default_language_code(self, val):
        if val is None:
            del self.default_language_code
            return
        val = self._default_language_code_validator.validate(val)
        self._default_language_code_value = val
        self._default_language_code_present = True

    @default_language_code.deleter
    def default_language_code(self):
        self._default_language_code_value = None
        self._default_language_code_present = False

    def __repr__(self):
        return 'CreateTeamArg(name={!r}, num_licensed_users={!r}, sku={!r}, invite_admin={!r}, default_language_code={!r})'.format(
            self._name_value,
            self._num_licensed_users_value,
            self._sku_value,
            self._invite_admin_value,
            self._default_language_code_value,
        )

class CreateTeamError(object):
    """
    :ivar num_licensed_users_not_allowed: The specified
        ``CreateTeamArg.num_licensed_users`` is not allowed.
    :ivar no_sku: The specified ``CreateTeamArg.sku`` does not exist.
    :ivar no_default_language_code: The specified
        ``CreateTeamArg.default_language_code`` does not exist.
    :ivar team_license_limit: Team is already full. The Dropbox for Business
        organization has no available licenses.
    :ivar user_already_on_team: User is already on this team. The provided email
        address is associated with a user who is already a member of or invited
        to the team.
    :ivar user_on_another_team: User is already on another team. The provided
        email address is associated with a user that is already a member or
        invited to another team.
    :ivar str cannot_invite_admin: Any other reason for which user cannot be
        invited to the team. See embedded string for more details.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'unknown'
    # Attribute is overwritten below the class definition
    num_licensed_users_not_allowed = None
    # Attribute is overwritten below the class definition
    no_sku = None
    # Attribute is overwritten below the class definition
    no_default_language_code = None
    # Attribute is overwritten below the class definition
    team_license_limit = None
    # Attribute is overwritten below the class definition
    user_already_on_team = None
    # Attribute is overwritten below the class definition
    user_on_another_team = None
    # Attribute is overwritten below the class definition
    user_already_paired = None
    # Attribute is overwritten below the class definition
    user_migration_failed = None
    # Attribute is overwritten below the class definition
    unknown = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    @classmethod
    def cannot_invite_admin(cls, val):
        return cls('cannot_invite_admin', val)

    def is_num_licensed_users_not_allowed(self):
        return self._tag == 'num_licensed_users_not_allowed'

    def is_no_sku(self):
        return self._tag == 'no_sku'

    def is_no_default_language_code(self):
        return self._tag == 'no_default_language_code'

    def is_team_license_limit(self):
        return self._tag == 'team_license_limit'

    def is_user_already_on_team(self):
        return self._tag == 'user_already_on_team'

    def is_user_on_another_team(self):
        return self._tag == 'user_on_another_team'

    def is_user_already_paired(self):
        return self._tag == 'user_already_paired'

    def is_user_migration_failed(self):
        return self._tag == 'user_migration_failed'

    def is_cannot_invite_admin(self):
        return self._tag == 'cannot_invite_admin'

    def is_unknown(self):
        return self._tag == 'unknown'

    def get_cannot_invite_admin(self):
        if not self.is_cannot_invite_admin():
            raise AttributeError("tag 'cannot_invite_admin' not set")
        return self._value

    def __repr__(self):
        return 'CreateTeamError(%r)' % self._tag

class GetTeamArg(object):
    """
    :ivar id: A team's unique ID.
    """

    __slots__ = [
        '_id_value',
        '_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 id=None):
        self._id_value = None
        self._id_present = False
        if id is not None:
            self.id = id

    @property
    def id(self):
        """
        A team's unique ID.

        :rtype: str
        """
        if self._id_present:
            return self._id_value
        else:
            raise AttributeError("missing required field 'id'")

    @id.setter
    def id(self, val):
        val = self._id_validator.validate(val)
        self._id_value = val
        self._id_present = True

    @id.deleter
    def id(self):
        self._id_value = None
        self._id_present = False

    def __repr__(self):
        return 'GetTeamArg(id={!r})'.format(
            self._id_value,
        )

class GetTeamError(object):
    """
    :ivar no_team: The specified ``GetTeamArg.id`` does not exist.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = 'unknown'
    # Attribute is overwritten below the class definition
    no_team = None
    # Attribute is overwritten below the class definition
    unknown = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_no_team(self):
        return self._tag == 'no_team'

    def is_unknown(self):
        return self._tag == 'unknown'

    def __repr__(self):
        return 'GetTeamError(%r)' % self._tag

class ModifyLicensesArg(GetTeamArg):
    """
    :ivar current_num_licensed_users: The current number of licenses for this
        team.
    :ivar new_num_licensed_users: The new number of licenses of the team.
    """

    __slots__ = [
        '_current_num_licensed_users_value',
        '_current_num_licensed_users_present',
        '_new_num_licensed_users_value',
        '_new_num_licensed_users_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 id=None,
                 current_num_licensed_users=None,
                 new_num_licensed_users=None):
        super(ModifyLicensesArg, self).__init__(id)
        self._current_num_licensed_users_value = None
        self._current_num_licensed_users_present = False
        self._new_num_licensed_users_value = None
        self._new_num_licensed_users_present = False
        if current_num_licensed_users is not None:
            self.current_num_licensed_users = current_num_licensed_users
        if new_num_licensed_users is not None:
            self.new_num_licensed_users = new_num_licensed_users

    @property
    def current_num_licensed_users(self):
        """
        The current number of licenses for this team.

        :rtype: long
        """
        if self._current_num_licensed_users_present:
            return self._current_num_licensed_users_value
        else:
            raise AttributeError("missing required field 'current_num_licensed_users'")

    @current_num_licensed_users.setter
    def current_num_licensed_users(self, val):
        val = self._current_num_licensed_users_validator.validate(val)
        self._current_num_licensed_users_value = val
        self._current_num_licensed_users_present = True

    @current_num_licensed_users.deleter
    def current_num_licensed_users(self):
        self._current_num_licensed_users_value = None
        self._current_num_licensed_users_present = False

    @property
    def new_num_licensed_users(self):
        """
        The new number of licenses of the team.

        :rtype: long
        """
        if self._new_num_licensed_users_present:
            return self._new_num_licensed_users_value
        else:
            raise AttributeError("missing required field 'new_num_licensed_users'")

    @new_num_licensed_users.setter
    def new_num_licensed_users(self, val):
        val = self._new_num_licensed_users_validator.validate(val)
        self._new_num_licensed_users_value = val
        self._new_num_licensed_users_present = True

    @new_num_licensed_users.deleter
    def new_num_licensed_users(self):
        self._new_num_licensed_users_value = None
        self._new_num_licensed_users_present = False

    def __repr__(self):
        return 'ModifyLicensesArg(id={!r}, current_num_licensed_users={!r}, new_num_licensed_users={!r})'.format(
            self._id_value,
            self._current_num_licensed_users_value,
            self._new_num_licensed_users_value,
        )

class ModifyLicensesError(GetTeamError):
    """
    :ivar incorrect_current_num_licensed_users: The specified
        ``ModifyLicensesArg.current_num_licensed_users`` is not correct  (has a
        different value than the actual num_licensed_users for this team).
    :ivar new_num_licensed_users_not_allowed: The specified
        ``ModifyLicensesArg.new_num_licensed_users`` is not allowed.
    """

    __slots__ = ['_tag', '_value']

    # Attribute is overwritten below the class definition
    incorrect_current_num_licensed_users = None
    # Attribute is overwritten below the class definition
    new_num_licensed_users_not_allowed = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_incorrect_current_num_licensed_users(self):
        return self._tag == 'incorrect_current_num_licensed_users'

    def is_new_num_licensed_users_not_allowed(self):
        return self._tag == 'new_num_licensed_users_not_allowed'

    def __repr__(self):
        return 'ModifyLicensesError(%r)' % self._tag

class SpaceGetArg(object):
    """
    :ivar uid: The user's unique identifier.
    """

    __slots__ = [
        '_uid_value',
        '_uid_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 uid=None):
        self._uid_value = None
        self._uid_present = False
        if uid is not None:
            self.uid = uid

    @property
    def uid(self):
        """
        The user's unique identifier.

        :rtype: long
        """
        if self._uid_present:
            return self._uid_value
        else:
            raise AttributeError("missing required field 'uid'")

    @uid.setter
    def uid(self, val):
        val = self._uid_validator.validate(val)
        self._uid_value = val
        self._uid_present = True

    @uid.deleter
    def uid(self):
        self._uid_value = None
        self._uid_present = False

    def __repr__(self):
        return 'SpaceGetArg(uid={!r})'.format(
            self._uid_value,
        )

class SpaceListArg(object):
    """
    :ivar date: A UTC date time that indicates the latest point in time to be
        included in the response from this endpoint. Any changes that happened
        after the indicated point in time will not be reflected in the response.
        Supply the same date in subsequent queries to obtain a consistent
        response when paginating.
    :ivar page: An integer specifying which page of the response to display.
        Optional. Defaults to 0 if not supplied.
    """

    __slots__ = [
        '_date_value',
        '_date_present',
        '_page_value',
        '_page_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 date=None,
                 page=None):
        self._date_value = None
        self._date_present = False
        self._page_value = None
        self._page_present = False
        if date is not None:
            self.date = date
        if page is not None:
            self.page = page

    @property
    def date(self):
        """
        A UTC date time that indicates the latest point in time to be included
        in the response from this endpoint. Any changes that happened after the
        indicated point in time will not be reflected in the response. Supply
        the same date in subsequent queries to obtain a consistent response when
        paginating.

        :rtype: datetime.datetime
        """
        if self._date_present:
            return self._date_value
        else:
            raise AttributeError("missing required field 'date'")

    @date.setter
    def date(self, val):
        val = self._date_validator.validate(val)
        self._date_value = val
        self._date_present = True

    @date.deleter
    def date(self):
        self._date_value = None
        self._date_present = False

    @property
    def page(self):
        """
        An integer specifying which page of the response to display. Optional.
        Defaults to 0 if not supplied.

        :rtype: long
        """
        if self._page_present:
            return self._page_value
        else:
            return None

    @page.setter
    def page(self, val):
        if val is None:
            del self.page
            return
        val = self._page_validator.validate(val)
        self._page_value = val
        self._page_present = True

    @page.deleter
    def page(self):
        self._page_value = None
        self._page_present = False

    def __repr__(self):
        return 'SpaceListArg(date={!r}, page={!r})'.format(
            self._date_value,
            self._page_value,
        )

class SpaceProvisionArg(object):
    """
    :ivar uid: The user's unique identifier.
    :ivar partner_uid: An identifier chosen by the partner to identify the user
        or transaction for auditing purposes.
    :ivar sku_id: The id of the SKU that should be provisioned.
    :ivar country_code: The `ISO 3166-1 alpha-2
        <http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2>`_ country code of the
        country that Partner will be billed in for this SKU, e.g. 'GB' for the
        United Kingdom of Great Britain and Northern Ireland.
    """

    __slots__ = [
        '_uid_value',
        '_uid_present',
        '_partner_uid_value',
        '_partner_uid_present',
        '_sku_id_value',
        '_sku_id_present',
        '_country_code_value',
        '_country_code_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 uid=None,
                 partner_uid=None,
                 sku_id=None,
                 country_code=None):
        self._uid_value = None
        self._uid_present = False
        self._partner_uid_value = None
        self._partner_uid_present = False
        self._sku_id_value = None
        self._sku_id_present = False
        self._country_code_value = None
        self._country_code_present = False
        if uid is not None:
            self.uid = uid
        if partner_uid is not None:
            self.partner_uid = partner_uid
        if sku_id is not None:
            self.sku_id = sku_id
        if country_code is not None:
            self.country_code = country_code

    @property
    def uid(self):
        """
        The user's unique identifier.

        :rtype: long
        """
        if self._uid_present:
            return self._uid_value
        else:
            raise AttributeError("missing required field 'uid'")

    @uid.setter
    def uid(self, val):
        val = self._uid_validator.validate(val)
        self._uid_value = val
        self._uid_present = True

    @uid.deleter
    def uid(self):
        self._uid_value = None
        self._uid_present = False

    @property
    def partner_uid(self):
        """
        An identifier chosen by the partner to identify the user or transaction
        for auditing purposes.

        :rtype: str
        """
        if self._partner_uid_present:
            return self._partner_uid_value
        else:
            raise AttributeError("missing required field 'partner_uid'")

    @partner_uid.setter
    def partner_uid(self, val):
        val = self._partner_uid_validator.validate(val)
        self._partner_uid_value = val
        self._partner_uid_present = True

    @partner_uid.deleter
    def partner_uid(self):
        self._partner_uid_value = None
        self._partner_uid_present = False

    @property
    def sku_id(self):
        """
        The id of the SKU that should be provisioned.

        :rtype: long
        """
        if self._sku_id_present:
            return self._sku_id_value
        else:
            raise AttributeError("missing required field 'sku_id'")

    @sku_id.setter
    def sku_id(self, val):
        val = self._sku_id_validator.validate(val)
        self._sku_id_value = val
        self._sku_id_present = True

    @sku_id.deleter
    def sku_id(self):
        self._sku_id_value = None
        self._sku_id_present = False

    @property
    def country_code(self):
        """
        The `ISO 3166-1 alpha-2
        <http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2>`_ country code of the
        country that Partner will be billed in for this SKU, e.g. 'GB' for the
        United Kingdom of Great Britain and Northern Ireland.

        :rtype: str
        """
        if self._country_code_present:
            return self._country_code_value
        else:
            raise AttributeError("missing required field 'country_code'")

    @country_code.setter
    def country_code(self, val):
        val = self._country_code_validator.validate(val)
        self._country_code_value = val
        self._country_code_present = True

    @country_code.deleter
    def country_code(self):
        self._country_code_value = None
        self._country_code_present = False

    def __repr__(self):
        return 'SpaceProvisionArg(uid={!r}, partner_uid={!r}, sku_id={!r}, country_code={!r})'.format(
            self._uid_value,
            self._partner_uid_value,
            self._sku_id_value,
            self._country_code_value,
        )

class SpaceDisableArg(object):
    """
    :ivar uid: The user's unique identifier.
    :ivar instance_id: The unique identifier for a single instance of a SKU that
        should be disabled.
    :ivar sku_id: The id of the SKU that should be disabled. This is used as a
        safeguard that the ``instance_id`` belongs to a SKU of the intended
        type.
    """

    __slots__ = [
        '_uid_value',
        '_uid_present',
        '_instance_id_value',
        '_instance_id_present',
        '_sku_id_value',
        '_sku_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 uid=None,
                 instance_id=None,
                 sku_id=None):
        self._uid_value = None
        self._uid_present = False
        self._instance_id_value = None
        self._instance_id_present = False
        self._sku_id_value = None
        self._sku_id_present = False
        if uid is not None:
            self.uid = uid
        if instance_id is not None:
            self.instance_id = instance_id
        if sku_id is not None:
            self.sku_id = sku_id

    @property
    def uid(self):
        """
        The user's unique identifier.

        :rtype: long
        """
        if self._uid_present:
            return self._uid_value
        else:
            raise AttributeError("missing required field 'uid'")

    @uid.setter
    def uid(self, val):
        val = self._uid_validator.validate(val)
        self._uid_value = val
        self._uid_present = True

    @uid.deleter
    def uid(self):
        self._uid_value = None
        self._uid_present = False

    @property
    def instance_id(self):
        """
        The unique identifier for a single instance of a SKU that should be
        disabled.

        :rtype: str
        """
        if self._instance_id_present:
            return self._instance_id_value
        else:
            raise AttributeError("missing required field 'instance_id'")

    @instance_id.setter
    def instance_id(self, val):
        val = self._instance_id_validator.validate(val)
        self._instance_id_value = val
        self._instance_id_present = True

    @instance_id.deleter
    def instance_id(self):
        self._instance_id_value = None
        self._instance_id_present = False

    @property
    def sku_id(self):
        """
        The id of the SKU that should be disabled. This is used as a safeguard
        that the ``instance_id`` belongs to a SKU of the intended type.

        :rtype: long
        """
        if self._sku_id_present:
            return self._sku_id_value
        else:
            raise AttributeError("missing required field 'sku_id'")

    @sku_id.setter
    def sku_id(self, val):
        val = self._sku_id_validator.validate(val)
        self._sku_id_value = val
        self._sku_id_present = True

    @sku_id.deleter
    def sku_id(self):
        self._sku_id_value = None
        self._sku_id_present = False

    def __repr__(self):
        return 'SpaceDisableArg(uid={!r}, instance_id={!r}, sku_id={!r})'.format(
            self._uid_value,
            self._instance_id_value,
            self._sku_id_value,
        )

class SkuProvisionState(object):
    """
    :ivar awaiting_requirement: The SKU has been provisioned, but is not yet
        fully active. This is typically the case if users are required to
        satisfy another requirement, such as completing Get Started. Depending
        on the agreement between Partner and Dropbox, some space may be granted
        in this state. The amount of space granted to the user may increase when
        the SKU changes into the active state.
    :ivar active: The SKU has been provisioned and is active.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = None
    # Attribute is overwritten below the class definition
    awaiting_requirement = None
    # Attribute is overwritten below the class definition
    active = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_awaiting_requirement(self):
        return self._tag == 'awaiting_requirement'

    def is_active(self):
        return self._tag == 'active'

    def __repr__(self):
        return 'SkuProvisionState(%r)' % self._tag

class SkuProvisionInfo(object):
    """
    Information about the provisioning state of a single SKU.

    :ivar instance_id: A unique identifier for a single instance of a SKU. When
        multiple SKUs of the same type are provisioned for one user then this
        identifier can be used to distinguish them.
    :ivar sku_id: An identifier issued to Partner by Dropbox that captures the
        provisioning-related aspects, such as amount of space granted, any
        requirements for granting, and duration of the SKU.
    :ivar country_code: The `ISO 3166-1 alpha-2
        <http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2>`_ country code of the
        country that Partner will be billed in for this SKU, e.g. 'GB' for the
        United Kingdom of Great Britain and Northern Ireland. The combination of
        ``country_code`` and ``sku_id`` specifies the currency that Partner will
        be billed in.
    :ivar provisioned_date: Specifies when the SKU was provisioned.
    :ivar activated_date: Specifies when the SKU was activated. Only present if
        the SKU is in active state.
    :ivar end_date: Specifies when the SKU will end. Only present if the SKU
        automatically terminates after a pre-agreed number of months and some
        amount of space is being granted to the user in the current state.
    :ivar state: The provisioning status of this SKU.
    """

    __slots__ = [
        '_instance_id_value',
        '_instance_id_present',
        '_sku_id_value',
        '_sku_id_present',
        '_country_code_value',
        '_country_code_present',
        '_provisioned_date_value',
        '_provisioned_date_present',
        '_activated_date_value',
        '_activated_date_present',
        '_end_date_value',
        '_end_date_present',
        '_state_value',
        '_state_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 instance_id=None,
                 sku_id=None,
                 country_code=None,
                 provisioned_date=None,
                 state=None,
                 activated_date=None,
                 end_date=None):
        self._instance_id_value = None
        self._instance_id_present = False
        self._sku_id_value = None
        self._sku_id_present = False
        self._country_code_value = None
        self._country_code_present = False
        self._provisioned_date_value = None
        self._provisioned_date_present = False
        self._activated_date_value = None
        self._activated_date_present = False
        self._end_date_value = None
        self._end_date_present = False
        self._state_value = None
        self._state_present = False
        if instance_id is not None:
            self.instance_id = instance_id
        if sku_id is not None:
            self.sku_id = sku_id
        if country_code is not None:
            self.country_code = country_code
        if provisioned_date is not None:
            self.provisioned_date = provisioned_date
        if activated_date is not None:
            self.activated_date = activated_date
        if end_date is not None:
            self.end_date = end_date
        if state is not None:
            self.state = state

    @property
    def instance_id(self):
        """
        A unique identifier for a single instance of a SKU. When multiple SKUs
        of the same type are provisioned for one user then this identifier can
        be used to distinguish them.

        :rtype: str
        """
        if self._instance_id_present:
            return self._instance_id_value
        else:
            raise AttributeError("missing required field 'instance_id'")

    @instance_id.setter
    def instance_id(self, val):
        val = self._instance_id_validator.validate(val)
        self._instance_id_value = val
        self._instance_id_present = True

    @instance_id.deleter
    def instance_id(self):
        self._instance_id_value = None
        self._instance_id_present = False

    @property
    def sku_id(self):
        """
        An identifier issued to Partner by Dropbox that captures the
        provisioning-related aspects, such as amount of space granted, any
        requirements for granting, and duration of the SKU.

        :rtype: long
        """
        if self._sku_id_present:
            return self._sku_id_value
        else:
            raise AttributeError("missing required field 'sku_id'")

    @sku_id.setter
    def sku_id(self, val):
        val = self._sku_id_validator.validate(val)
        self._sku_id_value = val
        self._sku_id_present = True

    @sku_id.deleter
    def sku_id(self):
        self._sku_id_value = None
        self._sku_id_present = False

    @property
    def country_code(self):
        """
        The `ISO 3166-1 alpha-2
        <http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2>`_ country code of the
        country that Partner will be billed in for this SKU, e.g. 'GB' for the
        United Kingdom of Great Britain and Northern Ireland. The combination of
        ``country_code`` and ``sku_id`` specifies the currency that Partner will
        be billed in.

        :rtype: str
        """
        if self._country_code_present:
            return self._country_code_value
        else:
            raise AttributeError("missing required field 'country_code'")

    @country_code.setter
    def country_code(self, val):
        val = self._country_code_validator.validate(val)
        self._country_code_value = val
        self._country_code_present = True

    @country_code.deleter
    def country_code(self):
        self._country_code_value = None
        self._country_code_present = False

    @property
    def provisioned_date(self):
        """
        Specifies when the SKU was provisioned.

        :rtype: datetime.datetime
        """
        if self._provisioned_date_present:
            return self._provisioned_date_value
        else:
            raise AttributeError("missing required field 'provisioned_date'")

    @provisioned_date.setter
    def provisioned_date(self, val):
        val = self._provisioned_date_validator.validate(val)
        self._provisioned_date_value = val
        self._provisioned_date_present = True

    @provisioned_date.deleter
    def provisioned_date(self):
        self._provisioned_date_value = None
        self._provisioned_date_present = False

    @property
    def activated_date(self):
        """
        Specifies when the SKU was activated. Only present if the SKU is in
        active state.

        :rtype: datetime.datetime
        """
        if self._activated_date_present:
            return self._activated_date_value
        else:
            return None

    @activated_date.setter
    def activated_date(self, val):
        if val is None:
            del self.activated_date
            return
        val = self._activated_date_validator.validate(val)
        self._activated_date_value = val
        self._activated_date_present = True

    @activated_date.deleter
    def activated_date(self):
        self._activated_date_value = None
        self._activated_date_present = False

    @property
    def end_date(self):
        """
        Specifies when the SKU will end. Only present if the SKU automatically
        terminates after a pre-agreed number of months and some amount of space
        is being granted to the user in the current state.

        :rtype: datetime.datetime
        """
        if self._end_date_present:
            return self._end_date_value
        else:
            return None

    @end_date.setter
    def end_date(self, val):
        if val is None:
            del self.end_date
            return
        val = self._end_date_validator.validate(val)
        self._end_date_value = val
        self._end_date_present = True

    @end_date.deleter
    def end_date(self):
        self._end_date_value = None
        self._end_date_present = False

    @property
    def state(self):
        """
        The provisioning status of this SKU.

        :rtype: SkuProvisionState
        """
        if self._state_present:
            return self._state_value
        else:
            raise AttributeError("missing required field 'state'")

    @state.setter
    def state(self, val):
        self._state_validator.validate_type_only(val)
        self._state_value = val
        self._state_present = True

    @state.deleter
    def state(self):
        self._state_value = None
        self._state_present = False

    def __repr__(self):
        return 'SkuProvisionInfo(instance_id={!r}, sku_id={!r}, country_code={!r}, provisioned_date={!r}, state={!r}, activated_date={!r}, end_date={!r})'.format(
            self._instance_id_value,
            self._sku_id_value,
            self._country_code_value,
            self._provisioned_date_value,
            self._state_value,
            self._activated_date_value,
            self._end_date_value,
        )

class SpaceUserResult(object):
    """
    A response containing information about a single user and active SKUs that
    Partner provisioned.

    :ivar uid: The user's unique identifier.
    :ivar active_skus: A list of all currently active SKUs provisioned by
        Partner.
    :ivar total_quota: The user's total quota in their Dropbox, in bytes.
    :ivar used_quota: The aggregate amount of data in their Dropbox, in bytes.
        Contains files in shared and private folders.
    """

    __slots__ = [
        '_uid_value',
        '_uid_present',
        '_active_skus_value',
        '_active_skus_present',
        '_total_quota_value',
        '_total_quota_present',
        '_used_quota_value',
        '_used_quota_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 uid=None,
                 active_skus=None,
                 total_quota=None,
                 used_quota=None):
        self._uid_value = None
        self._uid_present = False
        self._active_skus_value = None
        self._active_skus_present = False
        self._total_quota_value = None
        self._total_quota_present = False
        self._used_quota_value = None
        self._used_quota_present = False
        if uid is not None:
            self.uid = uid
        if active_skus is not None:
            self.active_skus = active_skus
        if total_quota is not None:
            self.total_quota = total_quota
        if used_quota is not None:
            self.used_quota = used_quota

    @property
    def uid(self):
        """
        The user's unique identifier.

        :rtype: long
        """
        if self._uid_present:
            return self._uid_value
        else:
            raise AttributeError("missing required field 'uid'")

    @uid.setter
    def uid(self, val):
        val = self._uid_validator.validate(val)
        self._uid_value = val
        self._uid_present = True

    @uid.deleter
    def uid(self):
        self._uid_value = None
        self._uid_present = False

    @property
    def active_skus(self):
        """
        A list of all currently active SKUs provisioned by Partner.

        :rtype: list of [SkuProvisionInfo]
        """
        if self._active_skus_present:
            return self._active_skus_value
        else:
            raise AttributeError("missing required field 'active_skus'")

    @active_skus.setter
    def active_skus(self, val):
        val = self._active_skus_validator.validate(val)
        self._active_skus_value = val
        self._active_skus_present = True

    @active_skus.deleter
    def active_skus(self):
        self._active_skus_value = None
        self._active_skus_present = False

    @property
    def total_quota(self):
        """
        The user's total quota in their Dropbox, in bytes.

        :rtype: long
        """
        if self._total_quota_present:
            return self._total_quota_value
        else:
            raise AttributeError("missing required field 'total_quota'")

    @total_quota.setter
    def total_quota(self, val):
        val = self._total_quota_validator.validate(val)
        self._total_quota_value = val
        self._total_quota_present = True

    @total_quota.deleter
    def total_quota(self):
        self._total_quota_value = None
        self._total_quota_present = False

    @property
    def used_quota(self):
        """
        The aggregate amount of data in their Dropbox, in bytes. Contains files
        in shared and private folders.

        :rtype: long
        """
        if self._used_quota_present:
            return self._used_quota_value
        else:
            raise AttributeError("missing required field 'used_quota'")

    @used_quota.setter
    def used_quota(self, val):
        val = self._used_quota_validator.validate(val)
        self._used_quota_value = val
        self._used_quota_present = True

    @used_quota.deleter
    def used_quota(self):
        self._used_quota_value = None
        self._used_quota_present = False

    def __repr__(self):
        return 'SpaceUserResult(uid={!r}, active_skus={!r}, total_quota={!r}, used_quota={!r})'.format(
            self._uid_value,
            self._active_skus_value,
            self._total_quota_value,
            self._used_quota_value,
        )

class SpaceUserListResult(object):
    """
    A response containing information about multiple users that the partner
    provisioined SKUs for.

    :ivar users: A list of users. The content of each element is identical to
        the response of space/get.
    :ivar date: The supplied date parameter. Note that the list of users with
        provisioned space may since have changed. Re-use this date when
        paginating to obtain a consistent response across multiple calls to this
        endpoint.
    :ivar page: An integer defining which page of results is displayed. To be
        used in conjunction with has_more.
    :ivar has_more: A boolean value indicating whether or not there are more
        results for pagination. If more results are available, a call to
        space/list with the same date and page incremented by one will yield
        additional results.
    """

    __slots__ = [
        '_users_value',
        '_users_present',
        '_date_value',
        '_date_present',
        '_page_value',
        '_page_present',
        '_has_more_value',
        '_has_more_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 users=None,
                 date=None,
                 page=None,
                 has_more=None):
        self._users_value = None
        self._users_present = False
        self._date_value = None
        self._date_present = False
        self._page_value = None
        self._page_present = False
        self._has_more_value = None
        self._has_more_present = False
        if users is not None:
            self.users = users
        if date is not None:
            self.date = date
        if page is not None:
            self.page = page
        if has_more is not None:
            self.has_more = has_more

    @property
    def users(self):
        """
        A list of users. The content of each element is identical to the
        response of space/get.

        :rtype: list of [SpaceUserResult]
        """
        if self._users_present:
            return self._users_value
        else:
            raise AttributeError("missing required field 'users'")

    @users.setter
    def users(self, val):
        val = self._users_validator.validate(val)
        self._users_value = val
        self._users_present = True

    @users.deleter
    def users(self):
        self._users_value = None
        self._users_present = False

    @property
    def date(self):
        """
        The supplied date parameter. Note that the list of users with
        provisioned space may since have changed. Re-use this date when
        paginating to obtain a consistent response across multiple calls to this
        endpoint.

        :rtype: datetime.datetime
        """
        if self._date_present:
            return self._date_value
        else:
            raise AttributeError("missing required field 'date'")

    @date.setter
    def date(self, val):
        val = self._date_validator.validate(val)
        self._date_value = val
        self._date_present = True

    @date.deleter
    def date(self):
        self._date_value = None
        self._date_present = False

    @property
    def page(self):
        """
        An integer defining which page of results is displayed. To be used in
        conjunction with has_more.

        :rtype: long
        """
        if self._page_present:
            return self._page_value
        else:
            raise AttributeError("missing required field 'page'")

    @page.setter
    def page(self, val):
        val = self._page_validator.validate(val)
        self._page_value = val
        self._page_present = True

    @page.deleter
    def page(self):
        self._page_value = None
        self._page_present = False

    @property
    def has_more(self):
        """
        A boolean value indicating whether or not there are more results for
        pagination. If more results are available, a call to space/list with the
        same date and page incremented by one will yield additional results.

        :rtype: bool
        """
        if self._has_more_present:
            return self._has_more_value
        else:
            raise AttributeError("missing required field 'has_more'")

    @has_more.setter
    def has_more(self, val):
        val = self._has_more_validator.validate(val)
        self._has_more_value = val
        self._has_more_present = True

    @has_more.deleter
    def has_more(self):
        self._has_more_value = None
        self._has_more_present = False

    def __repr__(self):
        return 'SpaceUserListResult(users={!r}, date={!r}, page={!r}, has_more={!r})'.format(
            self._users_value,
            self._date_value,
            self._page_value,
            self._has_more_value,
        )

class SpaceError(object):
    """
    :ivar unknown_uid: There is no user with the supplied `uid`.
    :ivar user_deleted: The account of the user with the supplied `uid` was
        deleted.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = None
    # Attribute is overwritten below the class definition
    unknown_uid = None
    # Attribute is overwritten below the class definition
    user_deleted = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_unknown_uid(self):
        return self._tag == 'unknown_uid'

    def is_user_deleted(self):
        return self._tag == 'user_deleted'

    def __repr__(self):
        return 'SpaceError(%r)' % self._tag

class ListSpaceError(object):
    """
    :ivar future_date: The specified date is in the future.
    """

    __slots__ = ['_tag', '_value']

    _catch_all = None
    # Attribute is overwritten below the class definition
    future_date = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_future_date(self):
        return self._tag == 'future_date'

    def __repr__(self):
        return 'ListSpaceError(%r)' % self._tag

class SpaceErrorWithSkuId(SpaceError):
    """
    Both space/provision as well as space/disable can return `invalid_sku_id`.

    :ivar invalid_sku_id: The supplied `sku_id` is not valid for this partner.
    """

    __slots__ = ['_tag', '_value']

    # Attribute is overwritten below the class definition
    invalid_sku_id = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_invalid_sku_id(self):
        return self._tag == 'invalid_sku_id'

    def __repr__(self):
        return 'SpaceErrorWithSkuId(%r)' % self._tag

class ProvisionSpaceError(SpaceErrorWithSkuId):
    """
    :ivar invalid_country_code: The supplied `SpaceProvisionArg.country_code` is
        invalid.
    :ivar not_eligible: The user is not eligible for the supplied sku_id.
    """

    __slots__ = ['_tag', '_value']

    # Attribute is overwritten below the class definition
    invalid_country_code = None
    # Attribute is overwritten below the class definition
    not_eligible = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_invalid_country_code(self):
        return self._tag == 'invalid_country_code'

    def is_not_eligible(self):
        return self._tag == 'not_eligible'

    def __repr__(self):
        return 'ProvisionSpaceError(%r)' % self._tag

class DisableSpaceError(SpaceErrorWithSkuId):
    """
    :ivar invalid_user_id: The supplied `SpaceDisableArg.user_id` is invalid.
    :ivar invalid_instance_id: The supplied `SpaceDisableArg.instance_id` is
        invalid.
    """

    __slots__ = ['_tag', '_value']

    # Attribute is overwritten below the class definition
    invalid_user_id = None
    # Attribute is overwritten below the class definition
    invalid_instance_id = None

    def __init__(self, tag, value=None):
        assert tag in self._tagmap, 'Invalid tag %r.' % tag
        validator = self._tagmap[tag]
        if isinstance(validator, bv.Void):
            assert value is None, 'Void type union member must have None value.'
        elif isinstance(validator, (bv.Struct, bv.Union)):
            validator.validate_type_only(value)
        else:
            validator.validate(value)
        self._tag = tag
        self._value = value

    def is_invalid_user_id(self):
        return self._tag == 'invalid_user_id'

    def is_invalid_instance_id(self):
        return self._tag == 'invalid_instance_id'

    def __repr__(self):
        return 'DisableSpaceError(%r)' % self._tag

TeamSuspensionState._active_validator = bv.Void()
TeamSuspensionState._suspended_validator = bv.Void()
TeamSuspensionState._deleted_validator = bv.Void()
TeamSuspensionState._tagmap = {
    'active': TeamSuspensionState._active_validator,
    'suspended': TeamSuspensionState._suspended_validator,
    'deleted': TeamSuspensionState._deleted_validator,
}

TeamSuspensionState.active = TeamSuspensionState('active')
TeamSuspensionState.suspended = TeamSuspensionState('suspended')
TeamSuspensionState.deleted = TeamSuspensionState('deleted')

TeamWithState._num_licensed_users_validator = bv.UInt32()
TeamWithState._num_provisioned_users_validator = bv.UInt32()
TeamWithState._all_field_names_ = users.Team._all_field_names_.union(set([
    'num_licensed_users',
    'num_provisioned_users',
]))
TeamWithState._all_fields_ = users.Team._all_fields_ + [
    ('num_licensed_users', TeamWithState._num_licensed_users_validator),
    ('num_provisioned_users', TeamWithState._num_provisioned_users_validator),
]

TeamWithStateList._teams_validator = bv.List(bv.Struct(TeamWithState))
TeamWithStateList._all_field_names_ = set(['teams'])
TeamWithStateList._all_fields_ = [('teams', TeamWithStateList._teams_validator)]

CreateTeamArg._name_validator = bv.String(min_length=2, max_length=20, pattern=u'^\\S+.*\\S+$')
CreateTeamArg._num_licensed_users_validator = bv.UInt32()
CreateTeamArg._sku_validator = bv.UInt32()
CreateTeamArg._invite_admin_validator = bv.String(pattern=u'^[^@]+@[^@]+\\.[^@]+$')
CreateTeamArg._default_language_code_validator = bv.Nullable(bv.String(min_length=2))
CreateTeamArg._all_field_names_ = set([
    'name',
    'num_licensed_users',
    'sku',
    'invite_admin',
    'default_language_code',
])
CreateTeamArg._all_fields_ = [
    ('name', CreateTeamArg._name_validator),
    ('num_licensed_users', CreateTeamArg._num_licensed_users_validator),
    ('sku', CreateTeamArg._sku_validator),
    ('invite_admin', CreateTeamArg._invite_admin_validator),
    ('default_language_code', CreateTeamArg._default_language_code_validator),
]

CreateTeamError._num_licensed_users_not_allowed_validator = bv.Void()
CreateTeamError._no_sku_validator = bv.Void()
CreateTeamError._no_default_language_code_validator = bv.Void()
CreateTeamError._team_license_limit_validator = bv.Void()
CreateTeamError._user_already_on_team_validator = bv.Void()
CreateTeamError._user_on_another_team_validator = bv.Void()
CreateTeamError._user_already_paired_validator = bv.Void()
CreateTeamError._user_migration_failed_validator = bv.Void()
CreateTeamError._cannot_invite_admin_validator = bv.String()
CreateTeamError._unknown_validator = bv.Void()
CreateTeamError._tagmap = {
    'num_licensed_users_not_allowed': CreateTeamError._num_licensed_users_not_allowed_validator,
    'no_sku': CreateTeamError._no_sku_validator,
    'no_default_language_code': CreateTeamError._no_default_language_code_validator,
    'team_license_limit': CreateTeamError._team_license_limit_validator,
    'user_already_on_team': CreateTeamError._user_already_on_team_validator,
    'user_on_another_team': CreateTeamError._user_on_another_team_validator,
    'user_already_paired': CreateTeamError._user_already_paired_validator,
    'user_migration_failed': CreateTeamError._user_migration_failed_validator,
    'cannot_invite_admin': CreateTeamError._cannot_invite_admin_validator,
    'unknown': CreateTeamError._unknown_validator,
}

CreateTeamError.num_licensed_users_not_allowed = CreateTeamError('num_licensed_users_not_allowed')
CreateTeamError.no_sku = CreateTeamError('no_sku')
CreateTeamError.no_default_language_code = CreateTeamError('no_default_language_code')
CreateTeamError.team_license_limit = CreateTeamError('team_license_limit')
CreateTeamError.user_already_on_team = CreateTeamError('user_already_on_team')
CreateTeamError.user_on_another_team = CreateTeamError('user_on_another_team')
CreateTeamError.user_already_paired = CreateTeamError('user_already_paired')
CreateTeamError.user_migration_failed = CreateTeamError('user_migration_failed')
CreateTeamError.unknown = CreateTeamError('unknown')

GetTeamArg._id_validator = bv.String()
GetTeamArg._all_field_names_ = set(['id'])
GetTeamArg._all_fields_ = [('id', GetTeamArg._id_validator)]

GetTeamError._no_team_validator = bv.Void()
GetTeamError._unknown_validator = bv.Void()
GetTeamError._tagmap = {
    'no_team': GetTeamError._no_team_validator,
    'unknown': GetTeamError._unknown_validator,
}

GetTeamError.no_team = GetTeamError('no_team')
GetTeamError.unknown = GetTeamError('unknown')

ModifyLicensesArg._current_num_licensed_users_validator = bv.UInt32()
ModifyLicensesArg._new_num_licensed_users_validator = bv.UInt32()
ModifyLicensesArg._all_field_names_ = GetTeamArg._all_field_names_.union(set([
    'current_num_licensed_users',
    'new_num_licensed_users',
]))
ModifyLicensesArg._all_fields_ = GetTeamArg._all_fields_ + [
    ('current_num_licensed_users', ModifyLicensesArg._current_num_licensed_users_validator),
    ('new_num_licensed_users', ModifyLicensesArg._new_num_licensed_users_validator),
]

ModifyLicensesError._incorrect_current_num_licensed_users_validator = bv.Void()
ModifyLicensesError._new_num_licensed_users_not_allowed_validator = bv.Void()
ModifyLicensesError._tagmap = {
    'incorrect_current_num_licensed_users': ModifyLicensesError._incorrect_current_num_licensed_users_validator,
    'new_num_licensed_users_not_allowed': ModifyLicensesError._new_num_licensed_users_not_allowed_validator,
}
ModifyLicensesError._tagmap.update(GetTeamError._tagmap)

ModifyLicensesError.incorrect_current_num_licensed_users = ModifyLicensesError('incorrect_current_num_licensed_users')
ModifyLicensesError.new_num_licensed_users_not_allowed = ModifyLicensesError('new_num_licensed_users_not_allowed')

SpaceGetArg._uid_validator = bv.UInt64()
SpaceGetArg._all_field_names_ = set(['uid'])
SpaceGetArg._all_fields_ = [('uid', SpaceGetArg._uid_validator)]

SpaceListArg._date_validator = bv.Timestamp(u'%Y-%m-%dT%H:%M:%SZ')
SpaceListArg._page_validator = bv.Nullable(bv.UInt64())
SpaceListArg._all_field_names_ = set([
    'date',
    'page',
])
SpaceListArg._all_fields_ = [
    ('date', SpaceListArg._date_validator),
    ('page', SpaceListArg._page_validator),
]

SpaceProvisionArg._uid_validator = bv.UInt64()
SpaceProvisionArg._partner_uid_validator = bv.String()
SpaceProvisionArg._sku_id_validator = bv.UInt64()
SpaceProvisionArg._country_code_validator = bv.String(min_length=2, max_length=2)
SpaceProvisionArg._all_field_names_ = set([
    'uid',
    'partner_uid',
    'sku_id',
    'country_code',
])
SpaceProvisionArg._all_fields_ = [
    ('uid', SpaceProvisionArg._uid_validator),
    ('partner_uid', SpaceProvisionArg._partner_uid_validator),
    ('sku_id', SpaceProvisionArg._sku_id_validator),
    ('country_code', SpaceProvisionArg._country_code_validator),
]

SpaceDisableArg._uid_validator = bv.UInt64()
SpaceDisableArg._instance_id_validator = bv.String()
SpaceDisableArg._sku_id_validator = bv.UInt64()
SpaceDisableArg._all_field_names_ = set([
    'uid',
    'instance_id',
    'sku_id',
])
SpaceDisableArg._all_fields_ = [
    ('uid', SpaceDisableArg._uid_validator),
    ('instance_id', SpaceDisableArg._instance_id_validator),
    ('sku_id', SpaceDisableArg._sku_id_validator),
]

SkuProvisionState._awaiting_requirement_validator = bv.Void()
SkuProvisionState._active_validator = bv.Void()
SkuProvisionState._tagmap = {
    'awaiting_requirement': SkuProvisionState._awaiting_requirement_validator,
    'active': SkuProvisionState._active_validator,
}

SkuProvisionState.awaiting_requirement = SkuProvisionState('awaiting_requirement')
SkuProvisionState.active = SkuProvisionState('active')

SkuProvisionInfo._instance_id_validator = bv.String()
SkuProvisionInfo._sku_id_validator = bv.UInt64()
SkuProvisionInfo._country_code_validator = bv.String(min_length=2, max_length=2)
SkuProvisionInfo._provisioned_date_validator = bv.Timestamp(u'%Y-%m-%dT%H:%M:%SZ')
SkuProvisionInfo._activated_date_validator = bv.Nullable(bv.Timestamp(u'%Y-%m-%dT%H:%M:%SZ'))
SkuProvisionInfo._end_date_validator = bv.Nullable(bv.Timestamp(u'%Y-%m-%dT%H:%M:%SZ'))
SkuProvisionInfo._state_validator = bv.Union(SkuProvisionState)
SkuProvisionInfo._all_field_names_ = set([
    'instance_id',
    'sku_id',
    'country_code',
    'provisioned_date',
    'activated_date',
    'end_date',
    'state',
])
SkuProvisionInfo._all_fields_ = [
    ('instance_id', SkuProvisionInfo._instance_id_validator),
    ('sku_id', SkuProvisionInfo._sku_id_validator),
    ('country_code', SkuProvisionInfo._country_code_validator),
    ('provisioned_date', SkuProvisionInfo._provisioned_date_validator),
    ('activated_date', SkuProvisionInfo._activated_date_validator),
    ('end_date', SkuProvisionInfo._end_date_validator),
    ('state', SkuProvisionInfo._state_validator),
]

SpaceUserResult._uid_validator = bv.UInt64()
SpaceUserResult._active_skus_validator = bv.List(bv.Struct(SkuProvisionInfo))
SpaceUserResult._total_quota_validator = bv.UInt64()
SpaceUserResult._used_quota_validator = bv.UInt64()
SpaceUserResult._all_field_names_ = set([
    'uid',
    'active_skus',
    'total_quota',
    'used_quota',
])
SpaceUserResult._all_fields_ = [
    ('uid', SpaceUserResult._uid_validator),
    ('active_skus', SpaceUserResult._active_skus_validator),
    ('total_quota', SpaceUserResult._total_quota_validator),
    ('used_quota', SpaceUserResult._used_quota_validator),
]

SpaceUserListResult._users_validator = bv.List(bv.Struct(SpaceUserResult))
SpaceUserListResult._date_validator = bv.Timestamp(u'%Y-%m-%dT%H:%M:%SZ')
SpaceUserListResult._page_validator = bv.UInt64()
SpaceUserListResult._has_more_validator = bv.Boolean()
SpaceUserListResult._all_field_names_ = set([
    'users',
    'date',
    'page',
    'has_more',
])
SpaceUserListResult._all_fields_ = [
    ('users', SpaceUserListResult._users_validator),
    ('date', SpaceUserListResult._date_validator),
    ('page', SpaceUserListResult._page_validator),
    ('has_more', SpaceUserListResult._has_more_validator),
]

SpaceError._unknown_uid_validator = bv.Void()
SpaceError._user_deleted_validator = bv.Void()
SpaceError._tagmap = {
    'unknown_uid': SpaceError._unknown_uid_validator,
    'user_deleted': SpaceError._user_deleted_validator,
}

SpaceError.unknown_uid = SpaceError('unknown_uid')
SpaceError.user_deleted = SpaceError('user_deleted')

ListSpaceError._future_date_validator = bv.Void()
ListSpaceError._tagmap = {
    'future_date': ListSpaceError._future_date_validator,
}

ListSpaceError.future_date = ListSpaceError('future_date')

SpaceErrorWithSkuId._invalid_sku_id_validator = bv.Void()
SpaceErrorWithSkuId._tagmap = {
    'invalid_sku_id': SpaceErrorWithSkuId._invalid_sku_id_validator,
}
SpaceErrorWithSkuId._tagmap.update(SpaceError._tagmap)

SpaceErrorWithSkuId.invalid_sku_id = SpaceErrorWithSkuId('invalid_sku_id')

ProvisionSpaceError._invalid_country_code_validator = bv.Void()
ProvisionSpaceError._not_eligible_validator = bv.Void()
ProvisionSpaceError._tagmap = {
    'invalid_country_code': ProvisionSpaceError._invalid_country_code_validator,
    'not_eligible': ProvisionSpaceError._not_eligible_validator,
}
ProvisionSpaceError._tagmap.update(SpaceErrorWithSkuId._tagmap)

ProvisionSpaceError.invalid_country_code = ProvisionSpaceError('invalid_country_code')
ProvisionSpaceError.not_eligible = ProvisionSpaceError('not_eligible')

DisableSpaceError._invalid_user_id_validator = bv.Void()
DisableSpaceError._invalid_instance_id_validator = bv.Void()
DisableSpaceError._tagmap = {
    'invalid_user_id': DisableSpaceError._invalid_user_id_validator,
    'invalid_instance_id': DisableSpaceError._invalid_instance_id_validator,
}
DisableSpaceError._tagmap.update(SpaceErrorWithSkuId._tagmap)

DisableSpaceError.invalid_user_id = DisableSpaceError('invalid_user_id')
DisableSpaceError.invalid_instance_id = DisableSpaceError('invalid_instance_id')

