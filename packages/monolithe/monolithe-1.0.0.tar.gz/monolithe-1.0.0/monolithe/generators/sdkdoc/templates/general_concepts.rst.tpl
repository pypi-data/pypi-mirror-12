General Concepts
================


Introduction
------------

`{{ sdk_name }}` provides a set of objects that allow the manipulation of {{ product_name }} entities very easily. It deals with all possible CRUD operations. It is based on the library `Bambou`, which defines all these low level operations in a single place.

You will never use `Bambou` directly when working with `{{ sdk_name }}`. However, you need to understand the basics of this library because this is where all the concepts are defined. `{{ sdk_name }}` objects are simple autogenerated objects that all inherit from the same `Bambou` class and so, they all work the same.

`Bambou` is composed of the following important classes:

* `NURESTSession`_
    Class representing an authenticated session.

* `NURESTObject`_
    Parent class of all ReST entities. All `{{ sdk_name }}` objects inherit from this class.

* `NURESTFetcher`_
    Class used to get children of a :class:`bambou.NURESTObject`.

* `NURESTPushCenter`_
    Class that deals with intercepting and rerouting {{ product_name }} ReST Push Notifications.

.. note:: There are more objects in `Bambou`, but you don't need to know all of them for now.



NURESTSession
-------------

The :class:`bambou.NURESTSession` represents some user credentials coupled with an API URL. All ReST calls are done using the current active session. :class:`bambou.NURESTSession` is an abstract class that must be reimplemented by anything using `Bambou`.

In `{{ sdk_name }}`, you use a class named :class:`{sdk_name }}.v3_2.{{ sdk_class_prefix }}{{ product_accronym }}Session` which will be used in the following examples.


.. code-block:: python
    :linenos:

    session = {{ sdk_class_prefix }}{{ product_accronym }}Session(username="user", password="secret", enterprise="organization", api_url="https://{{ product_name|lower }}:8443")
    session.start()

    # your script

.. note:: Since August 2015, it is no longer necessary to provide the API version parameter. `vpsk` will automatically grab it from the `{{ sdk_name }}` you are using.

When you start the session, a ReST call will be sent to the API endpoint in order to get the {{ product_name }} API key. If the credentials are valid, the attribute :attr:`{{ sdk_name }}.v3_2.{{ sdk_class_prefix }}{{ product_accronym }}Session.user` will be populated with information such as your name, your phone number, your avatar, your enterprise name and ID etc. This `user` is the root object of everything as all subsequent calls need to be done in the context of your account (for instance, your `/enterprises` are different from another account's `/enterprises`)

It is also possible to create sub sessions with the python statement `with`:

.. code-block:: python
    :linenos:

    cspsession = {{ sdk_class_prefix }}{{ product_accronym }}Session(username="user", password="secret", enterprise="organization", api_url="https://{{ product_name|lower }}:8443")
    adminsession = {{ sdk_class_prefix }}{{ product_accronym }}Session(username="admin", password="secret", enterprise="enterprise", api_url="https://{{ product_name|lower }}:8443")

    cspsession.start()

    # this part of the code will use the CSP root user

    with adminsession.start():
        # this code block will be executed as admin of `enterprise`

    # back to csp root session

.. note:: You **must** use `start()` when using the `with` statement, even if the session has already been started in the main context.



NURESTObject
------------

:class:`bambou.NURESTObject` is the parent class of all `{{ sdk_name }}` entities.


ReST Names
++++++++++

All :class:`bambou.NURESTObject` subclasses implements a given method that will return the actual ReST name of the objects. For instance, the ReST name of an Unicorn object is `unicorn`.

These names are used to forge the correct URI when doing CRUD operations on them.

.. note:: ReST names can be used as unique resource identifier for a given object.

.. note:: ReST names are auto generated. You never need to manually define them.


ReST API URI Generation
+++++++++++++++++++++++

:class:`bambou.NURESTObject` is able to forge all the URI needed to interact with the server through the ReST API.

For instance, if an object with a ReST name set to `object` needs to get the list of children with ReST name set to `subobject`, `Bambou` will use the following endpoint URL:

    `GET {api_base_url}/objects/{id}/subobjects`

If an object with a ReST name set to `entity` needs to fetch itself, the generated URL will be

    `GET {api_base_url}/entities/{id}`


.. note:: `Bambou` automagically deals with plurals.

.. note:: The ReST base URL is pulled from the current active :class:`bambou.NURESTSession`.

.. note:: URI are auto generated. You never need to deal with them manually.


Exposing ReST Attributes
++++++++++++++++++++++++

Exposed attributes will be converted and sent to the server when you do CRUD operations. That way, if an object has an attribute :py:attr:`name`, it can be marked as a ReST attribute.

When saving the object, the value of :py:attr:`name` will be put into the generated JSON structure that will be sent to the server, or automatically populated from a JSON structure that is coming from the server.

Not only the attribute can be exposed, but also its type and other informations like if it is read only, its allowed values, its format, its default value and so on.

.. note:: exposing ReST Attributes is auto generated. You never need to manually expose new attributes.


CRUD Operations
+++++++++++++++

:class:`bambou.NURESTObject` allows to perform all sorts of CRUD operations.

.. automethod:: bambou.NURESTObject.fetch
    :noindex:

.. automethod:: bambou.NURESTObject.save
    :noindex:

.. automethod:: bambou.NURESTObject.delete
    :noindex:

.. automethod:: bambou.NURESTObject.create_child
    :noindex:

.. automethod:: bambou.NURESTObject.assign
    :noindex:

.. automethod:: bambou.NURESTObject.instantiate_child
    :noindex:


.. note:: All these methods require the current :class:`bambou.NURESTObject` to have a valid :attr:`bambou.NURESTObject.ID`.

.. note:: You may notice that there is no creation method. Creation is always happening from a parent object and is done using `create_child`.

.. note:: You may notice that an optional parameter :py:attr:`callback` is present. This is because `{{ sdk_name }}` can work completely asynchronously.



Converting to and from a Python Dictionary
++++++++++++++++++++++++++++++++++++++++++

:class:`bambou.NURESTObject` allows quick and easy conversion from and to python dictionaries

.. automethod:: bambou.NURESTObject.from_dict
    :noindex:

.. automethod:: bambou.NURESTObject.to_dict
    :noindex:

.. note:: you never need to process to the actual JSON conversion when sending info to the server. :class:`bambou.NURESTConnection` will do that automatically, but you can use these methods to print an object, or copy information of an object into one another.



NURESTFetcher
-------------

:class:`bambou.NURESTFetcher` is a class allowing a :class:`bambou.NURESTObject` to fetch its children. All :class:`bambou.NURESTObject` have one or more fetchers, unless it's a final object in the {{ product_name }} model hierarchy. :class:`bambou.NURESTFetcher` provides a lot of possibility regarding the way you want to get a given children list. It can deal with simple object fetching, pagination, filtering, request headers, grouping etc.


Fetching Children List
++++++++++++++++++++++

:class:`bambou.NURESTFetcher` has three importants methods:

.. automethod:: bambou.NURESTFetcher.fetch
    :noindex:

.. automethod:: bambou.NURESTFetcher.get
    :noindex:

.. automethod:: bambou.NURESTFetcher.get_first
    :noindex:


Discussion about Fetchers
+++++++++++++++++++++++++

Fetcher is a powerfull concept that makes the process of getting child objects completely generic and code friendly. :class:`bambou.NURESTObject` provides methods that allow to deal programatically with its fetchers in a completely generic way.

.. automethod:: bambou.NURESTObject.fetcher_for_rest_name
    :noindex:

.. autoattribute:: bambou.NURESTObject.fetchers
    :noindex:

.. autoattribute:: bambou.NURESTObject.children_rest_names
    :noindex:


This allows complete abstract programatic operations on any objects.

For instance, the following function will create a new :class:`{{ sdk_name }}.v3_2.{{ sdk_class_prefix }}Metadata` to the entire hierarchy of children from a given object that has been created after a certain date:

.. code-block:: python
    :linenos:

    def apply_metatada_to_all_children(root_object, metadata, filter=None):

        # Loop on all declared children fetchers
        for fetcher in root_object.fetchers:

            # Fetch the list of the children
            children = fetcher.get(filter=filter)

            # Loop on all fetched children
            for child in children:

                # Add the metadata to the current children
                child.create_child(metadata)

                # Start over recursively on the children of the current child
                apply_metadata_to_all_children(child, metadata)


    enterprise = {{ sdk_class_prefix }}Enterprise(id="xxxx-xxxx-xxx-xxxx")
    metadata = {{ sdk_class_prefix }}Metadata(name="my metadata", blob="hello world!")

    apply_metadata_to_all_children(enterprise, metadata, filter="creationDate > '01-01-2015'")



NURESTPushCenter
----------------

The {{ product_name }} API supports client side push through a long polling connection. ReST clients can connect to that channel and will get a notification as soon as he or someone else in the system changes something. This events are filtered by permissions, which means that if someone change a property of an object you cannot see, you won't get notified. `{{ sdk_name }}` provides the :class:`bambou.NURESTPushCenter`, which encapsulates all the logic to deal with the event channel. It runs in its own thread and will call registered callbacks when it receives a push.

A :class:`bambou.NURESTPushCenter` is automatically created with each :class:`bambou.NURESTSession` and it is available from the attribute :attr:`bambou.NURESTSession.push_center`.

.. code-block:: python
    :linenos:

    session = {{ sdk_class_prefix }}{{ product_accronym }}Session(username="user", password="secret", enterprise="organization", api_url="https://{{ product_name|lower }}:8443")
    session.start()
    session.push_center.start()


.. note:: You need to explicitely start the push center.


Using the NURESTPushCenter
++++++++++++++++++++++++++

Only the following methods are important:

.. automethod:: bambou.NURESTPushCenter.start
    :noindex:

.. automethod:: bambou.NURESTPushCenter.add_delegate
    :noindex:

.. automethod:: bambou.NURESTPushCenter.remove_delegate
    :noindex:


Example
+++++++

Here is a really simple code sample that will print the push data on every push:

.. code-block:: python
    :linenos:

    from {{ sdk_name }} import *
    from pprint import pprint
    from time import sleep

    session = {{ sdk_class_prefix }}{{ product_accronym }}Session(username="csproot", password="secret", enterprise="csp", api_url="https://{{ product_name|lower }}:8443")
    session.start()

    def on_receive_push(data):
        pprint(data);

    session.push_center.add_delegate(on_receive_push);
    session.push_center.start()

    # default stupid run loop. don't do that in real life :)
    while True:
        sleep(1000)



Conclusion
----------

Now you know the basics of `Bambou` and so, of the `{{ sdk_name }}`. Remember that all objects in `{{ sdk_name }}` are subclasses of :class:`bambou.NURESTObject` so they **all** work exactly the same.

There is a lot more to know about `Bambou` like the asynchronous mode, auto model parsing, easy controllers creation thanks introspection and so on. We'll cover this in a different advanced section.
