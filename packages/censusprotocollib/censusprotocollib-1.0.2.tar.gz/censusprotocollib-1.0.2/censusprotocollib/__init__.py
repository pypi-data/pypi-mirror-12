__author__ = 'lpreimesberger'
import census
import crypto
import urllib2
import time
import json
import pybitcointools
import requests
import Crypto
from Crypto import Random
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import uuid
import base64

headers = {'Content-type': 'application/json', 'Accept': 'text/plain'}
now_ms = lambda: int(round(time.time() * 1000))
serialize = lambda json_data: json.dumps( json_data, sort_keys=True, separators=(',',':') )

def generate_wallet( my_seed_data, my_email="" ):
    """ create a new empty wallet - does not post it.  this is a VERY EXPENSIVE operation and has your private keys
    :param my_seed_data: seed for the wallet - this should be a big random block, but as always...
    :return: object containing, public, private, and address info in cwif format
    """
    new_wallet = {}
    hash_of_seed = pybitcointools.sha256(my_seed_data)
    new_wallet["public"] = pybitcointools.privkey_to_pubkey(hash_of_seed)
    new_wallet["private"] = hash_of_seed;
    new_wallet["email"] = my_email
    new_wallet["address"] = pybitcointools.pubtoaddr( new_wallet["public"])
    new_wallet["rsa_keys"] = []
    random_generator = Random.new().read
    encryption_key = RSA.generate(2048, random_generator)
    new_rsa_set = {}
    new_rsa_set["private"] = encryption_key.exportKey()
    new_rsa_set["public"]  = encryption_key.publickey().exportKey()
    new_wallet["rsa_keys"].append(new_rsa_set)
    return new_wallet

def cwif_to_wallet( cwif_data ):
    """ transforms the cwif data into a valid census object for passing up to the server
    :param cwif_data:
    :return: wallet object
    """
    return_data = {};
    # do everything manually so it's obvious what's what
    return_data["version"] = 1
    return_data["txid"]    = str(uuid.uuid4())
    return_data["created"] = census.now_ms()+0
    return_data["item_type"]= "wallet"
    return_data["source"] = cwif_data["address"]
    return_data["tag"]    = "generated by censusprotocollib"
    return_data["email"]  = cwif_data["email"]
    return_data["rsa_keys"] = []
    return_data["block_in"] = ""
    return_data["signature"] = ""
    return_data["rsa_keys"].append( cwif_data["rsa_keys"][0]["public"] )
    return_data["balance"] = 0
    return return_data

def version( host ):
    """ get the version block from the given server
    :param host: host to connect to
    :return: json data for that host or raises exception
    """
    url = 'http://{}:9000/api/v1/version'.format(host)
    # let it throw exception on fail and bubble up
    return urllib2.urlopen(url).read()


def sign( json_data, private_key ):
    """ sign the json info - returning the json object modified
    :param json_data: what to sign
    :param private_key: ecdsa key to use
    :return: updated json_data.  signature replaced with new signature
    """
    # clear if present
    json_data['signature'] = ""
    # sort and normalize the json data
    theString = json.dumps( json_data, sort_keys=True, separators=(',',':') )
    print "signing\n" + theString
    signature = pybitcointools.ecdsa_sign( theString, private_key )
    json_data['signature'] = signature
    print "signed!!!"
    print json_data
    print "signed!!!"
    return json_data


def check( json_data, public_key ):
    """ implementing the bitcoin.message.sign using the address is horrible in python
    i linked in a tiny library in crypto from electrum - but the bitcoin way assumes you
    only can add 255 bytes to the message since there's a pascal-style string at the front.
    this requires a wallet PUBLIC KEY - the web client is happy with the address
    :param json_data: data to check
    :param public_key: ecdsa encoded PUBLIC KEY - not the address
    :return: true or false
    """
    # clear if present
    the_signature = json_data['signature']
    json_data['signature'] = ""
    # sort and normalize the json data
    theString = json.dumps( json_data, sort_keys=True, separators=(',',':') )
    is_okay = pybitcointools.ecdsa_verify( theString, the_signature, public_key )
    return is_okay


def vend( host, json_data ):
    """ send this json to the host as a vend transaction
    :param host: host to connect to
    :param json_data: data to send.  must be signed
    :return: server response - normally json
    """
    r = requests.post(
        "http://{}:9000/api/v1/vend".format(host),
        headers=headers,
        data=serialize(json_data)
    )
    return r.text

def item( host, json_data ):
    """ send this json to the host as a item transaction
    :param host: host to connect to
    :param json_data: data to send.  must be signed
    :return: server response - normally json
    """
    r = requests.post(
        "http://{}:9000/api/v1/item".format(host),
        headers=headers,
        data=serialize(json_data)
    )
    return r.text

def items_from_venue( host, venue ):
    """ find items from this venue - capped, but at least 50
    :param host: host to connect to
    :param json_data: data to send.  must be signed
    :return: server response - normally json
    """
    r = requests.get(
        "http://{}:9000/api/v1/item/venue/{}".format(host, venue),
        headers=headers

    )
    return r.text

def items_from_location( host, lat, lon, distance_km ):
    """ get items around a certain point
    :param host:
    :param lat: latitude
    :param lon: longitude
    :param distance_km: how far away in km
    :return: listing
    """
    r = requests.get(
        "http://{}:9000/api/v1/item/geo/{}/{}/{}".format(host, lat, lon, distance_km),
        headers=headers

    )
    return r.text

def get_item( host, txid ):
    """ returns current state for this item
    :param host: host to connect to
    :param txid: data to send.  must be signed
    :return: server response - normally json
    """
    r = requests.get(
        "http://{}:9000/api/v1/item/{}".format(host, txid ),
        headers=headers

    )
    return r.text



def buy( host, json_data ):
    """ send this json to the host as a buy transaction
    :param host: host to connect to
    :param json_data: data to send.  must be signed
    :return: server response - normally json
    """
    r = requests.post(
        "http://{}:9000/api/v1/buy".format(host),
        headers=headers,
        data=serialize(json_data)
    )
    return r.text


def wallet( host, json_data ):
    """ send this json to the host as a wallet create transaction
    :param host: host to connect to
    :param json_data: the wallet create data
    :return: server response - normally json
    """

    r = requests.post(
        "http://{}:9000/api/v1/wallet".format(host ),
        headers=headers,
        data=serialize(json_data)
    )
    return r.text

def get_wallet( host, wallet_id ):
    """ get the information for a given wallet
    :param host: host to connect to
    :param wallet_id: the wallet uuid
    :return: server response - normally json
    """
    r = requests.get(
        "http://{}:9000/api/v1/wallet/{}".format(host, wallet_id),
        headers=headers
    )
    if r.status_code != 200:
        print "Warning - server has responded with error code " + str(r.status_code)
    return r.text

def get_wallet_by_email( host, wallet_id ):
    """ get the information for a given wallet
    :param host: host to connect to
    :param wallet_id: the wallet uuid
    :return: server response - normally json
    """
    r = requests.get(
        "http://{}:9000/api/v1/wallet/email/{}".format(host, wallet_id),
        headers=headers
    )
    if r.status_code != 200:
        print "Warning - server has responded with error code " + str(r.status_code)
    return r.text


def get_owned_items( host, wallet_id ):
    """ get the items owned by this user
    :param host: host to connect to
    :param wallet_id: the wallet uuid
    :return: server response - normally json
    """
    r = requests.get(
        "http://{}:9000/api/v1/wallet/owned/{}".format(host, wallet_id),
        headers=headers
    )
    return r.text

def rsa_encode( public_key, data ):
    the_key = RSA.importKey( public_key )
    cipher = PKCS1_OAEP.new(the_key)
    ciphertext = base64.b64encode(cipher.encrypt(data))
    return ciphertext