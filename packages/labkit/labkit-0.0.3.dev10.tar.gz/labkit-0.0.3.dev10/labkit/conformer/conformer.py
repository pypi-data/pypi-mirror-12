#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author  : lhr (airhenry@gmail.com)
# @Link    : http://about.me/air.henry

'''
开发基础组件和算法的时候, 全部import base_conformer,
如果需要别的模块的时候, 再import进来别的模块, 需要什么import什么
不要直接import conformer类, 只有在最外层功能实现的时候, 采用成品.

整体的架构以名词(数据)为核心, conformer, ensemble, 可以动态的加载模块.
实现开发测试模块化, 运行整体化, 解耦并且合体

解耦一个是要实现开发的解耦, 还有一个是实现不相关的独立的运行时之间用SOA解耦.
聚合是要把需要的功能封装, 内部要内聚. 不要放多余的功能在外部. 同时内部开发模块化.
有聚合才有分离. 就像聚类一样.

上面是错误的, 现在用全面面向对象实现. 不用monkey patch
'''

from Bio.SVDSuperimposer import SVDSuperimposer

## 解决utf8的问题
import  six
from copy import deepcopy

from general.monkey_patch import as_method_of


from general import gs
log=gs.get_logger(__name__,debug=True)


import yaml



from general.gs import cfg

OPTS = [
    cfg.FloatOpt('rmsd_range',
                 default=0.2,
                 help='two conformers rmsd range to be treated as the same'),
    ]

gs.CONF.register_opts(OPTS)

if six.PY2:
    import sys
    reload(sys)
    sys.setdefaultencoding('utf8')

import subprocess

MAX_CONFORMER_SIZE=100; #最大能处理的构型原子数
MAX_FREEDOM_NUMBER=20; #自由度个数最大值（可旋转的键的最大数）
MAX_FREEDOM=9; #自由度最大值
MAX_SIDE_CORRECTION=3; #单边调整的最大次数
DEFAULT_FOLDER="GaussionFiles"; #默认构型输出文件夹
LOGFILE_NAME="GenerateConformer.log"; #默认日志文件名
PM3_OPT="#pm3 opt \n\nGenerated by CConformer \n\n0 1\n"; #PM3优化的文件开头
from sh import ErrorReturnCode
import math
PI=math.pi
HbondLen_NHN=2.8; #氢键键长NH-N
HbondLen_NHO=2.8; #氢键键长NH-O
HbondLen_OHN=2.8; #氢键键长OH-N
HbondLen_OHO=2.8; #氢键键长OH-O
HbondEn_NHN=3.1; #氢键能NH-N
HbondEn_NHO=1.9; #氢键能NH-O
HbondEn_OHN=6.9; #氢键能OH-N
HbondEn_OHO=5.0; #氢键能OH-O
HbondAng=PI*100/180; #氢键键角最小值

MIN_ELEMENT_DISTANCE=0.0;
H_RADIUS=0.365;
C_RADIUS=0.885;
O_RADIUS=0.84;
N_RADIUS=0.86;
P_RADIUS=1.22;
S_RADIUS=1.17;


UN_CACULATED_ENERGY=100000000

import os, re
from general import reflection
from Bio.PDB.Polypeptide import *
import math
import StringIO
from Bio.PDB.Vector import *
from Bio.PDB.NeighborSearch import NeighborSearch
import pandas as pd

from Bio.PDB.Residue import Residue
from Bio.PDB.Atom import Atom

##### 初始化常量
# MIN_ELEMENT_DISTANCE=0.0;
# H_RADIUS=0.365;
# C_RADIUS=0.885;
# O_RADIUS=0.84;
# N_RADIUS=0.86;
# P_RADIUS=1.22;
# S_RADIUS=1.17;


###### 如果有原子对满足以下两条: 非成键, 间距小于判据[两原子原子半径之和加上允许的原子间空白距离:键长], 则非法
DISTANCE_SEARCH_RANGE=1.6  # 合法性判断的搜索范围, 单位A
MIN_SPACE_DISTANCE=0       # 允许的原子半径之间的空白距离
# 原子半径
ELEMENT_RADIUS_DICT={
    'H':0.365,
    'C':0.885,
    'O':0.84,
    'N':0.86,
    'P':1.22,
    'S':1.17,
    }
DEFAULT_RADIUS=0 # 如果不在此表中, 默认值为0


standard_aa_names_sorted=["ALA", "CYS", "ASP", "GLU", "PHE", "GLY", "HIS", "ILE", "LYS",
                          "LEU", "MET", "ASN", "PRO", "GLN", "ARG", "SER", "THR", "VAL",
                          "TRP", "TYR"]
standard_aa_names_sorted.sort()


# 肽键判据: 原子为C,N且距离为PEPTIDE_BOND, 误差不超过PEPTIDE_BOND_ERROR. 肽键判据在判断键合关系的时候有用
PEPTIDE_BOND=1.3256437
PEPTIDE_BOND_ERROR = 0.05


# load多肽的时候只考虑标准氨基酸, 默认值为1, 改为0可以处理非标准氨基酸, 可能要检查程序.
ONLY_CONSIDER_STANDARD_AA=1

PI=math.pi

script_folder = reflection.get_script_location(__file__)
all_aa_file_name=os.path.join(script_folder,'all_aa.pdb')




@as_method_of(Vector)
def axis_rotate_with_origin(v,axis,angle):
    '''
    绕原点->end逆时针旋转angle


    :param v:
    :param axis:
    :param angle:
    :return:
    '''
    m=rotaxis(angle,axis)
    return v.left_multiply(m)


import labkit.init_gs

from general.interpreter.loader import load_self_conf
# print __file__
# print load_self_conf(__file__)

# @connection.register
class Conformer(Polypeptide):
    '''
    molecular conformer data structure

    公开属性:

    - self.xyz
    - self.energy

    '''
    # structure = {
    #     '_type':basestring, # _type filed is for inherit
    #     'from_method' : basestring,
    #     'from_parameters' : basestring,
    #     'out_parameters' : basestring,
    #     'xyz' : basestring,
    #     'energy' : float,
    #     'father' : basestring,
    #     # self.calc_fun=''
    # }
    # indexes = [
    #     {
    #         'fields':.energy,
    #         },
    #     ]
    # required_fields = ['from_method', 'xyz', 'energy']
    # default_values = {'from_method' : 'origin','from_parameters':'','out_parameters':'', 'father':''}


    def __init__(self,empty=False,conf=None,from_seq=None,from_xyz_file=None,from_pdb_file=None):
        super(Conformer,self).__init__()
        self.xyz=None
        self.energy=None
        self.father=None
        self.from_method='origin'



        if conf == None:
            conf=load_self_conf(__file__)
        if conf:
            self.conf=self.parse_conf(conf)
            if empty:
                return

            if from_pdb_file:
                self.load(from_pdb_file,'pdb')
                return
            if from_xyz_file:
                self.load(from_xyz_file,'xyz')
                return
            if from_seq:
                self.from_seq(from_seq)
                return


            if from_pdb_file == None and self.conf.has_key('pdb'):
                self.load(self.conf['pdb'],'pdb')
                return
            if from_xyz_file == None and self.conf.has_key('xyz'):
                log.debug(self.conf['xyz'])
                self.load(self.conf['xyz'],'xyz')
                return
            if from_seq == None and self.conf.has_key('SEQ'):
                self.from_seq(self.conf['SEQ'])
                return

    @staticmethod
    def parse_conf(origin_conf=None):
        '''
        读取配置文件

        :param origin_conf:
        :return:
        '''
        # todo: 读取配置文件
        # todo: 读取模板分别放在inner和inter里面, 然后去判断. 调试load
        # todo: 全局变量还有一些问题, 在模块组合的时候如何处理配置的名字空间, 以及函数如何引用配置选项

        # todo: 用__dict__的方法把conf弄成一个对象, 从而可以使用conf.xxx的方式访问. 字母改小写(似乎不太好?).
        if origin_conf == None:
            origin_conf=load_self_conf(__file__)

        CONFIG=origin_conf
        conf={}
        for keyword in CONFIG:
            conf[keyword]=CONFIG[keyword]

        newbackbone=[]
        for item in conf['BACKBONE_TEMPLATE']:
            newitem={}
            newitem['dihedral_name']=item[2]
            newitem['residue']=item[0]
            newitem['residue_number']=int(item[1])
            # todo: config字符串和数字的处理.
            newitem['dihedral_list']=item[3]
            newbackbone.append(deepcopy(newitem))
            # del newitem

        conf['BACKBONE_TEMPLATE']=newbackbone

        if conf.get('USE_BOND_TEMPLATE',False):

            standard_pdb_filename=conf.get('USE_BOND_TEMPLATE')
            cc=Conformer().load(standard_pdb_filename,'xyz')

            self.conf['INNER_RESIDUE_BONDING_TEMPLATE']=cc.extract_inner_bonds()
            print self.conf['INNER_RESIDUE_BONDING_TEMPLATE']
        return conf

    ###########  构型的输入输出和配置
    # 主要只提供两个方法, 从conformer build, 以及dumps, 要转回conformer请用conformer().loads(pep.dumps()), 虽然也有快捷实现dump_to_conformer()

    # todo: 可以考虑实现xyz, pdb等属性, 自动同步设置
    # load_xyz: empty_xyz,清energy)->load->build
    # load_seq: empty_list,清energy)->load->refresh


    # build: empty_list->build
    # refresh: empty_xyz->refresh

    # 改变list: empty_xyz->refresh
    # 这样是保证xyz和list都是同时有值的

    def loads(self,string,from_format='xyz'):
        '''
        load conformer from a string, default xyz format

        :param string: conformer representation file content string
        :param from_format: conformer representation format: xyz, pdb, and so on
        :return: the conformer
        '''
        if from_format=='xyz':
            self.empty_xyz()
            self.xyz=string
            self.build()
            self.extract_energy_from_self()
            # print self.xyz
            # print self.energy
            return self
        # 就算是来源是xyz也用babel处理, 可以检查正确性
        to_format='xyz'

        p=subprocess.Popen(['babel',"-i"+from_format,"-o"+to_format],stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=open(os.devnull, 'w'))
        output=p.communicate(input=string)[0]
        self.xyz=output
        self.build()
        self.extract_energy_from_self()
        # print self.xyz
        return self

    def load(self,filename,from_format='xyz'):
        '''
        load conformer from a file, default xyz format

        :param filename: the input file name
        :param from_format: conformer representation format: xyz, pdb, and so on
        :return:
        '''
        # todo: load空文件的时候sh会卡住
        if from_format=='xyz':
            xyz=open(filename,'r').read()
            self.empty_xyz()
            self.xyz=xyz
            # log.debug(xyz)
            # print self.energy
            self.build()
            self.extract_energy_from_self()
            return self
        to_format='xyz'
        p=subprocess.Popen(['babel',"-i"+from_format,filename,"-o"+to_format],stdout=subprocess.PIPE,stderr=open(os.devnull, 'w'))
        output=p.communicate()[0]
        self.xyz=output
        # log.debug( output)
        # log.debug( output)
        self.build()
        self.extract_energy_from_self()

        return self

    def dumps(self,to_format='xyz'):
        '''
        dump a conformer to a string, default xyz format

        :param to_format: conformer representation format: xyz, pdb, and so on
        :return:
        '''
        if to_format=='xyz':
            return self.xyz

        # log.debug(self.xyz)
        in_format='xyz'
        p=subprocess.Popen(['babel',"-i"+in_format,"-o"+to_format],stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=open(os.devnull, 'w'))
        output=p.communicate(input=self.xyz)[0]
        return output

    def dump(self,filename,to_format='xyz'):
        '''
        dump a conformer to a string, default xyz format

        :param filename: output file name
        :param to_format: conformer representation format: xyz, pdb, and so on
        :return:
        '''
        # todo: babel返回值总是0, 需要表示错误. 另外文件操作需要异常处理
        # sh.babel("-ixyz","-o"+out_file_format,filename,_in=self.xyz)
        if to_format=='xyz':
            open(filename,'w').write(self.xyz)
            return self.xyz

        in_format='xyz'
        p=subprocess.Popen(['babel',"-i"+in_format,"-o"+to_format,filename],stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=open(os.devnull, 'w'))
        output=p.communicate(input=self.xyz)[0]

        # print p.returncode
        return output
        # 加判断, 如果是xyz就直接输出, 但是总是使用babel有个好处就是可以检查xyz的值并标准化
        # if out_file_format=='xyz':
        #     open(filename,'w').write(self.xyz)
        # else:
        #     sh.babel("-ixyz","-o"+out_file_format,filename,_in=self.xyz)


    def from_xyz(self,xyz):
        '''
        construct a conformer from a xyz string

        :param xyz: xyz string
        :return: the conformer self
        '''
        return self.loads(xyz,from_format='xyz')

    def to_xyz(self):
        '''
        dump the conformer to xyz string

        :return: the output xyz string
        '''
        return self.dumps(to_format='xyz')

    def from_dict(self,conformer_dict):
        '''
        从字典构建conformer, 注意会和字典共享, 所以字典需要是一次性的, 独享的.

        :param conformer_dict:
        :return:
        '''
        # for i in conformer_dict:
        #     setattr(self,i,conformer_dict[i])

        # 直接赋值的时候要注意, 此处是引用, 因此, 必须不可以再其他地方改变conformer_dict的值. conformer_dict要是一次性的. 或者干脆, deepcopy
        self.empty_xyz()
        self.__dict__=conformer_dict
        self.build()
        # self.refresh()
        return self

    def to_dict(self):
        '''
        此处也一样, 返回的字典是引用, 共享的. 实在不行deepcopy.
        共享好处是性能好以及可以有一些trick操作.

        :return:
        '''
        # for i in conformer_dict:
            # self[i]=conformer_dict[i]
        return self.__dict__



    # todo: load到list的要refresh, load到xyz的要build. 也可以在提取的时候检测是否需要build或者refresh
    def from_seq(self,seq):
        '''
        从序列生成多肽构型

        construct a conformer from a seq

        :param seq: the conformer seq such as 'cggg'
        :return: the constructed conformer
        '''
        "从序列生成多肽构型, 速度快"
        # todo: 包括d1_to_residue等在内的list和Polypeptide类型的问题, 要写转换函数和构造函数
        # self=Polypeptide()
        # todo: 清空
        self.empty_list()
        # print type(pep), "haha"
        for i in seq:
            # self=self.__add__(deepcopy([d1_to_residue[i]]))
            # log.debug()

            self.extend(deepcopy([d1_to_residue[i]]))

        self.refresh()
        return self




    def to_seq(self):
        '''
        dump the conformer to seq

        :return: the output seq
        '''
        pass

    def empty_xyz(self,xyz=''):
        '''
        empty xyz

        :param xyz:
        :return:
        '''
        self.xyz=None
        self.energy=None

    def empty_list(self,xyz=''):
        '''
        empty list

        :param xyz:
        :return:
        '''
        self[:]=[]
        self.energy=None


    def refresh(self):
        '''
        refresh the xyz field from self peptide list

        :return: the refreshed conformer self
        '''
        "dump to xyz format, 注意只有xyz format"
        output = StringIO.StringIO()
        count=0
        self.empty_xyz()
        for res in self:
            # print res
            for atom in res:
                count+=1
                x,y,z=atom.get_coord()
                print >>output,  atom.element,x,y,z
        output_string=output.getvalue()
        output_string=str(count)+'\n'+'peptide_to_xyz\n'+output_string
        # return output_string
        self.xyz=output_string
        return self

    def build(self):
        '''
        build the peptide list from self xyz field from

        :return: the builded conformer self
        '''
        # todo: 从pdb load进多肽
        # todo: 重命名残基名字的问题
        # todo: pdb文件精度是小数点后3位, rmsd比较附近, 以及只用能量和偶极矩去重.
        pdbstring=self.dumps('pdb')


        # log.debug(pdbstring)
        atomlist=re.compile(r'^ATOM.*$',re.M).findall(pdbstring)
        # self=Polypeptide()
        # todo: 清空
        self.empty_list()
        # 只能处理12列的情况, 如果pdb不符合则会有bug
        data=pd.DataFrame([i.split() for i in atomlist],columns=['ATOM','ATOM_ID','ATOM_NAME','RES_NAME','CHAIN','RES_ID','X','Y','Z','OCCUPANCY','TEMPFACTOR','ELEMENT'])

        # log.debug(data)
        for grouped_res in  data.groupby('RES_ID'):

            # log.debug(grouped_res)
            res_id= int(grouped_res[1]['RES_ID'].iloc[0])
            res_full_id= (' ',grouped_res[1]['RES_ID'].iloc[0],' ')
            res_name= grouped_res[1]['RES_NAME'].iloc[0]

            # todo: segid is None, 查init_res函数的调用里面的segid怎么设置的
            res=Residue(res_full_id,res_name,None)
            res.res_id=res_id
            if res_name=='SER':
                duplicated_h=False

                for grouped_atom in grouped_res[1].groupby('ATOM_ID'):
                    serial_number=grouped_atom[1]['ATOM_ID'].iloc[0]
                    element=grouped_atom[1]['ELEMENT'].iloc[0]

                    name=grouped_atom[1]['ATOM_NAME'].iloc[0]
                    if name=='H':
                        if not duplicated_h:
                            name=grouped_atom[1]['ATOM_NAME'].iloc[0]
                            duplicated_h=True
                        else:
                            name=grouped_atom[1]['ATOM_NAME'].iloc[0]+'HH'
                    x=grouped_atom[1]['X'].iloc[0]
                    y=grouped_atom[1]['Y'].iloc[0]
                    z=grouped_atom[1]['Z'].iloc[0]
                    coord=numpy.array((float(x),float(y),float(z)))
                    occupancy=grouped_atom[1]['OCCUPANCY'].iloc[0]
                    bfactor=grouped_atom[1]['TEMPFACTOR'].iloc[0]

                    # 这两个暂时乱填
                    fullname=grouped_atom[1]['RES_NAME'].iloc[0],grouped_atom[1]['ATOM_NAME'].iloc[0]
                    # @param altloc: alternative location specifier for disordered atoms
                    # @type altloc: string
                    altloc=''
                    atom=Atom(name,coord,bfactor,occupancy,altloc,fullname,serial_number,element)
                    atom.res_name=res_name
                    atom.res_id=res_id
                    res.add(atom)

            else:
                # print list(grouped_res[1]['ATOM_NAME'],)
                for grouped_atom in grouped_res[1].groupby('ATOM_ID'):
                    serial_number=grouped_atom[1]['ATOM_ID'].iloc[0]
                    element=grouped_atom[1]['ELEMENT'].iloc[0]
                    name=grouped_atom[1]['ATOM_NAME'].iloc[0]
                    x=grouped_atom[1]['X'].iloc[0]
                    y=grouped_atom[1]['Y'].iloc[0]
                    z=grouped_atom[1]['Z'].iloc[0]
                    coord=numpy.array((float(x),float(y),float(z)))
                    occupancy=grouped_atom[1]['OCCUPANCY'].iloc[0]
                    bfactor=grouped_atom[1]['TEMPFACTOR'].iloc[0]

                    # 这两个暂时乱填
                    fullname=grouped_atom[1]['RES_NAME'].iloc[0],grouped_atom[1]['ATOM_NAME'].iloc[0]
                    # @param altloc: alternative location specifier for disordered atoms
                    # @type altloc: string
                    altloc=''
                    atom=Atom(name,coord,bfactor,occupancy,altloc,fullname,serial_number,element)
                    atom.res_name=res_name
                    atom.res_id=res_id
                    res.add(atom)

            self.append(res)
            # print len(self)

        def get_res_id(res):
            # print res.get_id()[1]
            return int(res.res_id)


        self.sort(key=get_res_id)

        return self


    # ------------------
    def extract_energy_from_self(self):
        '''
        extract energy field from self xyz field

        :return: the conformer self with energy field refreshed
        '''
        re_energy=re.compile(r'Energy\: ?(.*) *$',re.M)
        # print 'haha',self.xyz
        match=re.search(re_energy,self.xyz)
        # print re.findall(re_energy,self.xyz)
        if match:
            # print match.group(1)
            energy=float(match.group(1))
            # print energy
            self.energy=energy
            # print self.energy
            # TODO: UN_CACULATED 和 从能量设置xyz域
            return self.energy
        else:
            return False



    def get_atoms_cord(self):
        '''
        get atoms cord list

        :return: the list contains atoms cord
        '''
        xyz=self.xyz
        # print xyz
        atomlist=[]
        for i,atom in enumerate(xyz.strip().split('\n')):
            # print i,atom
            if i>1:
                atomlist.append(numpy.array(atom.split()[1:],numpy.float64))
        return atomlist



    def rmsd(self,other):
        '''
        计算两个构型的rmsd

        :param other: the conformer to compare
        :return: rmsd value
        '''
        # 提取坐标
        fixed_coord=numpy.array(self.get_atoms_cord())
        moving_coord=numpy.array(other.get_atoms_cord())
        # fixed_coord=conformer1
        # moving_coord=conformer2
        # print fixed_coord
        # print moving_coord

        if not (len(fixed_coord)==len(moving_coord)):
            raise PDBException("Fixed and moving atom lists differ in size")
        # l=len(fixed)
        # fixed_coord=numpy.zeros((l, 3))
        # moving_coord=numpy.zeros((l, 3))
        # for i in range(0, len(fixed)):
        #     fixed_coord[i]=fixed[i].get_coord()
        #     moving_coord[i]=moving[i].get_coord()
        sup=SVDSuperimposer()
        sup.set(fixed_coord, moving_coord)
        sup.run()
        return sup.get_rms()
        # self.rotran=sup.get_rotran()

    def conformer_duplicated(self,other,rmsd_range=gs.CONF.rmsd_range):
        '''
        Judge whether two conformer are same in our durable range.

        :param self:
        :param other:
        :return: True or False whether the two conformer are the same.
        '''

        # print self.xyz
        # print other.xyz
        # print self.rmsd(other)
        if self.rmsd(other)< rmsd_range:
            return True
        else:
            return False





    ############# 构型修饰
    def neutralize(self):
        '''
        中性化

        :return:
        '''
        # todo: 中性化
        self.addH3()
        self.addOXH()
        pass

    def addH3(self):
        '''
        补全NH2端

        :return:
        '''
        # todo: 补全NH2端
        pass

    def addOXH(self):
        '''
        补全COOH端

        :return:
        '''
        # todo: 补全COOH端
        pass

    def dropH3(self):
        '''
        补全NH2端

        :return:
        '''
        # todo: 补全NH2端
        pass

    def dropOXH(self):
        '''
        补全COOH端

        :return:
        '''
        # todo: 补全COOH端
        pass

    ####### 辅助函数

    @staticmethod
    def atom_list(res):
        '''
        遍历返回一个残基的原子名字和坐标

        :param res:
        :return:
        '''
        return [(i.get_name(),i.get_coord()) for i in res]

    def get_atom_list(self):
        """Get list of C-alpha atoms in the polypeptide.

        :return: the list of C-alpha atoms
        :rtype: [L{Atom}, L{Atom}, ...]
        """
        atom_list=[]
        for res in self:
            for atom in res:
                atom_list.append(atom)
        return atom_list

    def get_res_list(self):
        """Get list of C-alpha atoms in the polypeptide.

        :return: the list of C-alpha atoms
        :rtype: [L{Atom}, L{Atom}, ...]
        """
        res_list=[]
        for res in self:
            res_list.append(res)
        return res_list

    @staticmethod
    def axis_rotate_with_start_end(p,start,end,angle):
        '''
        逆时针绕start->end向量旋转angle

        p绕start->end, 对着箭头, 逆时针旋转angle

        从end-start看去, 对着箭头, 绕着此轴顺时针转动angle//逆时针吧

        :param p:
        :param start:
        :param end:
        :param angle:
        :return:
        '''
        # todo: 待再次确认, 测试
        axis=end-start
        angle=angle
        m=rotaxis(angle, axis)
        return (p-start).left_multiply(m)+start



    @staticmethod
    def load_top():
        # todo: 根据角度定义(残基名称, 角度名称: 角度原子) 文件或者top文件获得templete, 键连接关系
        pass
    @staticmethod
    def get_four_atoms(dihedral_name):
        '''
        根据templete获得指定原子, 返回计算二面角用的四个原子.

        :param dihedral_name:
        :return:
        '''
        # todo: 根据templete获得指定原子, 返回计算二面角用的四个原子.
        pass

    # todo: 计算二面角, 设置二面角, 修改完善适用所有二面角
    @staticmethod
    def calc_coord_from_z(v_dis, v_ang, v_dih, dis, ang, dih):
        #todo: 根据z矩阵信息, 四个原子, 计算最后一个原子对应的坐标
        #求该点的坐标，该点与v_dis距离dis,与v_dis,v_ang构成ang的夹角，以v_dis-v_ang轴，与v_dih构成dih二面角
        # CVECTOR v_gs,v_hs,w,r;
        # if(v_dih.p_online(v_ang,v_dis)) throw dis;
        v_gs=v_ang-v_dis
        v_hs=v_dih-v_dis
        w=v_gs**v_hs.axis_rotate_with_origin(v_gs,-dih)
        r=v_gs.normalized()**dis
        return  r.axis_rotate_with_origin(w,ang)+v_dis

    def moving(from_atom, target_atom):
        '''
        moving 把构型某一个原子平移到另一个原子上面, 整体平移.

        :param from_atom:
        :param target_atom:
        :return:
        '''
        # todo: moving 把构型某一个原子平移到另一个原子上面, 整体平移.
        pass

    def moving_atom(self,atom_serial_number):
        '''
        操作单个原子的平移

        :param atom_serial_number:
        :return:
        '''
        # todo: 操作单个原子的平移
        pass
    def moving_pep(pep,residue):
        '''
        移动到一点

        :param pep:
        :param residue:
        :return:
        '''
        # todo: 移动到一点

        pass

    def __add__(self,other):
        '''
        拼接两个分子

        :param other:
        :return:
        '''
        # todo: 目前只是拼合, 还要做移动+旋转, 注意转换矩阵一定要是正交变换. 保持向量模不变
        # todo: combine 拼接: moving, set_dihedral
        # todo: 拼出来的一定要是合法的才行.
        # todo: 注意这里不是deepcopy, 以后要注意, 出现问题的时候回过来看这里.
        # if not self:
        #     return other
        # if not other:
        #     return self

        # end=self[len(self)-1]
        #
        # front=other[0]

        # print dir(front)
        # print inspect.getargspec(front.transform)
        # print atom_list(end)
        # echo_methods(pep1)
        # for i in pep2:
        #     print i.get_list()
        # rotation=rotmat(Vector(1,0,0), Vector(1, 0, 0))
        # translation=numpy.array((0, 0, 1), 'f')
        # [i.transform(rotation,translation) for i in pep1]

        tmp=Polypeptide()
        tmp.extend(self)
        tmp.extend(other)
        # self.logger.debug(type(self))
        # print "debuggggggggggggggggg"
        return tmp

    ######### 二面角和构型拼接旋转操作

    def get_phi_psi_list(self):
        '''
        Return the list of phi/psi dihedral angles.

        :return: a list of phi/psi dihedral angles
        '''
        ppl=[]
        lng=len(self)
        for i in range(0, lng):
            res=self[i]
            try:
                n=res['N'].get_vector()
                ca=res['CA'].get_vector()
                c=res['C'].get_vector()
            except:
                # Some atoms are missing
                # Phi/Psi cannot be calculated for this residue
                ppl.append((None, None))
                res.xtra["PHI"]=None
                res.xtra["PSI"]=None
                continue
            # Phi
            if i>0:
                rp=self[i-1]
                try:
                    cp=rp['C'].get_vector()
                    phi=calc_dihedral(cp, n, ca, c)
                except:
                    phi=None
            else:
                # No phi for residue 0!
                try:
                    h1=self[i]['H1'].get_vector()
                    h2=self[i]['H2'].get_vector()
                    h=(h1+h2)/2.0
                    phi=calc_dihedral(h, n, ca, c)
                except:
                    phi=None


                    # Psi
            if i<(lng-1):
                rn=self[i+1]
                try:
                    nn=rn['N'].get_vector()
                    psi=calc_dihedral(n, ca, c, nn)
                except:
                    psi=None
            else:
                # No psi for last residue!
                try:
                    o=self[i]['OXT'].get_vector()
                    psi=calc_dihedral(n, ca, c, o)
                except:
                    psi=None

            ppl.append(phi)
            ppl.append(psi)
            # Add Phi/Psi to xtra dict of residue
            res.xtra["PHI"]=phi
            res.xtra["PSI"]=psi
        return ppl

    # todo: 交叉变异生成新构型可以并行, 用map

    def set_dihedral(self,dihedral_selector,dihedral):
        '''
        same as get_dihedral, but the setter method.

        :param dihedral_selector: 二面角选择板
        :param dihedral: 设置的二面角
        :return: 设置后的构型
        '''

        old=self.get_dihedral(dihedral_selector)
        log.debug("old: "+str(old))
        new=dihedral*PI/180
        log.debug("new: "+str(new))
        delta=new-old
        log.debug("delta: "+str(delta))
        # print dihedral_selector
        # log.debug(dihedral)

        i=dihedral_selector['residue_number']-1
        lng=len(self)
        res=self[i]

        # print res

        if dihedral_selector['dihedral_name'].upper()=='PHI' or dihedral_selector['dihedral_name'].upper()=='PSI' :
            try:
                n=res['N'].get_vector()
                ca=res['CA'].get_vector()
                c=res['C'].get_vector()
            except:
                # Some atoms are missing
                # Phi/Psi cannot be calculated for this residue
                # ppl.append((None, None))
                res.xtra["PHI"]=None
                res.xtra["PSI"]=None
                return None




        if dihedral_selector['dihedral_name'].upper()=='PHI':
            start=n
            end=ca
            pass_atom=['N','HN','H1','H2','H3','CA']
        elif dihedral_selector['dihedral_name'].upper()=='PSI':
            start=ca
            end=c
            rest_atom=['O']


        for p in res:
            if p.name in rest_atom:
                # print p.name
                ans=self.axis_rotate_with_start_end(p.get_vector(),start,end,delta)
                # print p.coord
                # print ans
                p.coord=ans.get_array()
                # print p.coord

        for left in range(i+1,lng):
            res=self[left]
            for p in res:
                # print p.name,p.coord
                ans=self.axis_rotate_with_start_end(p.get_vector(),start,end,delta)
                # print ans
                p.coord=ans.get_array()
                # print p.name,p.coord

        self.refresh()
        return self



        # todo: 侧链角度二面角的转换列表

    def get_dihedral(self,dihedral_selector):
        '''
        dihedral_selector is a dict like this:
        {'residue': 'CYS', 'dihedral_name': 'PSI', 'residue_number': 1,
         'dihedral_list': [0, 90, 180, 270]}

        backbone_template is a list of dihedral_selector. dihedral_selector is also dihedral selector.
        so givin a dihedral_selector, we can get the dihedral from the comformer.
        It is what this function do.

        :param dihedral_selector: a dict, a dihedral selector
        :return: dihedral, with radian.
        '''

        # todo: 处理一些边界问题
        # log.debug(dihedral_selector)
        i=dihedral_selector['residue_number']-1
        log.debug(i)
        lng=len(self)
        # print self.dumps()
        res=self[i]

        if dihedral_selector['dihedral_name'].upper()=='PHI' or dihedral_selector['dihedral_name'].upper()=='PSI' :
            try:
                n=res['N'].get_vector()
                ca=res['CA'].get_vector()
                c=res['C'].get_vector()
            except:
                # Some atoms are missing
                # Phi/Psi cannot be calculated for this residue
                # ppl.append((None, None))
                res.xtra["PHI"]=None
                res.xtra["PSI"]=None
                return None
        if dihedral_selector['dihedral_name'].upper()=='PHI':
            # Phi
            if i>0:
                rp=self[i-1]
                try:
                    cp=rp['C'].get_vector()
                    phi=calc_dihedral(cp, n, ca, c)
                except:
                    phi=None
            else:
                # No phi for residue 0!
                try:
                    h1=self[i]['H1'].get_vector()
                    h2=self[i]['H2'].get_vector()
                    h=(h1+h2)/2.0
                    phi=calc_dihedral(h, n, ca, c)
                except:
                    phi=None
            return phi

        if dihedral_selector['dihedral_name'].upper()=='PSI':

            # Psi
            if i<(lng-1):
                rn=self[i+1]
                try:
                    nn=rn['N'].get_vector()
                    psi=calc_dihedral(n, ca, c, nn)
                except:
                    psi=None
            else:
                # No psi for last residue!
                try:
                    o=self[i]['OXT'].get_vector()
                    psi=calc_dihedral(n, ca, c, o)
                except:
                    psi=None
            return psi

            # Add Phi/Psi to xtra dict of residue
            # res.xtra["PHI"]=phi
            # res.xtra["PSI"]=psi


    ############# 构型检查

    def get_atoms(self):
        '''
        get the atoms of the conformer

        :return: a generater of atoms
        '''
        for res in self:
            for atom in res:
                yield atom



    def bebonding(self,atom1, atom2):
        '''
        judge whether two atom are bonded

        :param atom1: first atom
        :param atom2: second atom
        :return: True if bonding, False if not
        '''
        # todo: 给定两个原子, 判断他们是否有键连接, 可以根据gromacs的itp文件判断.
        if self.is_peptide_bond(atom1,atom2):
            return True
        res1=atom1.get_parent().get_resname()
        res2=atom2.get_parent().get_resname()
        # 检验一下这种用法

        # if res1!=res2:
        #     print [res1,atom1.id,res2,atom2.id] in inter_residue_bonding_template
        if res1==res2 and ([res1,atom1.id,atom2.id] in self.conf['INNER_RESIDUE_BONDING_TEMPLATE'] or [res1,atom2.id,atom1.id] in self.conf['INNER_RESIDUE_BONDING_TEMPLATE']) :
            return True
        if res1!=res2 and ([res1,atom1.id,res2,atom2.id] in self.conf['INTER_RESIDUE_BONDING_TEMPLATE'] or [res2,atom2.id,res1,atom1.id] in self.conf['INTER_RESIDUE_BONDING_TEMPLATE']) :
            return True
        return False

    # todo: 键判断这里还有问题, 需要修改


    def is_peptide_bond(self,atom1, atom2):
        '''
        判断两个原子C,N是否成肽键

        :param atom1:
        :param atom2:
        :return: True if peptide bond, else False
        '''
        if abs((atom1-atom2)-PEPTIDE_BOND)< PEPTIDE_BOND_ERROR and (atom1.id=='C' and atom2.id=='N' or atom1.id=='N' and atom2.id=='C' ):
            return True


    # todo: 二硫键, 氢键
    # todo: 检查in_residue_bonding_template:



    def extract_inner_bonds(self):
        '''
        从构型根据默认键长抽取内部键连接

        :return: 键连接列表
        '''
        # todo: 判断构型是否合法
        atoms=list(self.get_atoms())
        # pep.logger.debug(atoms)
        # al = [Atom() for j in range(100)]
        ns = NeighborSearch(atoms)
        count =0
        ll=[]
        for (atom1, atom2) in ns.search_all(DISTANCE_SEARCH_RANGE):
            allowed_distance=ELEMENT_RADIUS_DICT.get(atom1.element,DEFAULT_RADIUS)+ELEMENT_RADIUS_DICT.get(atom2.element,DEFAULT_RADIUS)+MIN_SPACE_DISTANCE
            if atom1-atom2 < allowed_distance and  atom1.get_parent().get_resname()==atom2.get_parent().get_resname()  :
                # todo : 没有链接关系, implement bebonding函数
                # ll.append([standard_aa_names_sorted[atom1.get_full_id()[3][1]-1],atom1.id,standard_aa_names_sorted[atom2.get_full_id()[3][1]-1],atom2.id,atom1-atom2,])
                # 老的
                # ll.append([standard_aa_names_sorted[atom1.get_full_id()[3][1]-1],atom1.id,atom2.id])
                ll.append([atom1.res_name,atom1.id,atom2.id])
                # print atom1.serial_number, atom2.serial_number
                # print count
                count =count +1
                return False
        ll.sort()
        # for i in ll:
        #     print i
        return ll



    def is_legit(self,print_not_legit=False):
        '''
        判断构型是否合法
        judge if a conformer is legit

        :param print_not_legit: 打印不合法的键
        :return: True if is legit, else Fale
        '''
        atoms=list(self.get_atoms())
        # pep.logger.debug(atoms)
        # al = [Atom() for j in range(100)]
        ns = NeighborSearch(atoms)
        count =0
        ll=[]
        for (atom1, atom2) in ns.search_all(DISTANCE_SEARCH_RANGE):
            allowed_distance=ELEMENT_RADIUS_DICT.get(atom1.element,DEFAULT_RADIUS)+ELEMENT_RADIUS_DICT.get(atom2.element,DEFAULT_RADIUS)+MIN_SPACE_DISTANCE
            if atom1-atom2 < allowed_distance and  not self.bebonding(atom1,atom2):
                # todo : 没有链接关系, implement bebonding函数
                ll.append([atom1.res_name,atom1.id,atom2.res_name,atom2.id,atom1-atom2,])
                # ll.append([standard_aa_names_sorted[atom1.get_full_id()[3][1]-1],atom1.id,atom2.id])
                # print atom1.serial_number, atom2.serial_number
                # print count
                count =count +1
                # 这里如果return False, 则略去打印过程
                if not print_not_legit:
                    return False
        ll.sort()
        for i in ll:
            print i
        if not count:
            return True
        else:
            return False



    ############## 构型生成和编码

    # 从1111开始转

    # todo: 持久化, 1.函数中断续传, 2.全部推入redis, 并简历完善的fail机制.
    # todo: pm3捆绑, 周一之后做.

    # todo: 加入判断构型合理性
    def generate_old(self,backbone_template=None,side_template=None):

        # todo: 根据模板返回系统法的生成器
        '''把构型转化为二面角列表
        (backbone,side) 由主链和侧链二面角在template里面的取值列表拼合而成.
        '''

        if backbone_template==None:
            backbone_template = self.conf['BACKBONE_TEMPLATE']
        if side_template==None:
            side_template = self.conf['SIDE_TEMPLATE']

        # backbone=get_phi_psi_list(pep)
        # 获得侧链二面角
        # side=get_side(pep)
        # todo: 侧链编码
        backbone=[]
        # print backbone_template
        # todo: 侧链
        for dihedral_selector in backbone_template:
            # Polypeptide.logger.debug( self.get_dihedral(dihedral_selector))
            # dihedral=pep.get_dihedral(dihedral_selector)*180/PI
            # delta_list=[]
            for i in dihedral_selector['dihedral_list']:
                # delta= (dihedral-i) % 360
                # if delta >180:
                #     delta=360-180
                # delta_list.append(delta)

                self.set_dihedral(dihedral_selector,i)
                # todo: 同样islegit需要处理
                if self.is_legit() or True:
                    # todo: 这里需要顺序处理, 是否需要deepcopy
                    yield self
                    # yield deepcopy(self)
                else:
                    continue
                    # todo: 重启的时候接续的问题, 持久化状态

                    # print delta_list
                    # print delta_list.index(min(delta_list))
                    # backbone.append(delta_list.index(min(delta_list)))

    def generate(self,backbone_template=None,side_template=None):
        '''
        返回generate出来的code的迭代器

        :param backbone_template:
        :param side_template:
        :return:
        '''

        if backbone_template==None:
            backbone_template = self.conf['BACKBONE_TEMPLATE']
        if side_template==None:
            # side_template = self.conf['SIDE_TEMPLATE']
            side_template = []

        # 解决主链和侧链的问题.


        # backbone=get_phi_psi_list(pep)
        # 获得侧链二面角
        # side=get_side(pep)
        # todo: 侧链编码
        backbone=[]


        backbone_coding_template= [range(len(dihedral_selector['dihedral_list'])) for dihedral_selector in backbone_template]
        side_coding_template= [range(len(dihedral_selector['dihedral_list'])) for dihedral_selector in side_template]

        from itertools import product
        return product(apply(product,backbone_coding_template),apply(product,side_coding_template))
        return



        # print backbone_template
        # todo: 侧链
        # for dihedral_selector in backbone_template:
        #     # Polypeptide.logger.debug( self.get_dihedral(dihedral_selector))
        #     # dihedral=pep.get_dihedral(dihedral_selector)*180/PI
        #     # delta_list=[]
        #     for i in dihedral_selector['dihedral_list']:
        #         # delta= (dihedral-i) % 360
        #         # if delta >180:
        #         #     delta=360-180
        #         # delta_list.append(delta)
        #
        #         self.set_dihedral(dihedral_selector,i)
        #         # todo: 同样islegit需要处理
        #         if self.is_legit() or True:
        #             # todo: 这里需要顺序处理, 是否需要deepcopy
        #             yield self
        #             # yield deepcopy(self)
        #         else:
        #             continue
        #             # todo: 重启的时候接续的问题, 持久化状态
        #
        #             # print delta_list
        #             # print delta_list.index(min(delta_list))
        #             # backbone.append(delta_list.index(min(delta_list)))

    # 这是什么方法
    # @staticmethod
    def decoding(self,code,backbone_template=None,side_template=None):
        '''
        把二面角列表编码转化为构型
        原地的, 并非copy

        :param code:
        :param backbone_template:
        :param side_template:
        :return:
        '''
        # todo: 把code转化为构型

        if backbone_template==None:
            backbone_template = self.conf['BACKBONE_TEMPLATE']
        if side_template==None:
            side_template = self.conf['SIDE_TEMPLATE']


        backbone_code,side_code=code


        for digit,dihedral_selector in zip(backbone_code,backbone_template):
            # print digit,dihedral_selector
            # log.debug(dihedral_selector['dihedral_list'])
            # log.debug(dihedral_selector['dihedral_list'][2])
            self.set_dihedral(dihedral_selector,dihedral_selector['dihedral_list'][digit])

        return self

            # for i in dihedral_selector['dihedral_list']:
            #     self.set_dihedral(dihedral_selector,i)
            #     if self.is_legit() or True:
            #         return self

    def first_code(self,backbone_template=None,side_template=None):
        if backbone_template==None:
            backbone_template = self.conf['BACKBONE_TEMPLATE']
        if side_template==None:
            side_template = self.conf['SIDE_TEMPLATE']

        # todo:
        code=[]
        # print side_template
        # print backbone_template+side_template
        # todo: 侧链
        for dihedral_selector in (backbone_template):
            # Polypeptide.logger.debug( self.get_dihedral(dihedral_selector))
            # print dihedral_selector
            for i in dihedral_selector['dihedral_list']:
                self.set_dihedral(dihedral_selector,i)
                # print self
                # todo: is_legit() 有问题
                if self.is_legit() or True:
                    code.append(dihedral_selector['dihedral_list'].index(i))
                    break
        return code

    def encoding(self,backbone_template=None,side_template=None):
        '''
        把构型转化为二面角列表
        (backbone,side) 由主链和侧链二面角在template里面的取值列表拼合而成.

        :param backbone_template:
        :param side_template:
        :return:
        '''
        # backbone=get_phi_psi_list(pep)
        # 获得侧链二面角
        # side=get_side(pep)
        # todo: 侧链编码

        if backbone_template == None:
            backbone_template = self.conf['BACKBONE_TEMPLATE']
        if side_template == None:
            side_template = self.conf['SIDE_TEMPLATE']

        # log.debug(backbone_template)
        log.debug(side_template)
        backbone=[]

        # print backbone_template
        # 提取主链二面角了\
        for dihedral_selector in backbone_template:
            # Polypeptide.logger.debug( self.get_dihedral(dihedral_selector))
            dihedral=self.get_dihedral(dihedral_selector)*180/PI
            delta_list=[]
            for i in dihedral_selector['dihedral_list']:
                delta= (dihedral-i) % 360
                if delta >180:
                    delta=360-180
                delta_list.append(delta)
            # print delta_list
            # print delta_list.index(min(delta_list))
            backbone.append(delta_list.index(min(delta_list)))

        side=[]


        for dihedral_selector in side_template:
            # todo: 侧链
            # log.debug(side_template)
            break
            # log.debug( self.get_dihedral(dihedral_selector))
            dihedral=self.get_dihedral(dihedral_selector)*180/PI
            delta_list=[]
            for i in dihedral_selector['dihedral_list']:
                delta= (dihedral-i) % 360
                if delta >180:
                    delta=360-180
                delta_list.append(delta)
            # print delta_list
            # print delta_list.index(min(delta_list))
            side.append(delta_list.index(min(delta_list)))

        return (backbone,side)

    def cross(self,code2):

        # todo: 交叉两个编码
        "交叉两个编码"
        pass


    ########### 构型计算和判断重复



    def metacalc(self,calc_func):
        # todo: 提交到labdist上面去计算
        pass



    # @patcher.as_method
    # def dump(self,filename):
    #     "dump to xyz format file"
    #     file=open(filename,'w')
    #     # Polypeptide.logger.debug(self.dumps())
    #     file.write(self.dumps())
    #     file.close()
    #
    # @patcher.as_method
    # def dump_to_conformer(self):
    #     "dump to conformer"
    #     return Conformer().loads(self.dumps())
    #



def build_template():
    '''
    build the 20 amino acid template

    :return:
    '''
    return Conformer(from_pdb_file=all_aa_file_name)


TEMPLATE=build_template()  # 20个标准氨基酸模板肽链

# print TEMPLATE
# print TEMPLATE[1].child_list[1].res_name

d3_to_residue={}
d1_to_residue={}
for d3 in d3_to_index.keys():
    for i in TEMPLATE:
        if i.resname == d3:
            matched_residue=i
            break
    d1_to_residue[three_to_one(d3)]=matched_residue
    d3_to_residue[d3]=matched_residue

def test():
    print d1_to_residue
    print TEMPLATE[:]
    TEMPLATE.refresh()
    print TEMPLATE.xyz
    pass


def run(args):
    '''

    :param args:
    :return:
    '''
    print "hello this is labkit.conformer.conformer"

def selfrun():
    import labkit.init_gs
    from general.interpreter.loader import callrun
    callrun(__file__)
if __name__ == '__main__':
    test()
    # selfrun()
    pass
