<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.waterdynamics &mdash; MDAnalysis 0.12.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.12.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.12.1 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.12.1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.12.1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.analysis.waterdynamics</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c"># and contributors (see AUTHORS for the full list)</span>
<span class="c">#</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Water dynamics analysis --- :mod:`MDAnalysis.analysis.waterdynamics`</span>
<span class="sd">=======================================================================</span>

<span class="sd">:Author: Alejandro Bernardin</span>
<span class="sd">:Year: 2014-2015</span>
<span class="sd">:Copyright: GNU Public License v3</span>

<span class="sd">.. versionadded:: 0.11.0</span>

<span class="sd">This module provides functions to analize water dynamics trajectories and water interactions with other molecules.</span>
<span class="sd">The functions in this module are: water orientational relaxation (WOR) [Yeh1999]_, hydrogen bond lifetimes (HBL) [Rapaport1983]_,</span>
<span class="sd">angular distribution (AD) [Grigera1995]_, mean square displacement (MSD) [Brodka1994]_ and survival probability (SP) [Liu2004]_.</span>

<span class="sd">For more information about this type of analysis please refer to [Araya-Secchi2014]_ (water in a protein cavity) and [Milischuk2011]_ (water in a nanopore).</span>

<span class="sd">.. rubric:: References</span>

<span class="sd">.. [Rapaport1983] D.C. Rapaport (1983): Hydrogen bonds in water, Molecular Physics: An International</span>
<span class="sd">            Journal at the Interface Between Chemistry and Physics, 50:5, 1151-1162.</span>

<span class="sd">.. [Yeh1999] Yu-ling Yeh and Chung-Yuan Mou (1999).</span>
<span class="sd">             Orientational Relaxation Dynamics of Liquid Water Studied by Molecular Dynamics</span>
<span class="sd">             Simulation, J. Phys. Chem. B 1999, 103, 3699-3705.</span>

<span class="sd">.. [Grigera1995] Raul Grigera, Susana G. Kalko and Jorge Fischbarg (1995). Wall-Water Interface.</span>
<span class="sd">                  A Molecular Dynamics Study, Langmuir 1996,12,154-158</span>

<span class="sd">.. [Liu2004] Pu Liu, Edward Harder, and B. J. Berne (2004).On the Calculation of Diffusion Coefficients</span>
<span class="sd">             in Confined Fluids and Interfaces with an Application to the Liquid-Vapor Interface of</span>
<span class="sd">             Water, J. Phys. Chem. B 2004, 108, 6595-6602.</span>

<span class="sd">.. [Brodka1994] Aleksander Brodka (1994). Diffusion in restricted volume, Molecular Physics, 1994, Vol.</span>
<span class="sd">                82, No. 5, 1075-1078.</span>

<span class="sd">.. [Araya-Secchi2014] Araya-Secchi, R., Tomas Perez-Acle, Seung-gu Kang, Tien Huynh, Alejandro Bernardin, Yerko Escalona, Jose-Antonio Garate, Agustin D. Martinez,</span>
<span class="sd">                     Isaac E. Garcia, Juan C. Saez, Ruhong Zhou (2014). Characterization of a novel water pocket inside the human Cx26 hemichannel structure. Biophysical journal, 107(3), 599-612.</span>

<span class="sd">.. [Milischuk2011] Anatoli A. Milischuk and Branka M. Ladanyi. Structure and dynamics of water confined</span>
<span class="sd">                    in silica nanopores. J. Chem. Phys. 135, 174709 (2011); doi: 10.1063/1.3657408</span>



<span class="sd">.. examples</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>

<span class="sd">HydrogenBondLifetimes</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">Analyzing hydrogen bond lifetimes (HBL) :class:`HydrogenBondLifetimes`, both continuos and intermittent. In this case we are analyzing</span>
<span class="sd">how residue 38 interact with a water sphere of radius 6.0 centered on the geometric center of protein and</span>
<span class="sd">residue 42. If the hydrogen bond lifetimes are very stable, we can assume that residue 38 is hydrophilic, on the other</span>
<span class="sd">hand, if the  are very unstable, we can assume that residue 38 is hydrophobic::</span>

<span class="sd">  import MDAnalysis</span>
<span class="sd">  from MDAnalysis.analysis.waterdynamics import HydrogenBondLifetimes as HBL</span>

<span class="sd">  u = MDAnalysis.Universe(pdb, trajectory)</span>
<span class="sd">  selection1 = &quot;byres name OH2 and sphzone 6.0 protein and resid 42&quot;</span>
<span class="sd">  selection2 = &quot;resid 38&quot;</span>
<span class="sd">  HBL_analysis = HBL(universe, selection1, selection2, 0, 2000, 30)</span>
<span class="sd">  HBL_analysis.run()</span>
<span class="sd">  i=0</span>
<span class="sd">  #now we print the data ready to graph. The first two columns are the HBLc vs t graph and</span>
<span class="sd">  #the second two columns are the HBLi vs t graph</span>
<span class="sd">  for HBLc, HBLi in HBL_analysis.timeseries:</span>
<span class="sd">        print i +&quot; &quot;+ HBLc +&quot; &quot;+ i +&quot; &quot;+ HBLi</span>
<span class="sd">        i+=1</span>

<span class="sd">where HBLc is the value for the continuos hydrogen bond lifetimes and HBLi is the value for the intermittent</span>
<span class="sd">hydrogen bond lifetime, t0 = 0, tf = 2000 and dtmax = 30. In this way we create 30 windows timestep</span>
<span class="sd">(30 values in x axis). The continuos hydrogen bond lifetimes should decay faster than intermittent.</span>


<span class="sd">WaterOrientationalRelaxation</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">Analyzing water orientational relaxation (WOR) :class:`WaterOrientationalRelaxation`. In this case we are analyzing &quot;how fast&quot; water molecules are rotating/changing direction. If WOR is very stable we can assume that water molecules are rotating/changing direction very slow, on the other hand, if WOR decay very fast, we can assume that water molecules are rotating/changing direction very fast::</span>

<span class="sd">  import MDAnalysis</span>
<span class="sd">  from MDAnalysis.analysis.waterdynamics import WaterOrientationalRelaxation as WOR</span>

<span class="sd">  u = MDAnalysis.Universe(pdb, trajectory)</span>
<span class="sd">  selection = &quot;byres name OH2 and sphzone 6.0 protein and resid 42&quot;</span>
<span class="sd">  WOR_analysis = WOR(universe, selection, 0, 1000, 20)</span>
<span class="sd">  WOR_analysis.run()</span>
<span class="sd">  i=0</span>
<span class="sd">  #now we print the data ready to graph. The first two columns are WOR_OH vs t graph,</span>
<span class="sd">  #the second two columns are WOR_HH vs t graph and the third two columns are WOR_dip vs t graph</span>
<span class="sd">  for WOR_OH, WOR_HH, WOR_dip in WOR_analysis.timeseries:</span>
<span class="sd">        print i +&quot; &quot;+ WOR_OH +&quot; &quot;+ i +&quot; &quot;+ WOR_HH +&quot; &quot;+ i +&quot; &quot;+ WOR_dip</span>

<span class="sd">where t0 = 0, tf = 1000 and dtmax = 20. In this way we create 20 windows timesteps (20 values in the x axis),</span>
<span class="sd">the first window is created with 1000 timestep average (1000/1), the second window is created with 500</span>
<span class="sd">timestep average(1000/2), the third window is created with 333 timestep average (1000/3) and so on.</span>

<span class="sd">AngularDistribution</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">Analyzing angular distribution (AD) :class:`AngularDistribution` for OH vector, HH vector and dipole vector. It returns</span>
<span class="sd">a line histogram with vector orientation preference. A straight line in the output graphic means no preferential</span>
<span class="sd">orientation in water molecules. In this case we are analyzing if water molecules have some orientational</span>
<span class="sd">preference, in this way we can see if water molecules are under an electric field or if they are interacting</span>
<span class="sd">with something (residue, protein, etc)::</span>

<span class="sd">  import MDAnalysis</span>
<span class="sd">  from MDAnalysis.analysis.waterdynamics import AngularDistribution as AD</span>

<span class="sd">  u = MDAnalysis.Universe(pdb, trajectory)</span>
<span class="sd">  selection = &quot;byres name OH2 and sphzone 6.0 (protein and (resid 42 or resid 26) )&quot;</span>
<span class="sd">  bins = 30</span>
<span class="sd">  AD_analysis = AD(universe,selection,bins)</span>
<span class="sd">  AD_analysis.run()</span>
<span class="sd">  #now we print data ready to graph. The first two columns are P(cos(theta)) vs cos(theta) for OH vector ,</span>
<span class="sd">  #the seconds two columns are P(cos(theta)) vs cos(theta) for HH vector and thirds two columns</span>
<span class="sd">  #are P(cos(theta)) vs cos(theta) for dipole vector</span>
<span class="sd">  for i in range(bins):</span>
<span class="sd">        print AD_analysis.graph[0][i] +&quot; &quot;+ AD_analysis.graph[1][i] +&quot; &quot;+ AD_analysis.graph[2][i]</span>

<span class="sd">where P(cos(theta)) is the angular distribution or angular probabilities.</span>

<span class="sd">MeanSquareDisplacement</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="sd">Analyzing mean square displacement (MSD):class:`MeanSquareDisplacement` for water molecules. In this case we are analyzing the average distance</span>
<span class="sd">that water molecules travels inside protein in XYZ direction (cylindric zone of radius 11[nm], Zmax 4.0[nm] and Zmin -8.0[nm]). A strong</span>
<span class="sd">rise mean a fast movement of water molecules, a weak rise mean slow movement of particles::</span>

<span class="sd">  import MDAnalysis</span>
<span class="sd">  from MDAnalysis.analysis.waterdynamics import MeanSquareDisplacement as MSD</span>

<span class="sd">  u = MDAnalysis.Universe(pdb, trajectory)</span>
<span class="sd">  selection = &quot;byres name OH2 and cyzone 11.0 4.0 -8.0 protein&quot;</span>
<span class="sd">  MSD_analysis = MSD(universe, selection, 0, 1000, 20)</span>
<span class="sd">  MSD_analysis.run()</span>
<span class="sd">  #now we print data ready to graph. The graph</span>
<span class="sd">  #represents MSD vs t</span>
<span class="sd">  i=0</span>
<span class="sd">  for msd in MSD_analysis.timeseries:</span>
<span class="sd">        print i +&quot; &quot;+ msd</span>
<span class="sd">        i += 1</span>


<span class="sd">SurvivalProbability</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~</span>
<span class="sd">Analyzing survival probability (SP) :class:`SurvivalProbability` for water molecules. In this case we are analyzing how long water</span>
<span class="sd">molecules remain in a sphere of radius 12.3 centered in the geometrical center of resid 42, 26, 34 and 80.</span>
<span class="sd">A slow decay of SP means a long permanence time of water molecules in the zone, on the</span>
<span class="sd">other hand, a fast decay means a short permanence time::</span>

<span class="sd">  import MDAnalysis</span>
<span class="sd">  from MDAnalysis.analysis.waterdynamics import SurvivalProbability as SP</span>

<span class="sd">  u = MDAnalysis.Universe(pdb, trajectory)</span>
<span class="sd">  selection = &quot;byres name OH2 and sphzone 12.3 (resid 42 or resid 26 or resid 34 or resid 80) &quot;</span>
<span class="sd">  SP_analysis = SP(universe, selection, 0, 100, 20)</span>
<span class="sd">  SP_analysis.run()</span>
<span class="sd">  #now we print data ready to graph. The graph</span>
<span class="sd">  #represents SP vs t</span>
<span class="sd">  i=0</span>
<span class="sd">  for sp in SP_analysis.timeseries:</span>
<span class="sd">        print i +&quot; &quot;+ sp</span>
<span class="sd">        i += 1</span>

<span class="sd">.. Output</span>

<span class="sd">Output</span>
<span class="sd">------</span>

<span class="sd">HydrogenBondLifetimes</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~</span>
<span class="sd">Hydrogen bond lifetimes (HBL) data is returned per window timestep, which is stored in</span>
<span class="sd">:attr:`HydrogenBondLifetimes.timeseries` (in all the following descriptions, # indicates comments that are not part of the output)::</span>

<span class="sd">    results = [</span>
<span class="sd">        [ # time t0</span>
<span class="sd">            &lt;HBL_c&gt;, &lt;HBL_i&gt;</span>
<span class="sd">        ],</span>
<span class="sd">        [ # time t1</span>
<span class="sd">            &lt;HBL_c&gt;, &lt;HBL_i&gt;</span>
<span class="sd">        ],</span>
<span class="sd">        ...</span>
<span class="sd">     ]</span>

<span class="sd">WaterOrientationalRelaxation</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="sd">Water orientational relaxation (WOR) data is returned per window timestep, which is stored in</span>
<span class="sd">:attr:`WaterOrientationalRelaxation.timeseries`::</span>

<span class="sd">    results = [</span>
<span class="sd">        [ # time t0</span>
<span class="sd">            &lt;WOR_OH&gt;, &lt;WOR_HH&gt;, &lt;WOR_dip&gt;</span>
<span class="sd">        ],</span>
<span class="sd">        [ # time t1</span>
<span class="sd">            &lt;WOR_OH&gt;, &lt;WOR_HH&gt;, &lt;WOR_dip&gt;</span>
<span class="sd">        ],</span>
<span class="sd">        ...</span>
<span class="sd">     ]</span>

<span class="sd">AngularDistribution</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~</span>
<span class="sd">Angular distribution (AD) data is returned per vector, which is stored in</span>
<span class="sd">:attr:`AngularDistribution.graph`. In fact, AngularDistribution returns a histogram::</span>

<span class="sd">    results = [</span>
<span class="sd">        [ # OH vector values</span>
<span class="sd">          # the values are order in this way: &lt;x_axis  y_axis&gt;</span>
<span class="sd">            &lt;cos_theta0 ang_distr0&gt;, &lt;cos_theta1 ang_distr1&gt;, ...</span>
<span class="sd">        ],</span>
<span class="sd">        [ # HH vector values</span>
<span class="sd">            &lt;cos_theta0 ang_distr0&gt;, &lt;cos_theta1 ang_distr1&gt;, ...</span>
<span class="sd">        ],</span>
<span class="sd">        [ # dip vector values</span>
<span class="sd">           &lt;cos_theta0 ang_distr0&gt;, &lt;cos_theta1 ang_distr1&gt;, ...</span>
<span class="sd">        ],</span>
<span class="sd">     ]</span>

<span class="sd">MeanSquareDisplacement</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="sd">Mean Square Displacement (MSD) data is returned in a list, which each element represents a MSD value in its respective</span>
<span class="sd">window timestep. Data is stored in :attr:`MeanSquareDisplacement.timeseries`::</span>

<span class="sd">    results = [</span>
<span class="sd">         #MSD values orders by window timestep</span>
<span class="sd">            &lt;MSD_t0&gt;, &lt;MSD_t1&gt;, ...</span>
<span class="sd">     ]</span>

<span class="sd">SurvivalProbability</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~</span>
<span class="sd">Survival Probability (SP) data is returned in a list, which each element represents a SP value in its respective</span>
<span class="sd">window timestep. Data is stored in :attr:`SurvivalProbability.timeseries`::</span>

<span class="sd">    results = [</span>
<span class="sd">         # SP values order by window timestep</span>
<span class="sd">            &lt;SP_t0&gt;, &lt;SP_t1&gt;, ...</span>
<span class="sd">     ]</span>



<span class="sd">Classes</span>
<span class="sd">--------</span>

<span class="sd">.. autoclass:: HydrogenBondLifetimes</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>

<span class="sd">.. autoclass:: WaterOrientationalRelaxation</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>

<span class="sd">.. autoclass:: AngularDistribution</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>

<span class="sd">.. autoclass:: MeanSquareDisplacement</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>

<span class="sd">.. autoclass:: SurvivalProbability</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">MDAnalysis.analysis.hbonds</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<div class="viewcode-block" id="HydrogenBondLifetimes"><a class="viewcode-back" href="../../../documentation_pages/analysis/waterdynamics.html#MDAnalysis.analysis.waterdynamics.HydrogenBondLifetimes">[docs]</a><span class="k">class</span> <span class="nc">HydrogenBondLifetimes</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    This is a autocorrelation function that gives the &quot;Hydrogen Bond Lifetimes&quot; (HBL) proposed by D.C. Rapaport [Rapaport1983]_. From this</span>
<span class="sd">    function we can obtain the continuos and intermittent behavior of hydrogen bonds in time. A</span>
<span class="sd">    fast decay in these parameters indicate a fast change in HBs connectivity. A slow decay</span>
<span class="sd">    indicate very stables hydrogen bonds, like in ice. The HBL is also know as &quot;Hydrogen Bond Population</span>
<span class="sd">    Relaxation&quot; (HBPR). In the continuos case we have:</span>

<span class="sd">    .. math::</span>
<span class="sd">       C_{HB}^c(\tau) = \frac{\sum_{ij}h_{ij}(t_0)h&#39;_{ij}(t_0+\tau)}{\sum_{ij}h_{ij}(t_0)}</span>

<span class="sd">    where :math:`h&#39;_{ij}(t_0+\tau)=1` if there is a H-bond between a pair :math:`ij` during time interval</span>
<span class="sd">    :math:`t_0+\tau` (continuos) and :math:`h&#39;_{ij}(t_0+\tau)=0` otherwise. In the intermittent case</span>
<span class="sd">    we have:</span>

<span class="sd">    .. math::</span>
<span class="sd">       C_{HB}^i(\tau) = \frac{\sum_{ij}h_{ij}(t_0)h_{ij}(t_0+\tau)}{\sum_{ij}h_{ij}(t_0)}</span>

<span class="sd">    where :math:`h_{ij}(t_0+\tau)=1` if there is a H-bond between a pair :math:`ij` at time</span>
<span class="sd">    :math:`t_0+\tau` (intermittent) and :math:`h_{ij}(t_0+\tau)=0` otherwise.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    :Arguments:</span>
<span class="sd">     *universe*</span>
<span class="sd">       Universe object</span>
<span class="sd">     *selection1*</span>
<span class="sd">       Selection string for first selection [‘byres name OH2’]</span>
<span class="sd">       It could be any selection available in MDAnalysis, not just water.</span>
<span class="sd">     *selection2*</span>
<span class="sd">       Selection string to analize its HBL against selection1</span>
<span class="sd">     *t0*</span>
<span class="sd">       Time where analysis begin</span>
<span class="sd">     *tf*</span>
<span class="sd">       Time where analysis end</span>
<span class="sd">     *dtmax*</span>
<span class="sd">       Maximum dt size, dtmax &lt; tf or it will crash.</span>
<span class="sd">     *nproc*</span>
<span class="sd">       Number of processors to use, by default is 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span> <span class="p">,</span><span class="n">selection1</span> <span class="p">,</span><span class="n">selection2</span><span class="p">,</span> <span class="n">t0</span> <span class="p">,</span> <span class="n">tf</span> <span class="p">,</span> <span class="n">dtmax</span><span class="p">,</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection1</span> <span class="o">=</span> <span class="n">selection1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span> <span class="o">=</span> <span class="n">selection2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtmax</span> <span class="o">=</span> <span class="n">dtmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">=</span> <span class="n">nproc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_getC_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function give the intermitent Hydrogen Bond Lifetime</span>
<span class="sd">        C_i = &lt;h(t0)h(t)&gt;/&lt;h(t0)&gt; between t0 and t</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HBP</span><span class="p">[</span><span class="n">t0</span><span class="p">])):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HBP</span><span class="p">[</span><span class="n">t</span><span class="p">])):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">HBP</span><span class="p">[</span><span class="n">t0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">HBP</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">HBP</span><span class="p">[</span><span class="n">t0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">HBP</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">C_i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">HBP</span><span class="p">[</span><span class="n">t0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">C_i</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">HBP</span><span class="p">[</span><span class="n">t0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_getC_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function give the continous Hydrogen Bond Lifetime</span>
<span class="sd">        C_c = &lt;h(t0)h&#39;(t)&gt;/&lt;h(t0)&gt; between t0 and t</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C_c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">begt0</span> <span class="o">=</span> <span class="n">t0</span>
        <span class="n">HBP_cp</span> <span class="o">=</span> <span class="n">HBP</span>
        <span class="n">HBP_t0</span> <span class="o">=</span> <span class="n">HBP</span><span class="p">[</span><span class="n">t0</span><span class="p">]</span>
        <span class="n">newHBP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">t0</span><span class="o">==</span><span class="n">t</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">while</span> <span class="n">t0</span><span class="o">+</span><span class="n">dt</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HBP_t0</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HBP_cp</span><span class="p">[</span><span class="n">t0</span><span class="o">+</span><span class="n">dt</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">HBP_t0</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">HBP_cp</span><span class="p">[</span><span class="n">t0</span><span class="o">+</span><span class="n">dt</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">HBP_t0</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">HBP_cp</span><span class="p">[</span><span class="n">t0</span><span class="o">+</span><span class="n">dt</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">newHBP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HBP_t0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="k">break</span>
            <span class="n">C_c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newHBP</span><span class="p">)</span>
            <span class="n">t0</span> <span class="o">+=</span> <span class="n">dt</span>
            <span class="n">HBP_t0</span> <span class="o">=</span> <span class="n">newHBP</span>
            <span class="n">newHBP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">HBP</span><span class="p">[</span><span class="n">begt0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">C_c</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HBP</span><span class="p">[</span><span class="n">begt0</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_intervC_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets all the data for the h(t0)h(t0+dt)&#39;, where</span>
<span class="sd">        t0 = 1,2,3,...,tf. This function give us one point of the final graphic</span>
<span class="sd">        HBL vs t</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HBP</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t0</span><span class="o">+</span><span class="n">dt</span> <span class="o">&lt;=</span> <span class="n">tf</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">t0</span> <span class="o">==</span> <span class="n">t0</span><span class="o">+</span><span class="n">dt</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getC_c</span><span class="p">(</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">t0</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getC_c</span><span class="p">(</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">t0</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span>
                <span class="n">t0</span> <span class="o">+=</span> <span class="n">dt</span>
                <span class="n">a</span> <span class="o">+=</span> <span class="n">b</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">/</span><span class="n">count</span>

    <span class="k">def</span> <span class="nf">_intervC_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets all the data for the h(t0)h(t0+dt), where</span>
<span class="sd">        t0 = 1,2,3,...,tf. This function give us a point of the final graphic</span>
<span class="sd">        HBL vs t</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HBP</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t0</span><span class="o">+</span><span class="n">dt</span> <span class="o">&lt;=</span> <span class="n">tf</span> <span class="p">):</span>
                <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getC_i</span><span class="p">(</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">t0</span><span class="o">+</span><span class="n">dt</span><span class="p">)</span>
                <span class="n">t0</span> <span class="o">+=</span> <span class="n">dt</span>
                <span class="n">a</span> <span class="o">+=</span> <span class="n">b</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">/</span><span class="n">count</span>

    <span class="k">def</span> <span class="nf">_finalGraphGetC_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">maxdt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets the final data of the C_i graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxdt</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intervC_i</span><span class="p">(</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_finalGraphGetC_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">maxdt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets the final data of the C_c graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxdt</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intervC_c</span><span class="p">(</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_getGraphics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">maxdt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that join all the results into a graphics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalGraphGetC_c</span><span class="p">(</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">maxdt</span><span class="p">)</span>
        <span class="n">inte</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalGraphGetC_i</span><span class="p">(</span><span class="n">HBP</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">maxdt</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cont</span><span class="p">)):</span>
            <span class="n">fix</span> <span class="o">=</span> <span class="p">[</span><span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">inte</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span> <span class="nf">_HBA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">selAtom1</span><span class="p">,</span> <span class="n">selAtom2</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main function for calculate C_i and C_c in parallel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">finalGetResidue1</span> <span class="o">=</span> <span class="n">selAtom1</span>
        <span class="n">finalGetResidue2</span> <span class="o">=</span> <span class="n">selAtom2</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">hbonds</span><span class="o">.</span><span class="n">HydrogenBondAnalysis</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span> <span class="n">finalGetResidue1</span><span class="p">,</span>
                                                            <span class="n">finalGetResidue2</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">3.5</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mf">120.0</span><span class="p">,</span>
                                                            <span class="n">start</span><span class="o">=</span><span class="n">frame</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">frame</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">h</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;error&quot;</span>
                <span class="k">print</span> <span class="s">&quot;trying again&quot;</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">timeseries</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<div class="viewcode-block" id="HydrogenBondLifetimes.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/waterdynamics.html#MDAnalysis.analysis.waterdynamics.HydrogenBondLifetimes.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyze trajectory and produce timeseries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">):</span>
                    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">k</span><span class="o">=</span><span class="n">i</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nproc</span><span class="p">):</span>
                        <span class="c">#start</span>
                        <span class="k">print</span> <span class="s">&quot;ts=&quot;</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="n">conn_parent</span><span class="p">,</span> <span class="n">conn_child</span>  <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
                        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="c">#new thread</span>
                                <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">(</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span>
                                            <span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_HBA</span><span class="p">,</span>
                                            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">conn_child</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">,)),</span>
                                     <span class="n">conn_parent</span><span class="p">))</span>
                                <span class="k">break</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">print</span> <span class="s">&quot;error in jobs.append&quot;</span>
                        <span class="n">jobs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nproc</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="n">rec01</span> <span class="o">=</span> <span class="n">jobs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">received</span> <span class="o">=</span> <span class="n">rec01</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
                        <span class="n">h_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">received</span><span class="p">)</span>
                        <span class="n">jobs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getGraphics</span><span class="p">(</span> <span class="n">h_list</span> <span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="o">-</span><span class="mi">1</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtmax</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h_list</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">hbonds</span><span class="o">.</span><span class="n">HydrogenBondAnalysis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection1</span><span class="p">,</span>
                                                                     <span class="bp">self</span><span class="o">.</span><span class="n">selection2</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="mf">3.5</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mf">120.0</span><span class="p">)</span>
            <span class="n">h_list</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getGraphics</span><span class="p">(</span><span class="n">h_list</span><span class="o">.</span><span class="n">timeseries</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtmax</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="WaterOrientationalRelaxation"><a class="viewcode-back" href="../../../documentation_pages/analysis/waterdynamics.html#MDAnalysis.analysis.waterdynamics.WaterOrientationalRelaxation">[docs]</a><span class="k">class</span> <span class="nc">WaterOrientationalRelaxation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Function to evaluate the Water Orientational Relaxation proposed by Yu-ling Yeh</span>
<span class="sd">    and Chung-Yuan Mou [Yeh1999_]. WaterOrientationalRelaxation indicates &quot;how fast&quot; water molecules are rotating</span>
<span class="sd">    or changing direction. This is a time correlation function given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        C_{\hat u}(\tau)=\langle \mathit{P}_2[\mathbf{\hat{u}}(t_0)\cdot\mathbf{\hat{u}}(t_0+\tau)]\rangle</span>

<span class="sd">    where :math:`P_2=(3x^2-1)/2` is the second-order Legendre polynomial and :math:`\hat{u}` is</span>
<span class="sd">    a unit vector along HH, OH or dipole vector.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *universe*</span>
<span class="sd">         Universe object</span>
<span class="sd">      *selection*</span>
<span class="sd">       Selection string, only models with 3 atoms molecules are allowed (TIP3, TIP3P, etc)</span>
<span class="sd">      *t0*</span>
<span class="sd">       Time where analysis begin</span>
<span class="sd">      *tf*</span>
<span class="sd">       Time where analysis end</span>
<span class="sd">      *dtmax*</span>
<span class="sd">       Maximum dt size window, dtmax &lt; tf or it will crash.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">dtmax</span><span class="p">,</span><span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">tf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtmax</span><span class="o">=</span> <span class="n">dtmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">=</span> <span class="n">nproc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_repeatedIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">totalFrames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicate the comparation between all the t+dt.</span>
<span class="sd">        The results is a list of list with all the repeated index per frame (or time).</span>
<span class="sd">        Ex: dt=1, so compare frames (1,2),(2,3),(3,4)...</span>
<span class="sd">        Ex: dt=2, so compare frames (1,3),(3,5),(5,7)...</span>
<span class="sd">        Ex: dt=3, so compare frames (1,4),(4,7),(7,10)...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rep</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span> <span class="p">(</span><span class="n">totalFrames</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>  <span class="n">dt</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">dt</span> <span class="o">&lt;</span> <span class="n">totalFrames</span> <span class="p">):</span>
                <span class="n">rep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sameMolecTandDT</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span><span class="n">dt</span><span class="o">*</span><span class="n">i</span><span class="p">,(</span><span class="n">dt</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">dt</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rep</span>

    <span class="k">def</span> <span class="nf">_getOneDeltaPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span> <span class="n">repInd</span><span class="p">,</span> <span class="n">i</span> <span class="p">,</span><span class="n">t0</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give one point to promediate and get one point of the graphic  C_vect vs t</span>
<span class="sd">        Ex: t0=1 and tau=1 so calculate the t0-tau=1-2 intervale.</span>
<span class="sd">        Ex: t0=5 and tau=3 so calcultate the t0-tau=5-8 intervale.</span>
<span class="sd">        i = come from getMeanOnePoint (named j) (int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valOH</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">valHH</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">valdip</span><span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">repInd</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">begj</span> <span class="o">=</span>  <span class="mi">3</span><span class="o">*</span><span class="n">j</span>
            <span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">t0</span><span class="p">]</span>
            <span class="n">Ot0</span> <span class="o">=</span> <span class="n">repInd</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">begj</span><span class="p">]</span>
            <span class="n">H1t0</span> <span class="o">=</span> <span class="n">repInd</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">begj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">H2t0</span> <span class="o">=</span> <span class="n">repInd</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">begj</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">OHVector0</span> <span class="o">=</span> <span class="n">H1t0</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">Ot0</span><span class="o">.</span><span class="n">position</span>
            <span class="n">HHVector0</span> <span class="o">=</span> <span class="n">H1t0</span><span class="o">.</span><span class="n">position</span><span class="o">-</span><span class="n">H2t0</span><span class="o">.</span><span class="n">position</span>
            <span class="n">dipVector0</span> <span class="o">=</span> <span class="p">((</span><span class="n">H1t0</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">H2t0</span><span class="o">.</span><span class="n">position</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span><span class="o">-</span><span class="n">Ot0</span><span class="o">.</span><span class="n">position</span>

            <span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">t0</span><span class="o">+</span><span class="n">dt</span><span class="p">]</span>
            <span class="n">Otp</span> <span class="o">=</span> <span class="n">repInd</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">begj</span><span class="p">]</span>
            <span class="n">H1tp</span> <span class="o">=</span> <span class="n">repInd</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">begj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">H2tp</span> <span class="o">=</span> <span class="n">repInd</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">begj</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>

            <span class="n">OHVectorp</span> <span class="o">=</span> <span class="n">H1tp</span><span class="o">.</span><span class="n">position</span><span class="o">-</span> <span class="n">Otp</span><span class="o">.</span><span class="n">position</span>
            <span class="n">HHVectorp</span> <span class="o">=</span> <span class="n">H1tp</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">H2tp</span><span class="o">.</span><span class="n">position</span>
            <span class="n">dipVectorp</span> <span class="o">=</span> <span class="p">((</span><span class="n">H1tp</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">H2tp</span><span class="o">.</span><span class="n">position</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span><span class="o">-</span><span class="n">Otp</span><span class="o">.</span><span class="n">position</span>

            <span class="n">normOHVector0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">OHVector0</span><span class="p">)</span>
            <span class="n">normOHVectorp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">OHVectorp</span><span class="p">)</span>
            <span class="n">normHHVector0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">HHVector0</span><span class="p">)</span>
            <span class="n">normHHVectorp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">HHVectorp</span><span class="p">)</span>
            <span class="n">normdipVector0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dipVector0</span><span class="p">)</span>
            <span class="n">normdipVectorp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dipVectorp</span><span class="p">)</span>

            <span class="n">unitOHVector0</span> <span class="o">=</span> <span class="p">[</span><span class="n">OHVector0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">normOHVector0</span><span class="p">,</span><span class="n">OHVector0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">normOHVector0</span><span class="p">,</span><span class="n">OHVector0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">normOHVector0</span><span class="p">]</span>
            <span class="n">unitOHVectorp</span> <span class="o">=</span> <span class="p">[</span><span class="n">OHVectorp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">normOHVectorp</span><span class="p">,</span><span class="n">OHVectorp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">normOHVectorp</span><span class="p">,</span><span class="n">OHVectorp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">normOHVectorp</span><span class="p">]</span>
            <span class="n">unitHHVector0</span> <span class="o">=</span> <span class="p">[</span><span class="n">HHVector0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">normHHVector0</span><span class="p">,</span><span class="n">HHVector0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">normHHVector0</span><span class="p">,</span><span class="n">HHVector0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">normHHVector0</span><span class="p">]</span>
            <span class="n">unitHHVectorp</span> <span class="o">=</span> <span class="p">[</span><span class="n">HHVectorp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">normHHVectorp</span><span class="p">,</span><span class="n">HHVectorp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">normHHVectorp</span><span class="p">,</span><span class="n">HHVectorp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">normHHVectorp</span><span class="p">]</span>
            <span class="n">unitdipVector0</span> <span class="o">=</span> <span class="p">[</span><span class="n">dipVector0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">normdipVector0</span><span class="p">,</span><span class="n">dipVector0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">normdipVector0</span><span class="p">,</span><span class="n">dipVector0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">normdipVector0</span><span class="p">]</span>
            <span class="n">unitdipVectorp</span> <span class="o">=</span> <span class="p">[</span><span class="n">dipVectorp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">normdipVectorp</span><span class="p">,</span><span class="n">dipVectorp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">normdipVectorp</span><span class="p">,</span><span class="n">dipVectorp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">normdipVectorp</span><span class="p">]</span>

            <span class="n">valOH</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lg2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unitOHVector0</span><span class="p">,</span><span class="n">unitOHVectorp</span><span class="p">))</span>
            <span class="n">valHH</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lg2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unitHHVector0</span><span class="p">,</span><span class="n">unitHHVectorp</span><span class="p">))</span>
            <span class="n">valdip</span> <span class="o">+=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">lg2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unitdipVector0</span><span class="p">,</span><span class="n">unitdipVectorp</span><span class="p">))</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">valOH</span> <span class="o">=</span> <span class="n">valOH</span><span class="o">/</span><span class="n">n</span>
        <span class="n">valHH</span> <span class="o">=</span> <span class="n">valHH</span><span class="o">/</span><span class="n">n</span>
        <span class="n">valdip</span> <span class="o">=</span> <span class="n">valdip</span><span class="o">/</span><span class="n">n</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">valOH</span><span class="p">,</span><span class="n">valHH</span><span class="p">,</span><span class="n">valdip</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getMeanOnePoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection1</span><span class="p">,</span><span class="n">selection_str</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">totalFrames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function get one point of the graphic C_OH vs t. It uses the</span>
<span class="sd">        _getOneDeltaPoint() function to calculate the average.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">repInd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repeatedIndex</span><span class="p">(</span><span class="n">selection1</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">totalFrames</span><span class="p">)</span>
        <span class="n">sumsdt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">sumDeltaOH</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">sumDeltaHH</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">sumDeltadip</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">valOHList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">valHHList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">valdipList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">totalFrames</span><span class="o">/</span><span class="n">dt</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getOneDeltaPoint</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="n">repInd</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">sumsdt</span><span class="p">,</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">sumDeltaOH</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sumDeltaHH</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sumDeltadip</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">valOHList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">valHHList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">valdipList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">sumsdt</span> <span class="o">+=</span>  <span class="n">dt</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">sumDeltaOH</span><span class="o">/</span><span class="n">n</span><span class="p">,</span><span class="n">sumDeltaHH</span><span class="o">/</span><span class="n">n</span><span class="p">,</span><span class="n">sumDeltadip</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sameMolecTandDT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span><span class="n">t0d</span><span class="p">,</span><span class="n">tf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare the molecules in the t0d selection and the t0d+dt selection and</span>
<span class="sd">        select only the particles that are repeated in both frame. This is to consider</span>
<span class="sd">        only the molecules that remains in the selection after the dt time has elapsed.</span>
<span class="sd">        The result is a list with the indexs of the atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="n">t0d</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="n">tf</span><span class="p">])</span>
        <span class="n">sort</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">sort</span>

    <span class="k">def</span> <span class="nf">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection_str</span><span class="p">):</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
            <span class="n">selection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">selection_str</span><span class="p">))</span>
            <span class="k">print</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
        <span class="k">return</span> <span class="n">selection</span>

    <span class="c"># Second Legendre polynomial</span>
    <span class="n">lg2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span><span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

<div class="viewcode-block" id="WaterOrientationalRelaxation.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/waterdynamics.html#MDAnalysis.analysis.waterdynamics.WaterOrientationalRelaxation.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyze trajectory and produce timeseries</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c">#All the selection to an array, this way is faster than selecting later.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">selection_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#selection_out = self._selection_parallel(self.universe,self.selection,self.nproc)</span>
            <span class="c">#parallel selection to be implemented</span>
            <span class="n">selection_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dtmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMeanOnePoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span><span class="n">selection_out</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>


</div></div>
<div class="viewcode-block" id="AngularDistribution"><a class="viewcode-back" href="../../../documentation_pages/analysis/waterdynamics.html#MDAnalysis.analysis.waterdynamics.AngularDistribution">[docs]</a><span class="k">class</span> <span class="nc">AngularDistribution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    The angular distribution function (AD) is defined as the distribution</span>
<span class="sd">    probability of the cosine of the :math:`\theta` angle formed by the OH vector, HH vector</span>
<span class="sd">    or dipolar vector of water molecules and a vector :math:`\hat n` parallel to chosen axis</span>
<span class="sd">    (z is the default value). The cosine is define as :math:`\cos \theta = \hat u \cdot \hat n`, where :math:`\hat u` is OH, HH or dipole vector.</span>
<span class="sd">    It creates a histogram and returns a list of lists, see Output_. The AD is also know as Angular Probability (AP).</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    :Arguments:</span>
<span class="sd">         *universe*</span>
<span class="sd">             Universe object</span>
<span class="sd">         *selection*</span>
<span class="sd">             Selection string to evaluate its angular distribution [‘byres name OH2’]</span>
<span class="sd">         *bins*</span>
<span class="sd">             Number of bins to create the histogram by means of numpy.histogram_ [40]</span>
<span class="sd">         *axis*</span>
<span class="sd">             Axis to create angle with the vector (HH, OH or dipole) and calculate cosine theta [&#39;z&#39;]. Options: &#39;x&#39;,</span>
<span class="sd">             &#39;y&#39;, &#39;z&#39;</span>

<span class="sd">    .. _numpy.histogram: http://docs.scipy.org/doc/np/reference/generated/np.histogram.html</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection_str</span><span class="p">,</span><span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span><span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="s">&quot;z&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_str</span> <span class="o">=</span> <span class="n">selection_str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">=</span> <span class="n">nproc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_getCosTheta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span><span class="n">axis</span><span class="p">):</span>
        <span class="n">valOH</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">valHH</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">valdip</span><span class="o">=</span> <span class="p">[]</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">selection</span><span class="p">[</span> <span class="n">i</span> <span class="p">]</span><span class="o">.</span><span class="n">positions</span>

            <span class="n">Ot0</span> <span class="o">=</span> <span class="n">line</span><span class="p">[::</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">H1t0</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">H2t0</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span>

            <span class="n">OHVector0</span> <span class="o">=</span> <span class="n">H1t0</span> <span class="o">-</span> <span class="n">Ot0</span>
            <span class="n">HHVector0</span> <span class="o">=</span> <span class="n">H1t0</span> <span class="o">-</span> <span class="n">H2t0</span>
            <span class="n">dipVector0</span> <span class="o">=</span> <span class="p">(</span><span class="n">H1t0</span> <span class="o">+</span> <span class="n">H2t0</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">Ot0</span>

            <span class="n">unitOHVector0</span> <span class="o">=</span> <span class="n">OHVector0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">OHVector0</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)[:,</span><span class="bp">None</span><span class="p">]</span>
            <span class="n">unitHHVector0</span> <span class="o">=</span> <span class="n">HHVector0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">HHVector0</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)[:,</span><span class="bp">None</span><span class="p">]</span>
            <span class="n">unitdipVector0</span> <span class="o">=</span> <span class="n">dipVector0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dipVector0</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)[:,</span><span class="bp">None</span><span class="p">]</span>

            <span class="n">j</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s">&quot;z&quot;</span><span class="p">:</span>
                    <span class="n">valOH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitOHVector0</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">valHH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitHHVector0</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">valdip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitdipVector0</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s">&quot;x&quot;</span><span class="p">:</span>
                    <span class="n">valOH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitOHVector0</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">valHH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitHHVector0</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">valdip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitdipVector0</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s">&quot;y&quot;</span><span class="p">:</span>
                    <span class="n">valOH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitOHVector0</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">valHH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitHHVector0</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">valdip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unitdipVector0</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">valOH</span><span class="p">,</span><span class="n">valHH</span><span class="p">,</span><span class="n">valdip</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getHistogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function gets a normalized histogram of the cos(theta) values. It return a list of list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getCosTheta</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">cosThetaOH</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cosThetaHH</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cosThetadip</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">lencosThetaOH</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cosThetaOH</span><span class="p">)</span>
        <span class="n">lencosThetaHH</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cosThetaHH</span><span class="p">)</span>
        <span class="n">lencosThetadip</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cosThetadip</span><span class="p">)</span>
        <span class="n">histInterval</span> <span class="o">=</span> <span class="n">bins</span>
        <span class="n">histcosThetaOH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">cosThetaOH</span><span class="p">,</span><span class="n">histInterval</span><span class="p">,</span> <span class="n">normed</span>  <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">histcosThetaHH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">cosThetaHH</span><span class="p">,</span><span class="n">histInterval</span><span class="p">,</span> <span class="n">normed</span>  <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">histcosThetadip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">cosThetadip</span><span class="p">,</span><span class="n">histInterval</span><span class="p">,</span> <span class="n">normed</span>  <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">histcosThetaOH</span><span class="p">,</span><span class="n">histcosThetaHH</span><span class="p">,</span><span class="n">histcosThetadip</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hist2column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">aList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function transform from the histogram format</span>
<span class="sd">        to a column format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip_longest</span><span class="p">(</span><span class="o">*</span><span class="n">aList</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="s">&quot;.&quot;</span><span class="p">):</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">a</span>

<div class="viewcode-block" id="AngularDistribution.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/waterdynamics.html#MDAnalysis.analysis.waterdynamics.AngularDistribution.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to evaluate the angular distribution of cos(theta)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#not implemented yet</span>
            <span class="c">#selection = self._selection_parallel(self.universe,self.selection_str,self.nproc)</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_str</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">output</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_getHistogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        <span class="c">#this is to format the exit of the file</span>
        <span class="c">#maybe this output could be improved</span>
        <span class="n">listOH</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span><span class="nb">list</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span>
        <span class="n">listHH</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span><span class="nb">list</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span>
        <span class="n">listdip</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span><span class="nb">list</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hist2column</span><span class="p">(</span><span class="n">listOH</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hist2column</span><span class="p">(</span><span class="n">listHH</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hist2column</span><span class="p">(</span><span class="n">listdip</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection_str</span><span class="p">):</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
            <span class="n">selection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">selection_str</span><span class="p">))</span>
            <span class="k">print</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
        <span class="k">return</span> <span class="n">selection</span>

</div>
<div class="viewcode-block" id="MeanSquareDisplacement"><a class="viewcode-back" href="../../../documentation_pages/analysis/waterdynamics.html#MDAnalysis.analysis.waterdynamics.MeanSquareDisplacement">[docs]</a><span class="k">class</span>  <span class="nc">MeanSquareDisplacement</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Function to evaluate the Mean Square Displacement (MSD_). The MSD gives the average distance that</span>
<span class="sd">    particles travels. The MSD is given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \langle\Delta r(t)^2\rangle = 2nDt</span>

<span class="sd">    where :math:`r(t)` is the position of particle in time :math:`t`, :math:`\Delta r(t)` is the displacement</span>
<span class="sd">    after time lag :math:`t`, :math:`n` is the dimensionality, in this case :math:`n=3`, :math:`D` is the diffusion</span>
<span class="sd">    coefficient and :math:`t` is the time.</span>

<span class="sd">    .. _MSD: http://en.wikipedia.org/wiki/Mean_squared_displacement</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *universe*</span>
<span class="sd">         Universe object</span>
<span class="sd">      *selection*</span>
<span class="sd">         Selection string</span>
<span class="sd">      *t0*</span>
<span class="sd">         Time where analysis begin</span>
<span class="sd">      *tf*</span>
<span class="sd">         Time where analysis end</span>
<span class="sd">      *dtmax*</span>
<span class="sd">         Maximum dt size window, dtmax &lt; tf or it will crash.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">dtmax</span><span class="p">,</span><span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">tf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtmax</span><span class="o">=</span> <span class="n">dtmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">=</span> <span class="n">nproc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_repeatedIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">totalFrames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicate the comparation between all the t+dt.</span>
<span class="sd">        The results is a list of list with all the repeated index per frame (or time).</span>
<span class="sd">        Ex: dt=1, so compare frames (1,2),(2,3),(3,4)...</span>
<span class="sd">        Ex: dt=2, so compare frames (1,3),(3,5),(5,7)...</span>
<span class="sd">        Ex: dt=3, so compare frames (1,4),(4,7),(7,10)...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rep</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span> <span class="p">(</span><span class="n">totalFrames</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>  <span class="n">dt</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">dt</span> <span class="o">&lt;</span> <span class="n">totalFrames</span> <span class="p">):</span>
                <span class="n">rep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sameMolecTandDT</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span><span class="n">dt</span><span class="o">*</span><span class="n">i</span><span class="p">,(</span><span class="n">dt</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">dt</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rep</span>

    <span class="k">def</span> <span class="nf">_getOneDeltaPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span> <span class="n">repInd</span><span class="p">,</span> <span class="n">i</span> <span class="p">,</span><span class="n">t0</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give one point to promediate and get one point of the grapic  C_vect vs t</span>
<span class="sd">        Ex: t0=1 and dt=1 so calculate the t0-dt=1-2 intervale.</span>
<span class="sd">        Ex: t0=5 and dt=3 so calcultate the t0-dt=5-8 intervale</span>
<span class="sd">        i = come from getMeanOnePoint (named j) (int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valO</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">repInd</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">begj</span> <span class="o">=</span>  <span class="mi">3</span><span class="o">*</span><span class="n">j</span>
            <span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">t0</span><span class="p">]</span>
            <span class="c">#Plus zero is to avoid 0to be equal to 0tp</span>
            <span class="n">Ot0</span> <span class="o">=</span> <span class="n">repInd</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">begj</span><span class="p">]</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="mi">0</span>

            <span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">t0</span><span class="o">+</span><span class="n">dt</span><span class="p">]</span>
            <span class="c">#Plus zero is to avoid 0to be equal to 0tp</span>
            <span class="n">Otp</span> <span class="o">=</span> <span class="n">repInd</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">begj</span><span class="p">]</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="mi">0</span>

            <span class="c">#position oxygen</span>
            <span class="n">OVector</span> <span class="o">=</span> <span class="n">Ot0</span> <span class="o">-</span> <span class="n">Otp</span>
            <span class="c">#here it is the difference with waterdynamics.WaterOrientationalRelaxation</span>
            <span class="n">valO</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">OVector</span><span class="p">,</span> <span class="n">OVector</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">valO</span> <span class="o">=</span> <span class="n">valO</span><span class="o">/</span><span class="n">n</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">valO</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getMeanOnePoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection1</span><span class="p">,</span><span class="n">selection_str</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">totalFrames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function get one point of the graphic C_OH vs t. It&#39;s uses the</span>
<span class="sd">        _getOneDeltaPoint() function to calculate the average.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">repInd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repeatedIndex</span><span class="p">(</span><span class="n">selection1</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">totalFrames</span><span class="p">)</span>
        <span class="n">sumsdt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">sumDeltaO</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">valOList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">totalFrames</span><span class="o">/</span><span class="n">dt</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getOneDeltaPoint</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="n">repInd</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">sumsdt</span><span class="p">,</span><span class="n">dt</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;a=&quot;</span><span class="p">,</span><span class="n">a</span>
            <span class="n">sumDeltaO</span> <span class="o">+=</span> <span class="n">a</span>
            <span class="n">valOList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">sumsdt</span> <span class="o">+=</span>  <span class="n">dt</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">sumDeltaO</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sameMolecTandDT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span><span class="n">t0d</span><span class="p">,</span><span class="n">tf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare the molecules in the t0d selection and the t0d+dt selection and</span>
<span class="sd">        select only the particles that are repeated in both frame. This is to consider</span>
<span class="sd">        only the molecules that remains in the selection after the dt time has elapsed.</span>
<span class="sd">        The result is a list with the indexs of the atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="n">t0d</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="n">tf</span><span class="p">])</span>
        <span class="n">sort</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">sort</span>

    <span class="k">def</span> <span class="nf">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection_str</span><span class="p">):</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
            <span class="n">selection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">selection_str</span><span class="p">))</span>
            <span class="k">print</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
        <span class="k">return</span> <span class="n">selection</span>

<div class="viewcode-block" id="MeanSquareDisplacement.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/waterdynamics.html#MDAnalysis.analysis.waterdynamics.MeanSquareDisplacement.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyze trajectory and produce timeseries</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c">#All the selection to an array, this way is faster than selecting later.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">selection_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#parallel not yet implemented</span>
            <span class="c">#selection = selection_parallel(universe,selection_str,nproc)</span>
            <span class="n">selection_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dtmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMeanOnePoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span><span class="n">selection_out</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="SurvivalProbability"><a class="viewcode-back" href="../../../documentation_pages/analysis/waterdynamics.html#MDAnalysis.analysis.waterdynamics.SurvivalProbability">[docs]</a><span class="k">class</span> <span class="nc">SurvivalProbability</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Function to evaluate the Survival Probability (SP). The SP gives the probability</span>
<span class="sd">    for a group of particles to remain in certain region. The SP is given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        P(\tau) = \frac1T \sum_{t=1}^T \frac{N(t,t+\tau)}{N(t)}</span>

<span class="sd">    where :math:`T` is the maximum time of simulation, :math:`\tau` is the timestep and</span>
<span class="sd">    :math:`N` the number of particles in certain time.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    :Arguments:</span>
<span class="sd">     *universe*</span>
<span class="sd">        Universe object</span>
<span class="sd">     *selection*</span>
<span class="sd">      Selection string, any selection is allowed, with this selection you define the region/zone where</span>
<span class="sd">      to analize, i.e.: &quot;selection_a&quot; and &quot;zone&quot; (see SP examples_ )</span>
<span class="sd">     *t0*</span>
<span class="sd">      Time where analysis begin</span>
<span class="sd">     *tf*</span>
<span class="sd">      Time where analysis end</span>
<span class="sd">     *dtmax*</span>
<span class="sd">      Maximum dt size window, dtmax &lt; tf or it will crash</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">tf</span><span class="p">,</span><span class="n">dtmax</span><span class="p">,</span><span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">tf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtmax</span><span class="o">=</span> <span class="n">dtmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">=</span> <span class="n">nproc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_getOneDeltaPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span> <span class="n">totalFrames</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give one point to promediate and get one point of the graphic  C_vect vs t</span>
<span class="sd">        Ex: t0=1 and tau=1 so calculate the t0-tau=1-2 intervale.</span>
<span class="sd">        Ex: t0=5 and tau=3 so calcultate the t0-tau=5-8 intervale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ntau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NumPart_tau</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">totalFrames</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
        <span class="n">Nt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NumPart</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span><span class="n">t0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Ntau</span><span class="o">/</span><span class="n">Nt</span>

    <span class="k">def</span> <span class="nf">_getMeanOnePoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection1</span><span class="p">,</span><span class="n">selection_str</span><span class="p">,</span><span class="n">wint</span><span class="p">,</span><span class="n">totalFrames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function get one point of the graphic P(t) vs t. It uses the</span>
<span class="sd">        _getOneDeltaPoint() function to calculate the average.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">sumDeltaP</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">totalFrames</span><span class="o">-</span><span class="n">wint</span><span class="p">):</span>
            <span class="c">#This &quot;try&quot; is to avoid a division by zero when there is no particles in time t0,</span>
            <span class="c">#this happens in very small selection regions.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getOneDeltaPoint</span><span class="p">(</span><span class="n">selection1</span><span class="p">,</span><span class="n">totalFrames</span> <span class="p">,</span><span class="n">frame</span><span class="p">,</span> <span class="n">wint</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">sumDeltaP</span> <span class="o">+=</span> <span class="n">a</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">sumDeltaP</span><span class="o">/</span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">_NumPart_tau</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">selection</span><span class="p">,</span> <span class="n">totalFrames</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span><span class="n">tau</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare the molecules in t0 selection and t0+tau selection and</span>
<span class="sd">        select only the particles that remaing from t0 to t0+tau. It returns</span>
<span class="sd">        the number of remaining particles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="n">t0</span><span class="p">])</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">t0</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">t0</span><span class="o">+</span><span class="n">tau</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t0</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">totalFrames</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="n">t0</span><span class="o">+</span><span class="n">i</span><span class="p">])</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_NumPart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">universe</span><span class="p">,</span><span class="n">selection_str</span><span class="p">):</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
            <span class="n">selection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">selection_str</span><span class="p">))</span>
            <span class="k">print</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
        <span class="k">return</span> <span class="n">selection</span>

<div class="viewcode-block" id="SurvivalProbability.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/waterdynamics.html#MDAnalysis.analysis.waterdynamics.SurvivalProbability.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyze trajectory and produce timeseries</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c">#All the selection to an array, this way is faster than selecting later.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">selection_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#selection = selection_parallel(universe,selection_str,nproc)</span>
            <span class="c">#parallel selection to be implemented</span>
            <span class="n">selection_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selection_serial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dtmax</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getMeanOnePoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span> <span class="n">selection_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.12.1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman, Jonathan Barnoud,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domański, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yáñez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>