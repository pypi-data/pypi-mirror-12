<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3.1.5. Calculating path similarity — MDAnalysis.analysis.psa &mdash; MDAnalysis 0.12.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.12.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.12.1 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.12.1 documentation" href="../../index.html" />
    <link rel="up" title="3. Analysis modules" href="../analysis_modules.html" />
    <link rel="next" title="3.2.1. Hydrogen Bond analysis — MDAnalysis.analysis.hbonds.hbond_analysis" href="hbond_analysis.html" />
    <link rel="prev" title="3.1.4. Calculating root mean square quantities — MDAnalysis.analysis.rms" href="rms.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="hbond_analysis.html" title="3.2.1. Hydrogen Bond analysis — MDAnalysis.analysis.hbonds.hbond_analysis"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="rms.html" title="3.1.4. Calculating root mean square quantities — MDAnalysis.analysis.rms"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">MDAnalysis 0.12.1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../analysis_modules.html" accesskey="U">3. Analysis modules</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.1.5. Calculating path similarity &#8212; <code class="docutils literal"><span class="pre">MDAnalysis.analysis.psa</span></code></a><ul>
<li><a class="reference internal" href="#helper-functions-and-variables">3.1.5.1. Helper functions and variables</a></li>
<li><a class="reference internal" href="#classes-methods-and-functions">3.1.5.2. Classes, methods, and functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="rms.html"
                        title="previous chapter">3.1.4. Calculating root mean square quantities &#8212; <code class="docutils literal"><span class="pre">MDAnalysis.analysis.rms</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="hbond_analysis.html"
                        title="next chapter">3.2.1. Hydrogen Bond analysis &#8212; <code class="docutils literal"><span class="pre">MDAnalysis.analysis.hbonds.hbond_analysis</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/documentation_pages/analysis/psa.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-MDAnalysis.analysis.psa"></span><div class="section" id="calculating-path-similarity-mdanalysis-analysis-psa">
<h1>3.1.5. Calculating path similarity &#8212; <a class="reference internal" href="#module-MDAnalysis.analysis.psa" title="MDAnalysis.analysis.psa"><code class="xref py py-mod docutils literal"><span class="pre">MDAnalysis.analysis.psa</span></code></a><a class="headerlink" href="#calculating-path-similarity-mdanalysis-analysis-psa" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Sean Seyler</td>
</tr>
<tr class="field-even field"><th class="field-name">Year:</th><td class="field-body">2015</td>
</tr>
<tr class="field-odd field"><th class="field-name">Copyright:</th><td class="field-body">GNU Public License v3</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
<p>The module contains code to calculate the geometric similarity of trajectories
using path metrics such as the Hausdorff or Fréchet distances
<a class="reference internal" href="#seyler2015" id="id1">[Seyler2015]</a>. The path metrics are functions of two paths and return a
nonnegative number, i.e., a distance. Two paths are identical if their distance
is zero, and large distances indicate dissimilarity. Each path metric is a
function of the individual points (e.g., coordinate snapshots) that comprise
each path and, loosely speaking, identify the two points, one per path of a
pair of paths, where the paths deviate the most.  The distance between these
points of maximal deviation is measured by the root mean square deviation
(RMSD), i.e., to compute structural similarity.</p>
<p>One typically computes the pairwise similarity for an ensemble of paths to
produce a symmetric distance matrix, which can be clustered to, at a glance,
identify patterns in the trajectory data. To properly analyze a path ensemble,
one must select a suitable reference structure to which all paths (each
conformer in each path) will be universally aligned using the rotations
determined by the best-fit rmsds. Distances between paths and their structures
are then computed directly with no further alignment. This pre-processing step
is necessary to preserve the metric properties of the Hausdorff and Fréchet
metrics; using the best-fit rmsd on a pairwise basis does not generally
preserve the triangle inequality.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference external" href="https://github.com/Becksteinlab/PSAnalysisTutorial">PSAnalysisTutorial</a> outlines a typical application of PSA to
a set of trajectories, including doing proper alignment,
performing distance comparisons, and generating heat
map-dendrogram plots from hierarchical clustering.</p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="seyler2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Seyler2015]</a></td><td>Sean L. Seyler, Avishek Kumar, Michael F. Thorpe, Oliver Beckstein.
<em>Path Similarity Analysis: a Method for Quantifying Macromolecular
Pathways.</em> <a class="reference external" href="http://arxiv.org/abs/1505.04807">arXiv:1505.04807</a> (2015).</td></tr>
</tbody>
</table>
<div class="section" id="helper-functions-and-variables">
<h2>3.1.5.1. Helper functions and variables<a class="headerlink" href="#helper-functions-and-variables" title="Permalink to this headline">¶</a></h2>
<p>The following convenience functions are used by other functions in this module.</p>
<dl class="function">
<dt id="MDAnalysis.analysis.psa.sqnorm">
<code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">sqnorm</code><span class="sig-paren">(</span><em>v</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#sqnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.sqnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of squares of elements along specified axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*v*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of coordinates</li>
<li><strong>*axes*</strong> &#8211; None or int or tuple of ints, optional
Axes or axes along which a sum is performed. The default (<em>axes</em> =
<code class="docutils literal"><span class="pre">None</span></code>) performs a sum over all the dimensions of the input array.
The value of <em>axes</em> may be negative, in which case it counts from the
last axis to the zeroth axis.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float, the sum of the squares of the elements of <em>v</em> along <em>axes</em></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="MDAnalysis.analysis.psa.get_msd_matrix">
<code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">get_msd_matrix</code><span class="sig-paren">(</span><em>P</em>, <em>Q</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#get_msd_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.get_msd_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the matrix of pairwise mean-squared deviations (MSDs) between
all pairs of points in <em>P</em> and <em>Q</em>, each pair having a point from <em>P</em> and a
point from <em>Q</em>.</p>
<p><em>P</em> (<em>Q</em>) is a <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of <span class="math">\(N_p\)</span> (<span class="math">\(N_q\)</span>) time
steps, <span class="math">\(N\)</span> atoms, and <span class="math">\(3N\)</span> coordinates (e.g.,
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.coordinates" title="MDAnalysis.core.AtomGroup.AtomGroup.coordinates"><code class="xref py py-meth docutils literal"><span class="pre">MDAnalysis.core.AtomGroup.AtomGroup.coordinates()</span></code></a>). The pairwise MSD
matrix has dimensions <span class="math">\(N_p\)</span> by <span class="math">\(N_q\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*P*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
<li><strong>*Q*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>numpy.ndarray</cite> of pairwise MSDs between points in <em>P</em> and points
in <em>Q</em></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">:class</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="MDAnalysis.analysis.psa.get_coord_axes">
<code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">get_coord_axes</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#get_coord_axes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.get_coord_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of atoms and the axes (<em>axis</em>) corresponding to atoms
and coordinates for a given path.</p>
<p>The <em>path</em> is assumed to be a <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> where the 0th axis
corresponds to a frame (a snapshot of coordinates). The <span class="math">\(3N\)</span>
(Cartesian) coordinates are assumed to be either:</p>
<blockquote>
<div><ol class="arabic simple">
<li>all in the 1st axis, starting with the x,y,z coordinates of the
first atom, followed by the <em>x</em>,*y*,*z* coordinates of the 2nd, etc.</li>
<li>in the 1st <em>and</em> 2nd axis, where the 1st axis indexes the atom
number and the 2nd axis contains the <em>x</em>,*y*,*z* coordinates of each
atom.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>*path*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(int, (int, ...)), the number of atoms and the axes containing coordinates</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="classes-methods-and-functions">
<h2>3.1.5.2. Classes, methods, and functions<a class="headerlink" href="#classes-methods-and-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="MDAnalysis.analysis.psa.get_path_metric_func">
<code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">get_path_metric_func</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#get_path_metric_func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.get_path_metric_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Selects a path metric function by name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>*name*</strong> &#8211; string, name of path metric</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The path metric function specified by <em>name</em> (if found).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="MDAnalysis.analysis.psa.hausdorff">
<code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">hausdorff</code><span class="sig-paren">(</span><em>P</em>, <em>Q</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#hausdorff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.hausdorff" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Hausdorff distance between two paths.</p>
<p><em>P</em> (<em>Q</em>) is a <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of <span class="math">\(N_p\)</span> (<span class="math">\(N_q\)</span>) time
steps, <span class="math">\(N\)</span> atoms, and <span class="math">\(3N\)</span> coordinates (e.g.,
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.coordinates" title="MDAnalysis.core.AtomGroup.AtomGroup.coordinates"><code class="xref py py-meth docutils literal"><span class="pre">MDAnalysis.core.AtomGroup.AtomGroup.coordinates()</span></code></a>). <em>P</em> (<em>Q</em>) has
either shape <span class="math">\(N_p \times N \times 3\)</span> (<span class="math">\(N_q \times N \times 3\)</span>), or <span class="math">\(N_p \times (3N)\)</span> (<span class="math">\(N_q \times (3N)\)</span>) in flattened form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*P*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
<li><strong>*Q*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float, the Hausdorff distance between paths <em>P</em> and <em>Q</em></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis.tests.datafiles</span> <span class="kn">import</span> <span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span><span class="n">DCD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s">&#39;name CA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>               <span class="n">ca</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[:</span><span class="n">mid</span><span class="p">:]</span>
<span class="gp">... </span>             <span class="p">])</span> <span class="c"># first half of trajectory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>               <span class="n">ca</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">mid</span><span class="p">::]</span>
<span class="gp">... </span>             <span class="p">])</span> <span class="c"># second half of trajectory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hausdorff</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
<span class="go">4.7786639840135905</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hausdorff</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c"># hausdorff distance w/ reversed 2nd trajectory</span>
<span class="go">4.7786639840135905</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="MDAnalysis.analysis.psa.hausdorff_wavg">
<code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">hausdorff_wavg</code><span class="sig-paren">(</span><em>P</em>, <em>Q</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#hausdorff_wavg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.hausdorff_wavg" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the weighted average Hausdorff distance between two paths.</p>
<p><em>P</em> (<em>Q</em>) is a <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of <span class="math">\(N_p\)</span> (<span class="math">\(N_q\)</span>) time
steps, <span class="math">\(N\)</span> atoms, and <span class="math">\(3N\)</span> coordinates (e.g.,
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.coordinates" title="MDAnalysis.core.AtomGroup.AtomGroup.coordinates"><code class="xref py py-meth docutils literal"><span class="pre">MDAnalysis.core.AtomGroup.AtomGroup.coordinates()</span></code></a>). <em>P</em> (<em>Q</em>) has
either shape <span class="math">\(N_p \times N \times 3\)</span> (<span class="math">\(N_q \times N \times 3\)</span>), or <span class="math">\(N_p \times (3N)\)</span> (<span class="math">\(N_q \times (3N)\)</span>) in flattened form. The nearest
neighbor distances for <em>P</em> (to <em>Q</em>) and those of <em>Q</em> (to <em>P</em>) are averaged
individually to get the average nearest neighbor distance for <em>P</em> and
likewise for <em>Q</em>. These averages are then summed and divided by 2 to get a
measure that gives equal weight to <em>P</em> and <em>Q</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*P*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
<li><strong>*Q*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float, the weighted average Hausdorff distance between paths <em>P</em> and <em>Q</em></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">Universe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis.tests.datafiles</span> <span class="kn">import</span> <span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span><span class="n">DCD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s">&#39;name CA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>               <span class="n">ca</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[:</span><span class="n">mid</span><span class="p">:]</span>
<span class="gp">... </span>             <span class="p">])</span> <span class="c"># first half of trajectory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>               <span class="n">ca</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">mid</span><span class="p">::]</span>
<span class="gp">... </span>             <span class="p">])</span> <span class="c"># second half of trajectory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hausdorff_wavg</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
<span class="go">2.5669644353703447</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hausdorff_wavg</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c"># weighted avg hausdorff dist w/ Q reversed</span>
<span class="go">2.5669644353703447</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="MDAnalysis.analysis.psa.hausdorff_avg">
<code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">hausdorff_avg</code><span class="sig-paren">(</span><em>P</em>, <em>Q</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#hausdorff_avg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.hausdorff_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the average Hausdorff distance between two paths.</p>
<p><em>P</em> (<em>Q</em>) is a <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of <span class="math">\(N_p\)</span> (<span class="math">\(N_q\)</span>) time
steps, <span class="math">\(N\)</span> atoms, and <span class="math">\(3N\)</span> coordinates (e.g.,
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.coordinates" title="MDAnalysis.core.AtomGroup.AtomGroup.coordinates"><code class="xref py py-meth docutils literal"><span class="pre">MDAnalysis.core.AtomGroup.AtomGroup.coordinates()</span></code></a>). <em>P</em> (<em>Q</em>) has
either shape <span class="math">\(N_p \times N \times 3\)</span> (<span class="math">\(N_q \times N \times 3\)</span>), or <span class="math">\(N_p \times (3N)\)</span> (<span class="math">\(N_q \times (3N)\)</span>) in flattened form. The nearest
neighbor distances for <em>P</em> (to <em>Q</em>) and those of <em>Q</em> (to <em>P</em>) are all
averaged together to get a mean nearest neighbor distance. This measure
biases the average toward the path that has more snapshots, whereas weighted
average Hausdorff gives equal weight to both paths.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*P*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
<li><strong>*Q*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float, the average Hausdorff distance between paths <em>P</em> and <em>Q</em></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis.tests.datafiles</span> <span class="kn">import</span> <span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span><span class="n">DCD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s">&#39;name CA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>               <span class="n">ca</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[:</span><span class="n">mid</span><span class="p">:]</span>
<span class="gp">... </span>             <span class="p">])</span> <span class="c"># first half of trajectory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>               <span class="n">ca</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">mid</span><span class="p">::]</span>
<span class="gp">... </span>             <span class="p">])</span> <span class="c"># second half of trajectory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hausdorff_avg</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
<span class="go">2.5669646575869005</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hausdorff_avg</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c"># hausdorff distance w/ reversed 2nd trajectory</span>
<span class="go">2.5669646575869005</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="MDAnalysis.analysis.psa.hausdorff_neighbors">
<code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">hausdorff_neighbors</code><span class="sig-paren">(</span><em>P</em>, <em>Q</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#hausdorff_neighbors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.hausdorff_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Hausdorff distance between two paths.</p>
<p><em>P</em> (<em>Q</em>) is a <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of <span class="math">\(N_p\)</span> (<span class="math">\(N_q\)</span>) time
steps, <span class="math">\(N\)</span> atoms, and <span class="math">\(3N\)</span> coordinates (e.g.,
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.coordinates" title="MDAnalysis.core.AtomGroup.AtomGroup.coordinates"><code class="xref py py-meth docutils literal"><span class="pre">MDAnalysis.core.AtomGroup.AtomGroup.coordinates()</span></code></a>). <em>P</em> (<em>Q</em>) has
either shape <span class="math">\(N_p \times N \times 3\)</span> (<span class="math">\(N_q \times N \times 3\)</span>), or <span class="math">\(N_p \times (3N)\)</span> (<span class="math">\(N_q \times (3N)\)</span>) in flattened form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*P*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
<li><strong>*Q*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">dictionary of two pairs of numpy arrays, the first pair containing the
indices of (Hausdorff) nearest neighbors for <em>P</em> and <em>Q</em>, respectively, the
second containing (corresponding) nearest neighbor distances for <em>P</em> and
<em>Q</em>, respectively</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="MDAnalysis.analysis.psa.discrete_frechet">
<code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">discrete_frechet</code><span class="sig-paren">(</span><em>P</em>, <em>Q</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#discrete_frechet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.discrete_frechet" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the discrete Frechet distance between two paths.</p>
<p><em>P</em> (<em>Q</em>) is a <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of <span class="math">\(N_p\)</span> (<span class="math">\(N_q\)</span>) time
steps, <span class="math">\(N\)</span> atoms, and <span class="math">\(3N\)</span> coordinates (e.g.,
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.coordinates" title="MDAnalysis.core.AtomGroup.AtomGroup.coordinates"><code class="xref py py-meth docutils literal"><span class="pre">MDAnalysis.core.AtomGroup.AtomGroup.coordinates()</span></code></a>). <em>P</em> (<em>Q</em>) has
either shape <span class="math">\(N_p \times N \times 3\)</span> (<span class="math">\(N_q \times N \times 3\)</span>), or :<span class="math">\(N_p \times (3N)\)</span> (<span class="math">\(N_q \times (3N)\)</span>) in flattened form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*P*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
<li><strong>*Q*</strong> &#8211; <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representing a path</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float, the discrete Frechet distance between paths <em>P</em> and <em>Q</em></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span><span class="n">DCD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s">&#39;name CA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>               <span class="n">ca</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[:</span><span class="n">mid</span><span class="p">:]</span>
<span class="gp">... </span>             <span class="p">])</span> <span class="c"># first half of trajectory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>               <span class="n">ca</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">mid</span><span class="p">::]</span>
<span class="gp">... </span>             <span class="p">])</span> <span class="c"># second half of trajectory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">discrete_frechet</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
<span class="go">4.7786639840135905</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">discrete_frechet</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c"># frechet distance w/ 2nd trj reversed 2nd</span>
<span class="go">6.8429011177113832</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="MDAnalysis.analysis.psa.dist_mat_to_vec">
<code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">dist_mat_to_vec</code><span class="sig-paren">(</span><em>N</em>, <em>i</em>, <em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#dist_mat_to_vec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.dist_mat_to_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert distance matrix indices (in the upper triangle) to the index of
the corresponding distance vector.</p>
<p>This is a convenience function to locate distance matrix elements (and the
pair generating it) in the corresponding distance vector. The row index <em>j</em>
should be greater than <em>i+1</em>, corresponding to the upper triangle of the
distance matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*N*</strong> &#8211; int, size of the distance matrix (of shape <em>N</em>-by-<em>N</em>)</li>
<li><strong>*i*</strong> &#8211; int, row index (starting at 0) of the distance matrix</li>
<li><strong>*j*</strong> &#8211; int, column index (starting at 0) of the distance matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">int, index (of the matrix element) in the corresponding distance vector</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="MDAnalysis.analysis.psa.PDBToBinaryTraj">
<em class="property">class </em><code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">PDBToBinaryTraj</code><span class="sig-paren">(</span><em>universe</em>, <em>output_type='.dcd'</em>, <em>infix=''</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PDBToBinaryTraj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PDBToBinaryTraj" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PDBToBinaryTraj.universe">
<code class="descname">universe</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PDBToBinaryTraj.universe" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> object with a trajectory</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PDBToBinaryTraj.frames">
<code class="descname">frames</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PDBToBinaryTraj.frames" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-attr docutils literal"><span class="pre">MDAnalysis.Universe.trajectory</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PDBToBinaryTraj.newname">
<code class="descname">newname</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PDBToBinaryTraj.newname" title="Permalink to this definition">¶</a></dt>
<dd><p>string, filename for converted trajectory, including file extension</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="MDAnalysis.analysis.psa.Path">
<em class="property">class </em><code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">Path</code><span class="sig-paren">(</span><em>universe</em>, <em>reference</em>, <em>ref_select='name CA'</em>, <em>path_select='all'</em>, <em>ref_frame=0</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#Path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.Path" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-process a <code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> object: (1) fit the
trajectory to a reference structure, (2) convert fitted time series to a
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representation of <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a>.</p>
<p>The analysis is performed with <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.run" title="MDAnalysis.analysis.psa.PSAnalysis.run"><code class="xref py py-meth docutils literal"><span class="pre">PSAnalysis.run()</span></code></a> and stores the result
in the <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> distance matrix <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.D" title="MDAnalysis.analysis.psa.PSAnalysis.D"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.D</span></code></a>.
<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.run" title="MDAnalysis.analysis.psa.PSAnalysis.run"><code class="xref py py-meth docutils literal"><span class="pre">PSAnalysis.run()</span></code></a> also generates a fitted trajectory and path from
alignment of the original trajectories to a reference structure.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.1.</span></p>
</div>
<p>Setting up trajectory alignment and fitted path generation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*universe*</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> object containing a trajectory</li>
<li><strong>*reference*</strong> &#8211; reference structure; <code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> object; if
<code class="docutils literal"><span class="pre">None</span></code> then <em>traj</em> is used (uses the current time step of the
object) [<code class="docutils literal"><span class="pre">None</span></code>]</li>
<li><strong>*ref_select*</strong> &#8211; <p>The selection to operate on for rms fitting; can be one of:</p>
<ol class="arabic">
<li>any valid selection string for
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.select_atoms" title="MDAnalysis.core.AtomGroup.AtomGroup.select_atoms"><code class="xref py py-meth docutils literal"><span class="pre">select_atoms()</span></code></a> that
produces identical selections in <em>mobile</em> and <em>reference</em>; or</li>
<li>a dictionary <code class="docutils literal"><span class="pre">{'mobile':sel1,</span> <span class="pre">'reference':sel2}</span></code> (the
<a class="reference internal" href="align.html#MDAnalysis.analysis.align.fasta2select" title="MDAnalysis.analysis.align.fasta2select"><code class="xref py py-func docutils literal"><span class="pre">MDAnalysis.analysis.align.fasta2select()</span></code></a> function returns
such a dictionary based on a <a class="reference external" href="http://www.clustal.org/">ClustalW</a> or <a class="reference external" href="http://www.compbio.dundee.ac.uk/manuals/stamp.4.2/">STAMP</a> sequence
alignment); or</li>
<li>a tuple <code class="docutils literal"><span class="pre">(sel1,</span> <span class="pre">sel2)</span></code></li>
</ol>
<p>When using 2. or 3. with <em>sel1</em> and <em>sel2</em> then these selections
can also each be a list of selection strings (to generate an
AtomGroup with defined atom order as described under
<a class="reference internal" href="../selections.html#ordered-selections-label"><span>Ordered selections</span></a>).</p>
</li>
<li><strong>*path_select*</strong> &#8211; atom selection composing coordinates of (fitted) path; if <code class="docutils literal"><span class="pre">None</span></code>
then <em>path_select</em> is set to <em>ref_select</em> [<code class="docutils literal"><span class="pre">None</span></code>]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.Path.u_original">
<code class="descname">u_original</code><a class="headerlink" href="#MDAnalysis.analysis.psa.Path.u_original" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> object with a trajectory</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.Path.u_reference">
<code class="descname">u_reference</code><a class="headerlink" href="#MDAnalysis.analysis.psa.Path.u_reference" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> object containing a reference structure</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.Path.ref_select">
<code class="descname">ref_select</code><a class="headerlink" href="#MDAnalysis.analysis.psa.Path.ref_select" title="Permalink to this definition">¶</a></dt>
<dd><p>string, selection for
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.select_atoms" title="MDAnalysis.core.AtomGroup.AtomGroup.select_atoms"><code class="xref py py-meth docutils literal"><span class="pre">select_atoms()</span></code></a> to select frame
from <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_reference" title="MDAnalysis.analysis.psa.Path.u_reference"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_reference</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.Path.path_select">
<code class="descname">path_select</code><a class="headerlink" href="#MDAnalysis.analysis.psa.Path.path_select" title="Permalink to this definition">¶</a></dt>
<dd><p>string, selection for
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.select_atoms" title="MDAnalysis.core.AtomGroup.AtomGroup.select_atoms"><code class="xref py py-meth docutils literal"><span class="pre">select_atoms()</span></code></a> to select atoms
to compose <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.Path.ref_frame">
<code class="descname">ref_frame</code><a class="headerlink" href="#MDAnalysis.analysis.psa.Path.ref_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>int, frame index to select frame from <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_reference" title="MDAnalysis.analysis.psa.Path.u_reference"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_reference</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.Path.u_fitted">
<code class="descname">u_fitted</code><a class="headerlink" href="#MDAnalysis.analysis.psa.Path.u_fitted" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> object with the fitted trajectory</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.Path.path">
<code class="descname">path</code><a class="headerlink" href="#MDAnalysis.analysis.psa.Path.path" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> object representation of the fitted trajectory</p>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.Path.fit_to_reference">
<code class="descname">fit_to_reference</code><span class="sig-paren">(</span><em>filename=None</em>, <em>prefix=''</em>, <em>postfix='_fit'</em>, <em>rmsdfile=None</em>, <em>targetdir='.'</em>, <em>mass_weighted=False</em>, <em>tol_mass=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#Path.fit_to_reference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.Path.fit_to_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Align each trajectory frame to the reference structure with
<a class="reference internal" href="align.html#MDAnalysis.analysis.align.rms_fit_trj" title="MDAnalysis.analysis.align.rms_fit_trj"><code class="xref py py-func docutils literal"><span class="pre">MDAnalysis.analysis.align.rms_fit_trj()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*filename*</strong> &#8211; file name for the RMS-fitted trajectory or pdb; defaults to the
original trajectory filename (from <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_original" title="MDAnalysis.analysis.psa.Path.u_original"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_original</span></code></a>) with
<em>prefix</em> prepended</li>
<li><strong>*prefix*</strong> &#8211; prefix for auto-generating the new output filename</li>
<li><strong>*rmsdfile*</strong> &#8211; file name for writing the RMSD time series [<code class="docutils literal"><span class="pre">None</span></code>]</li>
<li><strong>*mass_weighted*</strong> &#8211; do a mass-weighted RMSD fit</li>
<li><strong>*tol_mass*</strong> &#8211; Reject match if the atomic masses for matched atoms differ by more
than <em>tol_mass</em> [0.1]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>MDAnalysis.Universe</cite> object containing a fitted trajectory</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">:class</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.Path.get_num_atoms">
<code class="descname">get_num_atoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#Path.get_num_atoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.Path.get_num_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of atoms used to construct the <a class="reference internal" href="#MDAnalysis.analysis.psa.Path" title="MDAnalysis.analysis.psa.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a>.</p>
<p>Must run <a href="#id2"><span class="problematic" id="id3">:method:`Path.to_path()`</span></a> prior to calling this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">class:<cite>Path</cite></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int, the number of atoms in the</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.Path.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>align=False</em>, <em>filename=None</em>, <em>postfix='_fit'</em>, <em>rmsdfile=None</em>, <em>targetdir='.'</em>, <em>mass_weighted=False</em>, <em>tol_mass=0.1</em>, <em>flat=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#Path.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.Path.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a path from a trajectory and reference structure, aligning
to a reference structure if specified.</p>
<p>This is a convenience method to generate a fitted trajectory from an
inputted universe (<a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_original" title="MDAnalysis.analysis.psa.Path.u_original"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_original</span></code></a>) and reference structure
(<a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_reference" title="MDAnalysis.analysis.psa.Path.u_reference"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_reference</span></code></a>). <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.fit_to_reference" title="MDAnalysis.analysis.psa.Path.fit_to_reference"><code class="xref py py-meth docutils literal"><span class="pre">Path.fit_to_reference()</span></code></a> and
<a class="reference internal" href="#MDAnalysis.analysis.psa.Path.to_path" title="MDAnalysis.analysis.psa.Path.to_path"><code class="xref py py-meth docutils literal"><span class="pre">Path.to_path()</span></code></a> are used consecutively to generate a new universe
(<a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_fitted" title="MDAnalysis.analysis.psa.Path.u_fitted"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_fitted</span></code></a>) containing the fitted trajectory along with the
corresponding <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a> represented as an
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a>. The method returns a tuple of the topology name
and new trajectory name, which can be fed directly into an
<code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> object after unpacking the tuple using the
<code class="docutils literal"><span class="pre">*</span></code> operator, as in
<code class="docutils literal"><span class="pre">MDAnalysis.Universe(*(top_name,</span> <span class="pre">newtraj_name))</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*align*</strong> &#8211; Align trajectory to atom selection <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.ref_select" title="MDAnalysis.analysis.psa.Path.ref_select"><code class="xref py py-attr docutils literal"><span class="pre">Path.ref_select</span></code></a> of
<a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_reference" title="MDAnalysis.analysis.psa.Path.u_reference"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_reference</span></code></a>. If <code class="docutils literal"><span class="pre">True</span></code>, a universe containing an
aligned trajectory is produced with <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.fit_to_reference" title="MDAnalysis.analysis.psa.Path.fit_to_reference"><code class="xref py py-meth docutils literal"><span class="pre">Path.fit_to_reference()</span></code></a>
[<code class="docutils literal"><span class="pre">False</span></code>]</li>
<li><strong>*filename*</strong> &#8211; filename for the RMS-fitted trajectory or pdb; defaults to the
original trajectory filename (from <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_original" title="MDAnalysis.analysis.psa.Path.u_original"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_original</span></code></a>) with
<em>prefix</em> prepended</li>
<li><strong>*prefix*</strong> &#8211; prefix for auto-generating the new output filename</li>
<li><strong>*rmsdfile*</strong> &#8211; file name for writing the RMSD time series [<code class="docutils literal"><span class="pre">None</span></code>]</li>
<li><strong>*mass_weighted*</strong> &#8211; do a mass-weighted RMSD fit</li>
<li><strong>*tol_mass*</strong> &#8211; Reject match if the atomic masses for matched atoms differ by more
than <em>tol_mass</em> [0.1]</li>
<li><strong>*flat*</strong> &#8211; represent <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a> with 2D (<span class="math">\(N_p\times 3N\)</span>) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a>;
if <code class="docutils literal"><span class="pre">False</span></code> then <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a> is a 3D (<span class="math">\(N_p\times N\times 3\)</span>)
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> [<code class="docutils literal"><span class="pre">False</span></code>]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple of the topology name and new trajectory name.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.Path.to_path">
<code class="descname">to_path</code><span class="sig-paren">(</span><em>fitted=False</em>, <em>select=None</em>, <em>flat=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#Path.to_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.Path.to_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a coordinate time series from the fitted universe
trajectory.</p>
<p>Given a selection of <em>N</em> atoms from <em>select</em>, the atomic positions for
each frame in the fitted universe (<a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_fitted" title="MDAnalysis.analysis.psa.Path.u_fitted"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_fitted</span></code></a>) trajectory
(with <span class="math">\(N_p\)</span> total frames) are appended sequentially to form a 3D or 2D
(if <em>flat</em> is <code class="docutils literal"><span class="pre">True</span></code>) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> representation of the
fitted trajectory (with dimensions <span class="math">\(N_p\times N\times 3\)</span> or <span class="math">\(N_p\times 3N\)</span>, respectively).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*fitted*</strong> &#8211; construct a <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a> from the <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_fitted" title="MDAnalysis.analysis.psa.Path.u_fitted"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_fitted</span></code></a>
trajectory; if <code class="docutils literal"><span class="pre">False</span></code> then <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a> is generated with
the trajectory from <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_original" title="MDAnalysis.analysis.psa.Path.u_original"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_original</span></code></a> [<code class="docutils literal"><span class="pre">False</span></code>]</li>
<li><strong>*select*</strong> &#8211; the selection for constructing the coordinates of each frame in
<a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a>; if <code class="docutils literal"><span class="pre">None</span></code> then <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path_select" title="MDAnalysis.analysis.psa.Path.path_select"><code class="xref py py-attr docutils literal"><span class="pre">Path.path_select</span></code></a>
is used, else it is overridden by <em>select</em> [<code class="docutils literal"><span class="pre">None</span></code>]</li>
<li><strong>*flat*</strong> &#8211; represent <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a> as a 2D (<span class="math">\(N_p\times 3N\)</span>) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a>;
if <code class="docutils literal"><span class="pre">False</span></code> then <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a> is a 3D (<span class="math">\(N_p\times N\times 3\)</span>)
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> [<code class="docutils literal"><span class="pre">False</span></code>]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>numpy.ndarray</cite> representing a time series of atomic positions
of an <a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup" title="MDAnalysis.core.AtomGroup.AtomGroup"><code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.core.AtomGroup.AtomGroup</span></code></a> selection from
<code class="xref py py-attr docutils literal"><span class="pre">Path.u_fitted.trajectory</span></code></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">:class</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="MDAnalysis.analysis.psa.PSAPair">
<em class="property">class </em><code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">PSAPair</code><span class="sig-paren">(</span><em>npaths</em>, <em>i</em>, <em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAPair"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAPair" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate nearest neighbor and Hausdorff pair information between a pair
of paths from an all-pairs comparison generated by <code class="xref py py-class docutils literal"><span class="pre">PSA</span></code>.</p>
<p>The nearest neighbors for each path of a pair of paths is generated by
<code class="xref py py-meth docutils literal"><span class="pre">PSAPair.compute_nearest_neighbors()</span></code> and stores the result
in a dictionary (<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair.nearest_neighbors" title="MDAnalysis.analysis.psa.PSAPair.nearest_neighbors"><code class="xref py py-attr docutils literal"><span class="pre">nearest_neighbors</span></code></a>): each path has a
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of the frames of its nearest neighbors, and a
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of its nearest neighbor distances
<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.D" title="MDAnalysis.analysis.psa.PSAnalysis.D"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.D</span></code></a>. For example, <em>nearest_neighbors[&#8216;frames&#8217;]</em> is a pair
of <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a>, the first being the frames of the nearest
neighbors of the first path, <em>i</em>, the second being those of the second path,
<em>j</em>.</p>
<p>The Hausdorff pair for the pair of paths is found by calling
<code class="xref py py-meth docutils literal"><span class="pre">find_hausdorff_pair()</span></code> (locates the nearest neighbor pair having the
largest overall distance separating them), which stores the result in a
dictionary (<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair.hausdorff_pair" title="MDAnalysis.analysis.psa.PSAPair.hausdorff_pair"><code class="xref py py-attr docutils literal"><span class="pre">hausdorff_pair</span></code></a>) containing the frames (indices) of the
pair along with the corresponding (Hausdorff) distance.
<em>hausdorff_pair[&#8216;frame&#8217;]</em> contains a pair of frames in the first path, <em>i</em>,
and the second path, <em>j</em>, respectively, that correspond to the Hausdorff
distance between them.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.11.</span></p>
</div>
<p>Set up a <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a> for a pair of paths that are part of a
<code class="xref py py-class docutils literal"><span class="pre">PSA</span></code> comparison of <em>npaths</em> total paths.</p>
<p>Each unique pair of paths compared using <code class="xref py py-class docutils literal"><span class="pre">PSA</span></code> is related by
their nearest neighbors (and corresponding distances) and the Hausdorff
pair and distance. <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a> is a convenience class for
calculating and encapsulating nearest neighbor and Hausdorff pair
information for one pair of paths.</p>
<p>Given <em>npaths</em>, <code class="xref py py-class docutils literal"><span class="pre">PSA</span></code> performs and all-pairs comparison among all
paths for a total of :math:`    ext{npaths}*(   ext{npaths}-1)/2` unique
comparisons. If distances between paths are computed, the all-pairs
comparison can be summarized in a symmetric distance matrix whose upper
triangle can be mapped to a corresponding distance vector form in a
one-to-one manner. A particular comparison of a pair of paths in a
given instance of <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a> is thus unique identified by the row
and column indices in the distance matrix representation (whether or not
distances are actually computed), or a single ID (index) in the
corresponding distance vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*npaths*</strong> &#8211; int, total number of paths in <code class="xref py py-class docutils literal"><span class="pre">PSA</span></code> used to generate <em>this</em>
<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a></li>
<li><strong>*i*</strong> &#8211; int, row index (starting at 0) of the distance matrix</li>
<li><strong>*j*</strong> &#8211; int, column index (starting at 0) of the distance matrix</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAPair.npaths">
<code class="descname">npaths</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAPair.npaths" title="Permalink to this definition">¶</a></dt>
<dd><p>int, total number of paths in the comparison in which <em>this</em>
<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a> was generated</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAPair.matrix_id">
<code class="descname">matrix_id</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAPair.matrix_id" title="Permalink to this definition">¶</a></dt>
<dd><p>(int, int), (row, column) indices of the location of <em>this</em>
<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a> in the corresponding pairwise distance matrix</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAPair.pair_id">
<code class="descname">pair_id</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAPair.pair_id" title="Permalink to this definition">¶</a></dt>
<dd><p>int, ID of <em>this</em> <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a> (the pair_id:math:<cite>^text{th}</cite>
comparison) in the distance vector corresponding to the pairwise distance
matrix</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAPair.nearest_neighbors">
<code class="descname">nearest_neighbors</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAPair.nearest_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>dict, contains the nearest neighbors by frame index and the
nearest neighbor distances for each path in <em>this</em> <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAPair.hausdorff_pair">
<code class="descname">hausdorff_pair</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAPair.hausdorff_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>dict, contains the frame indices of the Hausdorff pair for each path in
<em>this</em> <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a> and the corresponding (Hausdorff) distance</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="MDAnalysis.analysis.psa.PSAnalysis">
<em class="property">class </em><code class="descclassname">MDAnalysis.analysis.psa.</code><code class="descname">PSAnalysis</code><span class="sig-paren">(</span><em>universes</em>, <em>reference=None</em>, <em>ref_select='name CA'</em>, <em>ref_frame=0</em>, <em>path_select=None</em>, <em>labels=None</em>, <em>targetdir=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Path Similarity Analysis (PSA) on a set of trajectories.</p>
<p>The analysis is performed with <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.run" title="MDAnalysis.analysis.psa.PSAnalysis.run"><code class="xref py py-meth docutils literal"><span class="pre">PSAnalysis.run()</span></code></a> and stores the result
in the <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> distance matrix <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.D" title="MDAnalysis.analysis.psa.PSAnalysis.D"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.D</span></code></a>.
<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.run" title="MDAnalysis.analysis.psa.PSAnalysis.run"><code class="xref py py-meth docutils literal"><span class="pre">PSAnalysis.run()</span></code></a> also generates a fitted trajectory and path from
alignment of the original trajectories to a reference structure.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.8.</span></p>
</div>
<p>Setting up Path Similarity Analysis.</p>
<p>The mutual similarity between all unique pairs of trajectories
are computed using a selected path metric.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*universes*</strong> &#8211; a list of universes (<code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> object), each
containing a trajectory</li>
<li><strong>*reference*</strong> &#8211; reference coordinates; <code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> object; if
<code class="docutils literal"><span class="pre">None</span></code> the first time step of the first item in <em>trajs</em> is used
[<code class="docutils literal"><span class="pre">None</span></code>]</li>
<li><strong>*ref_select*</strong> &#8211; <p>The selection to operate on; can be one of:</p>
<ol class="arabic">
<li>any valid selection string for
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.select_atoms" title="MDAnalysis.core.AtomGroup.AtomGroup.select_atoms"><code class="xref py py-meth docutils literal"><span class="pre">select_atoms()</span></code></a> that
produces identical selections in <em>mobile</em> and <em>reference</em>; or</li>
<li>a dictionary <code class="docutils literal"><span class="pre">{'mobile':sel1,</span> <span class="pre">'reference':sel2}</span></code> (the
<a class="reference internal" href="align.html#MDAnalysis.analysis.align.fasta2select" title="MDAnalysis.analysis.align.fasta2select"><code class="xref py py-func docutils literal"><span class="pre">MDAnalysis.analysis.align.fasta2select()</span></code></a> function returns
such a dictionary based on a <a class="reference external" href="http://www.clustal.org/">ClustalW</a> or <a class="reference external" href="http://www.compbio.dundee.ac.uk/manuals/stamp.4.2/">STAMP</a> sequence
alignment); or</li>
<li>a tuple <code class="docutils literal"><span class="pre">(sel1,</span> <span class="pre">sel2)</span></code></li>
</ol>
<p>When using 2. or 3. with <em>sel1</em> and <em>sel2</em> then these selections
can also each be a list of selection strings (to generate an
AtomGroup with defined atom order as described under
<a class="reference internal" href="../selections.html#ordered-selections-label"><span>Ordered selections</span></a>).</p>
</li>
<li><strong>*mass_weighted*</strong> &#8211; do a mass-weighted RMSD fit [<code class="docutils literal"><span class="pre">False</span></code>]</li>
<li><strong>*tol_mass*</strong> &#8211; Reject match if the atomic masses for matched atoms differ by more
than <em>tol_mass</em> [0.1]</li>
<li><strong>*ref_frame*</strong> &#8211; frame index to select frame from <em>reference</em> [0]</li>
<li><strong>*path_select*</strong> &#8211; atom selection composing coordinates of (fitted) path; if <code class="docutils literal"><span class="pre">None</span></code>
then <em>path_select</em> is set to <em>ref_select</em> [<code class="docutils literal"><span class="pre">None</span></code>]</li>
<li><strong>*targetdir*</strong> &#8211; output files are saved there [.]</li>
<li><strong>*labels*</strong> &#8211; list of strings, names of trajectories to be analyzed
(<code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code>); if <code class="docutils literal"><span class="pre">None</span></code>, defaults to trajectory
names [<code class="docutils literal"><span class="pre">None</span></code>]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.universes">
<code class="descname">universes</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.universes" title="Permalink to this definition">¶</a></dt>
<dd><p>list of <code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> objects containing trajectories</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.u_reference">
<code class="descname">u_reference</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.u_reference" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal"><span class="pre">MDAnalysis.Universe</span></code> object containing a reference structure</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.ref_select">
<code class="descname">ref_select</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.ref_select" title="Permalink to this definition">¶</a></dt>
<dd><p>string, selection for
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.select_atoms" title="MDAnalysis.core.AtomGroup.AtomGroup.select_atoms"><code class="xref py py-meth docutils literal"><span class="pre">select_atoms()</span></code></a> to select frame
from <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.u_reference" title="MDAnalysis.analysis.psa.PSAnalysis.u_reference"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.u_reference</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.path_select">
<code class="descname">path_select</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.path_select" title="Permalink to this definition">¶</a></dt>
<dd><p>string, selection for
<a class="reference internal" href="../core/AtomGroup.html#MDAnalysis.core.AtomGroup.AtomGroup.select_atoms" title="MDAnalysis.core.AtomGroup.AtomGroup.select_atoms"><code class="xref py py-meth docutils literal"><span class="pre">select_atoms()</span></code></a> to select atoms
to compose <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.ref_frame">
<code class="descname">ref_frame</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.ref_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>int, frame index to select frame from <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.u_reference" title="MDAnalysis.analysis.psa.Path.u_reference"><code class="xref py py-attr docutils literal"><span class="pre">Path.u_reference</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.filename">
<code class="descname">filename</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>string, name of file to store calculated distance matrix
(<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.D" title="MDAnalysis.analysis.psa.PSAnalysis.D"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.D</span></code></a>)</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.paths">
<code class="descname">paths</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.paths" title="Permalink to this definition">¶</a></dt>
<dd><p>list of <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> objects representing the set/ensemble of
fitted trajectories</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.D">
<code class="descname">D</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.D" title="Permalink to this definition">¶</a></dt>
<dd><p>string, name of file to store calculated distance matrix
(<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.D" title="MDAnalysis.analysis.psa.PSAnalysis.D"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.D</span></code></a>)</p>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.cluster">
<code class="descname">cluster</code><span class="sig-paren">(</span><em>distArray</em>, <em>method='ward'</em>, <em>count_sort=False</em>, <em>distance_sort=False</em>, <em>no_plot=False</em>, <em>no_labels=True</em>, <em>color_threshold=4</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.cluster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster trajectories and optionally plot the dendrogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>*method*</strong> &#8211; string, name of linkage criterion for clustering [<code class="docutils literal"><span class="pre">'ward'</span></code>]</li>
<li><strong>*no_plot*</strong> &#8211; boolean, if <code class="docutils literal"><span class="pre">True</span></code>, do not render the dendrogram [<code class="docutils literal"><span class="pre">False</span></code>]</li>
<li><strong>*no_labels*</strong> &#8211; boolean, if <code class="docutils literal"><span class="pre">True</span></code> then do not label dendrogram [<code class="docutils literal"><span class="pre">True</span></code>]</li>
<li><strong>*color_threshold*</strong> &#8211; For brevity, let t be the color_threshold. Colors all the
descendent links below a cluster node k the same color if k is
the first node below the cut threshold t. All links connecting
nodes with distances greater than or equal to the threshold are
colored blue. If t is less than or equal to zero, all nodes are
colored blue. If color_threshold is None or ‘default’,
corresponding with MATLAB(TM) behavior, the threshold is set to
0.7*max(Z[:,2]). [<code class="docutils literal"><span class="pre">4</span></code>]]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of indices representing the row-wise order of the objects
after clustering</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.generate_paths">
<code class="descname">generate_paths</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.generate_paths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.generate_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate paths, aligning each to reference structure if necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Keywords:</th><td class="field-body"><dl class="first last docutils">
<dt><em>align</em></dt>
<dd><p class="first last">Align trajectories to atom selection <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.ref_select" title="MDAnalysis.analysis.psa.PSAnalysis.ref_select"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.ref_select</span></code></a>
of <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.u_reference" title="MDAnalysis.analysis.psa.PSAnalysis.u_reference"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.u_reference</span></code></a> [<code class="docutils literal"><span class="pre">False</span></code>]</p>
</dd>
<dt><em>filename</em></dt>
<dd><p class="first last">strings representing base filename for fitted trajectories and
paths [<code class="docutils literal"><span class="pre">None</span></code>]</p>
</dd>
<dt><em>infix</em></dt>
<dd><p class="first last">additional tag string that is inserted into the output filename of
the fitted trajectory files [&#8216;&#8217;]</p>
</dd>
<dt><em>mass_weighted</em></dt>
<dd><p class="first last">do a mass-weighted RMSD fit</p>
</dd>
<dt><em>tol_mass</em></dt>
<dd><p class="first last">Reject match if the atomic masses for matched atoms differ by more
than <em>tol_mass</em></p>
</dd>
<dt><em>ref_frame</em></dt>
<dd><p class="first last">frame index to select frame from <em>reference</em></p>
</dd>
<dt><em>flat</em></dt>
<dd><p class="first last">represent <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a> as a 2D (<span class="math">\(N_p\times 3N\)</span>) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a>;
if <code class="docutils literal"><span class="pre">False</span></code> then <a class="reference internal" href="#MDAnalysis.analysis.psa.Path.path" title="MDAnalysis.analysis.psa.Path.path"><code class="xref py py-attr docutils literal"><span class="pre">Path.path</span></code></a> is a 3D (<span class="math">\(N_p\times N\times 3\)</span>)
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> [<code class="docutils literal"><span class="pre">False</span></code>]</p>
</dd>
<dt><em>save</em></dt>
<dd><p class="first last">boolean; if <code class="docutils literal"><span class="pre">True</span></code>, pickle list of names for fitted trajectories
[<code class="docutils literal"><span class="pre">True</span></code>]</p>
</dd>
<dt><em>store</em></dt>
<dd><p class="first last">boolean; if <code class="docutils literal"><span class="pre">True</span></code> then writes each path (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a>)
in <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.paths" title="MDAnalysis.analysis.psa.PSAnalysis.paths"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.paths</span></code></a> to compressed npz (numpy) files
[<code class="docutils literal"><span class="pre">False</span></code>]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>The fitted trajectories are written to new files in the
&#8220;/trj_fit&#8221; subdirectory in <code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.targetdir</span></code> named
&#8220;filename(<em>trajectory</em>)XXX*infix*_psa&#8221;, where &#8220;XXX&#8221; is a number between
000 and 999; the extension of each file is the same as its original.
Optionally, the trajectories can also be saved in numpy compressed npz
format in the &#8220;/paths&#8221; subdirectory in <code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.targetdir</span></code> for
persistence and can be accessed as the attribute
<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.paths" title="MDAnalysis.analysis.psa.PSAnalysis.paths"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.paths</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.get_num_atoms">
<code class="descname">get_num_atoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.get_num_atoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.get_num_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of atoms used to construct the <code class="xref py py-class docutils literal"><span class="pre">Path`s</span> <span class="pre">in</span>
<span class="pre">:class:`PSA</span></code>.</p>
<p>Must run <a href="#id4"><span class="problematic" id="id5">:method:`PSAnalysis.generate_paths()`</span></a> prior to calling this
method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">class:<cite>PSA</cite>&#8216;s :class:<a href="#id6"><span class="problematic" id="id7">`</span></a>Path`s&#8217;</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int, the number of atoms in</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.get_num_paths">
<code class="descname">get_num_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.get_num_paths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.get_num_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of paths in <code class="xref py py-class docutils literal"><span class="pre">PSA</span></code>.</p>
<p>Must run <a href="#id8"><span class="problematic" id="id9">:method:`PSAnalysis.generate_paths()`</span></a> prior to calling this
method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">class:<cite>PSA</cite></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int, the number of paths in</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.get_pairwise_distances">
<code class="descname">get_pairwise_distances</code><span class="sig-paren">(</span><em>vectorform=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.get_pairwise_distances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.get_pairwise_distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distance matrix (or vector) of pairwise path distances.</p>
<p>Must run <a href="#id10"><span class="problematic" id="id11">:method:`PSAnalysis.run(store=True)`</span></a> prior to calling this
method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>*vectorform*</strong> &#8211; boolean, if <code class="docutils literal"><span class="pre">True</span></code>, return the distance vector instead [<code class="docutils literal"><span class="pre">False</span></code>]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><cite>numpy.ndarray</cite> representation of the distance matrix (or
vector)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">:class</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.get_paths">
<code class="descname">get_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.get_paths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.get_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the paths in <code class="xref py py-class docutils literal"><span class="pre">PSA</span></code>.</p>
<p>Must run <a href="#id12"><span class="problematic" id="id13">:method:`PSAnalysis.generate_paths()`</span></a> prior to calling this
method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">class:<cite>numpy.ndarray</cite> representations of paths in
<code class="xref py py-class docutils literal"><span class="pre">PSA</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.hausdorff_pairs">
<code class="descname">hausdorff_pairs</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.hausdorff_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Hausdorff pair for each (unique) pairs of paths.</p>
<p>This method returns a list of Hausdorff pair information, where each
element is a dictionary containing the pair of frames and the
(Hausdorff) distance between a pair of paths. See
<a href="#id14"><span class="problematic" id="id15">:method:`PSAnalysis.psa_pairs`</span></a> and <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair.hausdorff_pair" title="MDAnalysis.analysis.psa.PSAPair.hausdorff_pair"><code class="xref py py-attr docutils literal"><span class="pre">PSAPair.hausdorff_pair</span></code></a> for
more information about accessing Hausdorff pair data.</p>
<p>Must run <a href="#id16"><span class="problematic" id="id17">:method:`PSAnalysis.run_pairs_analysis(hausdorff_pairs=True)`</span></a>
prior to calling this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of all Hausdorff pairs (in distance vector order)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.load">
<code class="descname">load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load fitted paths specified by &#8216;psa_path-names.pkl&#8217; in
<code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.targetdir</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.nearest_neighbors">
<code class="descname">nearest_neighbors</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.nearest_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the nearest neighbors for each (unique) pair of paths.</p>
<p>This method returns a list of nearest neighbor information, where each
element is a dictionary containing the nearest neighbor frames and
distances between a pair of paths. See <a href="#id18"><span class="problematic" id="id19">:method:`PSAnalysis.psa_pairs`</span></a>
and <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair.nearest_neighbors" title="MDAnalysis.analysis.psa.PSAPair.nearest_neighbors"><code class="xref py py-attr docutils literal"><span class="pre">PSAPair.nearest_neighbors</span></code></a> for more information about
accessing nearest neighbor data.</p>
<p>Must run <a href="#id20"><span class="problematic" id="id21">:method:`PSAnalysis.run_pairs_analysis(neighbors=True)`</span></a> prior
to calling this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of all nearest neighbors (in distance vector order)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>filename=None</em>, <em>linkage='ward'</em>, <em>count_sort=False</em>, <em>distance_sort=False</em>, <em>figsize=4.5</em>, <em>labelsize=12</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a clustered distance matrix using method <em>linkage</em> along with
the corresponding dendrogram. Rows (and columns) are identified using
the list of strings specified by <code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.labels</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*filename*</strong> &#8211; string, save figure to <em>filename</em> [<code class="docutils literal"><span class="pre">None</span></code>]</li>
<li><strong>*linkage*</strong> &#8211; string, name of linkage criterion for clustering [<code class="docutils literal"><span class="pre">'ward'</span></code>]</li>
<li><strong>*count_sort*</strong> &#8211; boolean, see scipy.cluster.hierarchy.dendrogram [<code class="docutils literal"><span class="pre">False</span></code>]</li>
<li><strong>*distance_sort*</strong> &#8211; boolean, see scipy.cluster.hierarchy.dendrogram [<code class="docutils literal"><span class="pre">False</span></code>]</li>
<li><strong>*figsize*</strong> &#8211; set the vertical size of plot in inches [<code class="docutils literal"><span class="pre">4.5</span></code>]</li>
<li><strong>*labelsize*</strong> &#8211; set the font size for colorbar labels; font size for path labels on
dendrogram default to 3 points smaller [<code class="docutils literal"><span class="pre">12</span></code>]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>If <em>filename</em> is supplied then the figure is also written to file (the
suffix determines the file type, e.g. pdf, png, eps, ...). All other
keyword arguments are passed on to <code class="xref py py-func docutils literal"><span class="pre">pylab.imshow()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.plot_annotated_heatmap">
<code class="descname">plot_annotated_heatmap</code><span class="sig-paren">(</span><em>filename=None</em>, <em>linkage='ward'</em>, <em>count_sort=False</em>, <em>distance_sort=False</em>, <em>figsize=8</em>, <em>annot_size=6.5</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.plot_annotated_heatmap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.plot_annotated_heatmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a clustered distance matrix using method <em>linkage</em> with
annotated distances in the matrix. Rows (and columns) are identified
using the list of strings specified by <code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.labels</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*filename*</strong> &#8211; string, save figure to <em>filename</em> [<code class="docutils literal"><span class="pre">None</span></code>]</li>
<li><strong>*count_sort*</strong> &#8211; boolean, see scipy.cluster.hierarchy.dendrogram [<code class="docutils literal"><span class="pre">False</span></code>]</li>
<li><strong>*distance_sort*</strong> &#8211; boolean, see scipy.cluster.hierarchy.dendrogram [<code class="docutils literal"><span class="pre">False</span></code>]</li>
<li><strong>*linkage*</strong> &#8211; string, name of linkage criterion for clustering [<code class="docutils literal"><span class="pre">'ward'</span></code>]</li>
<li><strong>*figsize*</strong> &#8211; set the vertical size of plot in inches [<code class="docutils literal"><span class="pre">8</span></code>]</li>
<li><strong>*annot_size*</strong> &#8211; float, font size of annotation labels on heat map [<code class="docutils literal"><span class="pre">6.5</span></code>]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>If <em>filename</em> is supplied then the figure is also written to file (the
suffix determines the file type, e.g. pdf, png, eps, ...). All other
keyword arguments are passed on to <code class="xref py py-func docutils literal"><span class="pre">pylab.imshow()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.plot_nearest_neighbors">
<code class="descname">plot_nearest_neighbors</code><span class="sig-paren">(</span><em>filename=None</em>, <em>idx=0</em>, <em>labels=('Path 1'</em>, <em>'Path 2')</em>, <em>figsize=4.5</em>, <em>multiplot=False</em>, <em>aspect_ratio=1.75</em>, <em>labelsize=12</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.plot_nearest_neighbors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.plot_nearest_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot nearest neighbor distances as a function of normalized frame
number (mapped to the interval <em>[0,1]</em>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*filename*</strong> &#8211; string, save figure to <em>filename</em> [<code class="docutils literal"><span class="pre">None</span></code>]</li>
<li><strong>*idx*</strong> &#8211; integer, index of path (pair) comparison to plot [<code class="docutils literal"><span class="pre">0</span></code>]</li>
<li><strong>*labels*</strong> &#8211; (string, string), pair of names to label nearest neighbor distance
curves [<code class="docutils literal"><span class="pre">('Path</span> <span class="pre">1',</span> <span class="pre">'Path</span> <span class="pre">2')</span></code>]</li>
<li><strong>*figsize*</strong> &#8211; float, set the vertical size of plot in inches [<code class="docutils literal"><span class="pre">4.5</span></code>]</li>
<li><strong>*multiplot*</strong> &#8211; boolean, set to <code class="docutils literal"><span class="pre">True</span></code> to enable plotting multiple nearest
neighbor distances on the same figure [<code class="docutils literal"><span class="pre">False</span></code>]</li>
<li><strong>*aspect_ratio*</strong> &#8211; float, set the ratio of width to height of the plot [<code class="docutils literal"><span class="pre">1.75</span></code>]</li>
<li><strong>*labelsize*</strong> &#8211; set the font size for colorbar labels; font size for path labels on
dendrogram default to 3 points smaller [<code class="docutils literal"><span class="pre">12</span></code>]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>If <em>filename</em> is supplied then the figure is also written to file (the
suffix determines the file type, e.g. pdf, png, eps, ...). All other
keyword arguments are passed on to <code class="xref py py-func docutils literal"><span class="pre">pylab.imshow()</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.psa_pairs">
<code class="descname">psa_pairs</code><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.psa_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of :class:<a href="#id22"><span class="problematic" id="id23">`</span></a>PSAPair`s for each pair of paths.</p>
<p><a href="#id24"><span class="problematic" id="id25">:method:`psa_pairs`</span></a> is a list of <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a> whose elements are
pairs of paths that have been compared using
<a href="#id26"><span class="problematic" id="id27">:method:`PSAnalysis.run_pairs_analysis()`</span></a>. Each <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a>
contains nearest neighbor and Hausdorff pair information specific to a
pair of paths. The nearest neighbor frames and distances for a
<a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair" title="MDAnalysis.analysis.psa.PSAPair"><code class="xref py py-class docutils literal"><span class="pre">PSAPair</span></code></a> can be accessed in the nearest neighbor dictionary
using the keys &#8216;frames&#8217; and &#8216;distances&#8217;, respectively. E.g.,
<code class="xref py py-attr docutils literal"><span class="pre">PSAPair.nearest_neighbors['distances']</span></code> returns a <em>pair</em> of
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> corresponding to the nearest neighbor distances
for each path. Similarly, Hausdorff pair information can be accessed
using <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAPair.hausdorff_pair" title="MDAnalysis.analysis.psa.PSAPair.hausdorff_pair"><code class="xref py py-attr docutils literal"><span class="pre">PSAPair.hausdorff_pair</span></code></a> with the keys &#8216;frames&#8217; and
&#8216;distance&#8217;.</p>
<p>Must run <a href="#id28"><span class="problematic" id="id29">:method:`PSAnalysis.run_pairs_analysis()`</span></a> prior to calling this
method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">class:<cite>PSAPair</cite> objects (in distance vector order)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of all</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform path similarity analysis on the trajectories to compute
the distance matrix.</p>
<p>A number of parameters can be changed from the defaults. The
result is stored as the array <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.D" title="MDAnalysis.analysis.psa.PSAnalysis.D"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.D</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Keywords:</th><td class="field-body"><dl class="first last docutils">
<dt><em>metric</em></dt>
<dd><p class="first last">selection string specifying the path metric to measure pairwise
distances among <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.paths" title="MDAnalysis.analysis.psa.PSAnalysis.paths"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.paths</span></code></a> [<code class="docutils literal"><span class="pre">'hausdorff'</span></code>]</p>
</dd>
<dt><em>start</em>, <em>stop</em>, <em>step</em></dt>
<dd><p class="first last">start and stop frame index with step size: analyze
<code class="docutils literal"><span class="pre">trajectory[start:stop:step]</span></code> [<code class="docutils literal"><span class="pre">None</span></code>]</p>
</dd>
<dt><em>store</em></dt>
<dd><p class="first last">boolean; if <code class="docutils literal"><span class="pre">True</span></code> then writes <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.D" title="MDAnalysis.analysis.psa.PSAnalysis.D"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.D</span></code></a> to text and
compressed npz (numpy) files [<code class="docutils literal"><span class="pre">True</span></code>]</p>
</dd>
<dt><em>filename</em></dt>
<dd><p class="first last">string, filename to save <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.D" title="MDAnalysis.analysis.psa.PSAnalysis.D"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.D</span></code></a></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.run_pairs_analysis">
<code class="descname">run_pairs_analysis</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.run_pairs_analysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.run_pairs_analysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform PSA Hausdorff (nearest neighbor) pairs analysis on all unique
pairs of paths in <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.paths" title="MDAnalysis.analysis.psa.PSAnalysis.paths"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.paths</span></code></a>.</p>
<p>Partial results can be stored in separate lists, where each list is
indexed according to distance vector convention (i.e., element <em>(i,j)</em>
in distance matrix representation corresponds to element
<span class="math">\(s=N*i+j-(i+1)*(i+2)\)</span> in distance vector representation, which is
the <span class="math">\(s^   ext{th}\)</span> comparison). For each unique pair of paths, the
nearest neighbors for that pair can be stored in <code class="xref py py-attr docutils literal"><span class="pre">NN</span></code> and the
Hausdorff pair in <code class="xref py py-attr docutils literal"><span class="pre">HP</span></code>. <code class="xref py py-attr docutils literal"><span class="pre">PP</span></code> stores the full information
of Hausdorff pairs analysis that is available for each pair of path,
including nearest neighbors lists and the Hausdorff pairs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Keywords:</th><td class="field-body"><dl class="first last docutils">
<dt><em>start</em>, <em>stop</em>, <em>step</em></dt>
<dd><p class="first last">start and stop frame index with step size: analyze
<code class="docutils literal"><span class="pre">trajectory[start:stop:step]</span></code> [<code class="docutils literal"><span class="pre">None</span></code>]</p>
</dd>
<dt><em>neighbors</em></dt>
<dd><p class="first last">boolean; if <code class="docutils literal"><span class="pre">True</span></code>, then stores dictionary of nearest neighbor
frames/distances in <code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.NN</span></code> [<code class="docutils literal"><span class="pre">False</span></code>]</p>
</dd>
<dt><em>hausdorff_pairs</em></dt>
<dd><p class="first last">boolean; if <code class="docutils literal"><span class="pre">True</span></code>, then stores dictionary of Hausdorff pair
frames/distances in <code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.HP</span></code> [<code class="docutils literal"><span class="pre">False</span></code>]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.save_paths">
<code class="descname">save_paths</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.save_paths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.save_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Save fitted <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.paths" title="MDAnalysis.analysis.psa.PSAnalysis.paths"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.paths</span></code></a> to numpy compressed npz files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>*filename*</strong> &#8211; string, specifies filename [<code class="docutils literal"><span class="pre">None</span></code>]</td>
</tr>
</tbody>
</table>
<p>The data are saved with <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.savez_compressed.html#numpy.savez_compressed" title="(in NumPy v1.9)"><code class="xref py py-func docutils literal"><span class="pre">numpy.savez_compressed()</span></code></a> in the directory
specified by <code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.targetdir</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="MDAnalysis.analysis.psa.PSAnalysis.save_result">
<code class="descname">save_result</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/MDAnalysis/analysis/psa.html#PSAnalysis.save_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#MDAnalysis.analysis.psa.PSAnalysis.save_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Save distance matrix <a class="reference internal" href="#MDAnalysis.analysis.psa.PSAnalysis.D" title="MDAnalysis.analysis.psa.PSAnalysis.D"><code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.D</span></code></a> to a numpy compressed npz
file and text file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>*filename*</strong> &#8211; string, specifies filename [<code class="docutils literal"><span class="pre">None</span></code>]</td>
</tr>
</tbody>
</table>
<p>The data are saved with <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.savez_compressed.html#numpy.savez_compressed" title="(in NumPy v1.9)"><code class="xref py py-func docutils literal"><span class="pre">numpy.savez_compressed()</span></code></a> and
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html#numpy.savetxt" title="(in NumPy v1.9)"><code class="xref py py-func docutils literal"><span class="pre">numpy.savetxt()</span></code></a> in the directory specified by
<code class="xref py py-attr docutils literal"><span class="pre">PSAnalysis.targetdir</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="hbond_analysis.html" title="3.2.1. Hydrogen Bond analysis — MDAnalysis.analysis.hbonds.hbond_analysis"
             >next</a> |</li>
        <li class="right" >
          <a href="rms.html" title="3.1.4. Calculating root mean square quantities — MDAnalysis.analysis.rms"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">MDAnalysis 0.12.1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../analysis_modules.html" >3. Analysis modules</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman, Jonathan Barnoud,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Matthieu Chavent, Xavier Deupi, Jan Domański, David L. Dotson
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Joe Jordan, Jinju Lu, Robert McGibbon, Alex Nesterenko,
    Manuel Nuno Melo, Caio S. Souza, Danny Parton, Joshua L. Phillips, Tyler Reddy,
    Paul Rigor, Sean L. Seyler, Andy Somogyi, Lukas Stelzl, Gorman Stock, Isaac Virshup,
    Zhuyi Xue, Carlos Yáñez S.,
    and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>