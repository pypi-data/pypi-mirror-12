\chapter{Module data}
\label{module:data}

\section{Reading a table from a file}

The module datafile contains the class \verb|datafile| which can be
used to read in a table from a file. You just have to construct an
instance and provide a filename as the parameter, e.g.
\verb|datafile("testdata")|. The parsing of the file, namely the
columns of the table, is done by matching regular expressions. They
can be modified, as they are additional named arguments of the
constructor. Furthermore there is the possibility to skip some of
the data points by some other keyword arguments as listed in the
following table:

\medskip
\begin{tabularx}{\linewidth}{l>{\raggedright\arraybackslash}X}
argument name&description\\
\hline
\texttt{commentpattern}&start a comment line; default: \texttt{re.compile(r"(\#+|!+|\%+)\textbackslash s*")}\\
\texttt{stringpattern}&a string column; default: \texttt{re.compile(r"\textbackslash"(.*?)\textbackslash"(\textbackslash s+|\$)}\\
\texttt{columnpattern}&any other column; default: \texttt{re.compile(r"(.*?)(\textbackslash s+|\$)}\\
\texttt{skiphead}&skip first data lines; default: \texttt{0}\\
\texttt{skiptail}&skip last data lines; default: \texttt{0}\\
\texttt{every}&only take every \texttt{every} data line into account; default: \texttt{1}
\end{tabularx}
\medskip

The processing of the input file is done by reading the file line by
line and first strip leading and tailing whitespaces of the line. Then
a check is performed, whether the line matches the comment pattern or
not. If it does match, this rest of the line is analysed like a table
line when no data was read before (otherwise it is just thrown away).
The result is interpreted as column titles. As the titles are
sequentially overwritten by another comment line previous to the data,
finally the last non-empty comment line determines the column titles.

Thus we have still to explain, how the reading of data lines works. We
create a list of entries for each column out of a given line. A line
resulting in an empty list (e.g. an empty line) is just ignored. As
shown in the table above, there is a special string column pattern.
When it matches it forces the interpretation of a column as a string.
Otherwise \verb|datafile| will try to convert the columns
automatically into floats except for the title line. When the
conversions fails, it just keeps the string.

The default string pattern allows for columns to contain whitespaces.
It matches a string whenever it starts with a quote (\verb|"|) and
then tries to find the end of that very string by another quote
immediately followed by a whitespace or the end of the line. Hence a
quote within a string is just ignored and no kind of escaping is
needed. The only disadvantage is, that you cannot describe a string
which contains a quote and a whitespace consecutively. However, you
can always replace this string pattern to fit your special needs.

Finally the number of columns is fixed to the maximal number contained
in the file and lines with less entries get filled with \verb|None|.
Also the titles list is cutted to this maximal number of columns.

\section{Accessing columns}

The method \verb|getcolumnno| takes a parameter as the column
description. If it matches exactly one entry in the titles list, the
number of this element is returned. Otherwise the parameter should be
an integer and it is checked, if this integer is a valid column index.
Like for other python indices a column number might be negative
counting the columns from the end. When an error occurres, the
exception \verb|ColumnError| is raised. Please note, that the datafile
inserts a first column having the index 0, which contains the line
number (starting at 1 and counting only data lines). Examples are
\verb|getcolumnno(1)| or \verb|getcolumnno("title")|.

The method \verb|getcolumn| takes the same argument as the method
\verb|getcolumnno| described above, but it returns a list with the
values of this very column.

\section{Mathematics on columns}

By the method \verb|addcolumn| a new column is appended. The method
takes a string as the first parameter which is interpreted as an
expression. When the expression contains an equal sign (\verb|=|),
everything left to the last equal sign will become the title of the
new column. If no equal sign is found, the title will be set to
\verb|None|. The part right to the last equal sign is interpreted as
an mathematical expression. A list of functions, predefined variables
and operators can be found in appendix~\ref{mathtree}. The list of
available functions and predefined variables can be extended by a
dictionary passed as the keyword argument \verb|context| to the
\verb|addcolumn| method.

The expression might contain variable names. The interpretation of
this names is done in the following way:
\begin{itemize}
\item The names can be a column title, but this is only allowed for
column titles which are valid variable names (e.g. they should start
with a letter or an underscore and contain only letters, digits and
the underscore).
\item A variable name can start with the dollar symbol (\verb|$|) and
the following integer number will directly refer to a column number.
\end{itemize}
The data referenced by variables in the expression need to be
floats, otherwise the result for that data line will be \verb|None|.

\section{Reading data from a sectioned config file}

The class \verb|sectionfile| provides a reader for files in the
ConfigFile format (see the description of the module \verb|ConfigFile|
from the pyx standard library).

\section{Own datafile readers}

The development of other datafile readers should be based on the
class \verb|data| by inheritance. When doing so, the methods
\verb|getcolumnno|, \verb|getcolumn|, and \verb|addcolumn| are
immediately available and the cooperation with other parts of \PyX{}
is assured. All what has to be done, is a call to the inherited
constructor supplying at least a sequence of data points as the
\verb|data| keyword argument. A data point itself is a sequence of
floats and/or strings. Additionally a sequence of column titles
(strings) might be given in the \verb|titles| argument.
